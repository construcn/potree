From 6d854e734f50bb53eade05d25d3e9bbe4bd06541 Mon Sep 17 00:00:00 2001
From: SathyaKrishna Vanama <sathyakrishna.vanama@constructn.ai>
Date: Wed, 19 Jul 2023 18:38:57 +0530
Subject: [PATCH 1/2] code changes after applying the patch file

---
 commands.txt                                  |   19 +
 examples/colorextension.js                    |  109 +
 examples/colorextension_optimized.js          |   52 +
 examples/dtwin_viewer_v0.html                 | 3603 +++++++
 examples/lion_las.html                        |  413 +-
 patch-constructN.patch                        | 9115 +++++++++++++++++
 src/modules/Images360/Images360.js            |  416 +-
 .../OrientedImages/OrientedImageControls.js   |   37 +-
 src/modules/OrientedImages/OrientedImages.js  |  903 +-
 src/navigation/OrbitControls.js               |  590 +-
 src/viewer/Scene.js                           |  885 +-
 src/viewer/map.js                             |    2 +-
 src/viewer/viewer.js                          |  172 +-
 13 files changed, 14815 insertions(+), 1501 deletions(-)
 create mode 100644 commands.txt
 create mode 100644 examples/colorextension.js
 create mode 100644 examples/colorextension_optimized.js
 create mode 100644 examples/dtwin_viewer_v0.html
 create mode 100644 patch-constructN.patch

diff --git a/commands.txt b/commands.txt
new file mode 100644
index 00000000..ddfbd1a3
--- /dev/null
+++ b/commands.txt
@@ -0,0 +1,19 @@
+curl -v 'https://developer.api.autodesk.com/authentication/v1/authenticate' -X 'POST' -H 'Content-Type: application/x-www-form-urlencoded' -d 'client_id=aJRMrmok5UAbsdsXjckJmSBmoNnYKLzM&client_secret=mSqemcEE53l4THBJ&grant_type=client_credentials&scope=data:read%20data:write%20viewables:read%20bucket:create%20bucket:read'
+
+eyJhbGciOiJSUzI1NiIsImtpZCI6IlU3c0dGRldUTzlBekNhSzBqZURRM2dQZXBURVdWN2VhIn0.eyJzY29wZSI6WyJkYXRhOnJlYWQiLCJkYXRhOndyaXRlIiwidmlld2FibGVzOnJlYWQiLCJidWNrZXQ6Y3JlYXRlIiwiYnVja2V0OnJlYWQiXSwiY2xpZW50X2lkIjoiYUpSTXJtb2s1VUFic2RzWGpja0ptU0Jtb05uWUtMek0iLCJhdWQiOiJodHRwczovL2F1dG9kZXNrLmNvbS9hdWQvYWp3dGV4cDYwIiwianRpIjoibk5iYVlqamRLME5OU1QzVndneHFtbEVVRFZaM1h0b2VydUtBM1FQSkxva2JQSVBMbWRaeWlQMUNIb2JnalZwUCIsImV4cCI6MTYyNTY1OTQ0NH0.CdolgqfI6YO4Bc7U7c3FGIR080fwlwDAXauXKPg4eqgjSdaYYdgK_ch-ahO-STi_Nl2p7a2TirotH3opgYp0CbyyXL6_fd8ETkk6eX0vKU0LOo7D6gk0CtigKWF7Xxta6icsWUM80lDNppYiSW1Cn1pWaAxHyQ4aSqfjlNVRdQ48V-d8MJ6VmbgCz57UyCcmUtkESrwgYzxOmvoVqwWDA72J6Uoj4gHU5pJnDjaOtzaOzIui11V1dgMZgsUkkoa1GpzarIsRKMeBGhyldTOD474pKn-L-vhM7qtfYjTbq24w9hHAHsnxWvuBdCMogwoWLh4mek4HPO72YpwTQAd8wA
+
+curl -v 'https://developer.api.autodesk.com/oss/v2/buckets' -X 'POST' -H 'Content-Type: application/json' -H 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsImtpZCI6Imp3dF9zeW1tZXRyaWNfa2V5In0.eyJjbGllbnRfaWQiOiJpWFdZbTNGVkdNaExZTHNzQVFBd2RNR01xNUhzQXdOYiIsImV4cCI6MTU4NTEyMTY0NSwic2NvcGUiOlsiZGF0YTpyZWFkIiwiZGF0YTp3cml0ZSIsInZpZXdhYmxlczpyZWFkIiwiYnVja2V0OmNyZWF0ZSIsImJ1Y2tldDpyZWFkIl0sImF1ZCI6Imh0dHBzOi8vYXV0b2Rlc2suY29tL2F1ZC9qd3RleHA2MCIsImp0aSI6Im10VklEWGtrOUJwUVBUYU84UlpEV3NWNWpCSHR3VkRObUIwVlN3dnJVeXFiNTVveFlibW5vaUNsMk02Vks4Ym4ifQ.71YkbtExiXDVkWeGODigBWGViNj9_5RSHwTjgvd_MME' -d '{"bucketKey":"threeforge","policyKey":"transient"}'
+digitaltwins
+Verify Bucket
+curl -v 'https://developer.api.autodesk.com/oss/v2/buckets/dtwin/details' -X 'GET' -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IlU3c0dGRldUTzlBekNhSzBqZURRM2dQZXBURVdWN2VhIn0.eyJzY29wZSI6WyJkYXRhOnJlYWQiLCJkYXRhOndyaXRlIiwidmlld2FibGVzOnJlYWQiLCJidWNrZXQ6Y3JlYXRlIiwiYnVja2V0OnJlYWQiXSwiY2xpZW50X2lkIjoiYUpSTXJtb2s1VUFic2RzWGpja0ptU0Jtb05uWUtMek0iLCJhdWQiOiJodHRwczovL2F1dG9kZXNrLmNvbS9hdWQvYWp3dGV4cDYwIiwianRpIjoibk5iYVlqamRLME5OU1QzVndneHFtbEVVRFZaM1h0b2VydUtBM1FQSkxva2JQSVBMbWRaeWlQMUNIb2JnalZwUCIsImV4cCI6MTYyNTY1OTQ0NH0.CdolgqfI6YO4Bc7U7c3FGIR080fwlwDAXauXKPg4eqgjSdaYYdgK_ch-ahO-STi_Nl2p7a2TirotH3opgYp0CbyyXL6_fd8ETkk6eX0vKU0LOo7D6gk0CtigKWF7Xxta6icsWUM80lDNppYiSW1Cn1pWaAxHyQ4aSqfjlNVRdQ48V-d8MJ6VmbgCz57UyCcmUtkESrwgYzxOmvoVqwWDA72J6Uoj4gHU5pJnDjaOtzaOzIui11V1dgMZgsUkkoa1GpzarIsRKMeBGhyldTOD474pKn-L-vhM7qtfYjTbq24w9hHAHsnxWvuBdCMogwoWLh4mek4HPO72YpwTQAd8wA'
+
+
+curl -v 'https://developer.api.autodesk.com/oss/v2/buckets/dtwin/objects/floor_4.ifc' -X 'PUT' -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IlU3c0dGRldUTzlBekNhSzBqZURRM2dQZXBURVdWN2VhIn0.eyJzY29wZSI6WyJkYXRhOnJlYWQiLCJkYXRhOndyaXRlIiwidmlld2FibGVzOnJlYWQiLCJidWNrZXQ6Y3JlYXRlIiwiYnVja2V0OnJlYWQiXSwiY2xpZW50X2lkIjoiYUpSTXJtb2s1VUFic2RzWGpja0ptU0Jtb05uWUtMek0iLCJhdWQiOiJodHRwczovL2F1dG9kZXNrLmNvbS9hdWQvYWp3dGV4cDYwIiwianRpIjoibk5iYVlqamRLME5OU1QzVndneHFtbEVVRFZaM1h0b2VydUtBM1FQSkxva2JQSVBMbWRaeWlQMUNIb2JnalZwUCIsImV4cCI6MTYyNTY1OTQ0NH0.CdolgqfI6YO4Bc7U7c3FGIR080fwlwDAXauXKPg4eqgjSdaYYdgK_ch-ahO-STi_Nl2p7a2TirotH3opgYp0CbyyXL6_fd8ETkk6eX0vKU0LOo7D6gk0CtigKWF7Xxta6icsWUM80lDNppYiSW1Cn1pWaAxHyQ4aSqfjlNVRdQ48V-d8MJ6VmbgCz57UyCcmUtkESrwgYzxOmvoVqwWDA72J6Uoj4gHU5pJnDjaOtzaOzIui11V1dgMZgsUkkoa1GpzarIsRKMeBGhyldTOD474pKn-L-vhM7qtfYjTbq24w9hHAHsnxWvuBdCMogwoWLh4mek4HPO72YpwTQAd8wA' -H 'Content-Type: application/octet-stream' -T 'floor_4.ifc'
+
+urn:adsk.objects:os.object:dtwin/floor_4.ifc
+
+dXJuOmFkc2sub2JqZWN0czpvcy5vYmplY3Q6ZHR3aW4vZmxvb3JfNC5pZmM=
+
+curl -X 'POST' -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IlU3c0dGRldUTzlBekNhSzBqZURRM2dQZXBURVdWN2VhIn0.eyJzY29wZSI6WyJkYXRhOnJlYWQiLCJkYXRhOndyaXRlIiwidmlld2FibGVzOnJlYWQiLCJidWNrZXQ6Y3JlYXRlIiwiYnVja2V0OnJlYWQiXSwiY2xpZW50X2lkIjoiYUpSTXJtb2s1VUFic2RzWGpja0ptU0Jtb05uWUtMek0iLCJhdWQiOiJodHRwczovL2F1dG9kZXNrLmNvbS9hdWQvYWp3dGV4cDYwIiwianRpIjoibk5iYVlqamRLME5OU1QzVndneHFtbEVVRFZaM1h0b2VydUtBM1FQSkxva2JQSVBMbWRaeWlQMUNIb2JnalZwUCIsImV4cCI6MTYyNTY1OTQ0NH0.CdolgqfI6YO4Bc7U7c3FGIR080fwlwDAXauXKPg4eqgjSdaYYdgK_ch-ahO-STi_Nl2p7a2TirotH3opgYp0CbyyXL6_fd8ETkk6eX0vKU0LOo7D6gk0CtigKWF7Xxta6icsWUM80lDNppYiSW1Cn1pWaAxHyQ4aSqfjlNVRdQ48V-d8MJ6VmbgCz57UyCcmUtkESrwgYzxOmvoVqwWDA72J6Uoj4gHU5pJnDjaOtzaOzIui11V1dgMZgsUkkoa1GpzarIsRKMeBGhyldTOD474pKn-L-vhM7qtfYjTbq24w9hHAHsnxWvuBdCMogwoWLh4mek4HPO72YpwTQAd8wA' -H 'Content-Type: application/json' -v 'https://developer.api.autodesk.com/modelderivative/v2/designdata/job' -d '{"input": {"urn": "dXJuOmFkc2sub2JqZWN0czpvcy5vYmplY3Q6ZHR3aW4vZmxvb3JfNC5pZmM="},"output":{"formats":[{"type":"svf","views":["2d","3d"]}]}}'
+
+curl -X 'GET' -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IlU3c0dGRldUTzlBekNhSzBqZURRM2dQZXBURVdWN2VhIn0.eyJzY29wZSI6WyJkYXRhOnJlYWQiLCJkYXRhOndyaXRlIiwidmlld2FibGVzOnJlYWQiLCJidWNrZXQ6Y3JlYXRlIiwiYnVja2V0OnJlYWQiXSwiY2xpZW50X2lkIjoiYUpSTXJtb2s1VUFic2RzWGpja0ptU0Jtb05uWUtMek0iLCJhdWQiOiJodHRwczovL2F1dG9kZXNrLmNvbS9hdWQvYWp3dGV4cDYwIiwianRpIjoibk5iYVlqamRLME5OU1QzVndneHFtbEVVRFZaM1h0b2VydUtBM1FQSkxva2JQSVBMbWRaeWlQMUNIb2JnalZwUCIsImV4cCI6MTYyNTY1OTQ0NH0.CdolgqfI6YO4Bc7U7c3FGIR080fwlwDAXauXKPg4eqgjSdaYYdgK_ch-ahO-STi_Nl2p7a2TirotH3opgYp0CbyyXL6_fd8ETkk6eX0vKU0LOo7D6gk0CtigKWF7Xxta6icsWUM80lDNppYiSW1Cn1pWaAxHyQ4aSqfjlNVRdQ48V-d8MJ6VmbgCz57UyCcmUtkESrwgYzxOmvoVqwWDA72J6Uoj4gHU5pJnDjaOtzaOzIui11V1dgMZgsUkkoa1GpzarIsRKMeBGhyldTOD474pKn-L-vhM7qtfYjTbq24w9hHAHsnxWvuBdCMogwoWLh4mek4HPO72YpwTQAd8wA' -v 'https://developer.api.autodesk.com/modelderivative/v2/designdata/dXJuOmFkc2sub2JqZWN0czpvcy5vYmplY3Q6ZHR3aW4vZmxvb3JfNC5pZmM=/manifest'
\ No newline at end of file
diff --git a/examples/colorextension.js b/examples/colorextension.js
new file mode 100644
index 00000000..a1bdf86f
--- /dev/null
+++ b/examples/colorextension.js
@@ -0,0 +1,109 @@
+///////////////////////////////////////////////////////////////////////////////
+// Autodesk.ADN.Viewing.Extension.Color
+//
+///////////////////////////////////////////////////////////////////////////////
+AutodeskNamespace("Autodesk.ADN.Viewing.Extension");
+Autodesk.ADN.Viewing.Extension.Color = function(viewer, options) {
+
+    Autodesk.Viewing.Extension.call(this, viewer, options);
+
+    var overlayName = "temperary-colored-overlay";
+    var _self = this;
+    var defMaterials = {}
+
+    _self.load = function() {
+
+        console.log('Autodesk.ADN.Viewing.Extension.Color loaded');
+        ///////////////////////////////////////////////////////////////////////////
+        // Generate GUID
+        //
+        ///////////////////////////////////////////////////////////////////////////
+        // function newGuid() {
+        //     var d = new Date().getTime();
+        //     var guid = 'xxxx-xxxx-xxxx-xxxx-xxxx'.replace(/[xy]/g, function(c) {
+        //         var r = (d + Math.random() * 16) % 16 | 0;
+        //         d = Math.floor(d / 16);
+        //         return (c == 'x' ? r : (r & 0x7 | 0x8)).toString(16);
+        //     });
+        //     return guid;
+        // };
+
+        ///////////////////////////////////////////////////////////////////////////
+        // add new material
+        //
+        ///////////////////////////////////////////////////////////////////////////
+        function addMaterial(color, name) {
+            var material =  new THREE.MeshPhongMaterial({side: THREE.DoubleSide, color, opacity: 1, transparent: false})
+            viewer.impl.matman().addMaterial(name, material);
+            // viewer.impl.createOverlayScene(name, material, material);
+            return material;
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Set color for nodes
+        // objectIds should be an array of dbId
+        // 
+        //
+        ///////////////////////////////////////////////////////////////////////////
+        Autodesk.Viewing.Viewer3D.prototype.setColorMaterial = function(objectIds, color, name) {
+            var material = addMaterial(color, name);
+            const frags = viewer.model.getFragmentList();
+            for (var i=0; i<objectIds.length; i++) {
+
+                var dbid = objectIds[i];
+
+                //from dbid to node, to fragid
+                var it = viewer.model.getData().instanceTree;
+
+                it.enumNodeFragments(dbid, function (fragId) {
+    
+                    defMaterials[dbid] = viewer.model.getFragmentList().getMaterial(fragId);
+                    // var renderProxy = viewer.impl.getRenderProxy(viewer.model, fragId);
+                    
+                    // renderProxy.meshProxy = new THREE.Mesh(renderProxy.geometry, renderProxy.material);
+
+                    // renderProxy.meshProxy.matrix.copy(renderProxy.matrixWorld);
+                    // renderProxy.meshProxy.matrixWorldNeedsUpdate = true;
+                    // renderProxy.meshProxy.matrixAutoUpdate = false;
+                    // renderProxy.meshProxy.frustumCulled = false;
+
+                    // viewer.impl.addOverlay(name, renderProxy.meshProxy);
+                    frags.setMaterial(fragId, material);
+                    viewer.impl.invalidate(true);
+                    
+                }, false);
+            }
+
+        }
+
+
+        Autodesk.Viewing.Viewer3D.prototype.restoreColorMaterial = function(objectIds) {
+       
+            const frags = viewer.model.getFragmentList();
+            for (var i=0; i<objectIds.length; i++) {
+
+                var dbid = objectIds[i];
+
+                //from dbid to node, to fragid
+                var it = viewer.model.getData().instanceTree;
+
+                it.enumNodeFragments(dbid, function (fragId) {
+                    if (defMaterials[dbid]) {
+                        frags.setMaterial(fragId, defMaterials[dbid]);
+                        viewer.impl.invalidate(true);
+                    }
+                    
+                }, false);
+            }
+  
+        }
+
+        _self.unload = function() {
+            console.log('Autodesk.ADN.Viewing.Extension.Color unloaded');
+            return true;
+        };
+    };
+};
+Autodesk.ADN.Viewing.Extension.Color.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
+Autodesk.ADN.Viewing.Extension.Color.prototype.constructor = Autodesk.ADN.Viewing.Extension.Color;
+Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.ADN.Viewing.Extension.Color', Autodesk.ADN.Viewing.Extension.Color);
\ No newline at end of file
diff --git a/examples/colorextension_optimized.js b/examples/colorextension_optimized.js
new file mode 100644
index 00000000..15ac71c9
--- /dev/null
+++ b/examples/colorextension_optimized.js
@@ -0,0 +1,52 @@
+AutodeskNamespace("Autodesk.ADN.Viewing.Extension");
+Autodesk.ADN.Viewing.Extension.Color = function(viewer, options) {
+
+    Autodesk.Viewing.Extension.call(this, viewer, options);
+
+    var overlayName = "temperary-colored-overlay";
+    var _self = this;
+    var defMaterials = {}
+    var materials = {}
+
+    _self.load = function() {
+
+        console.log('Autodesk.ADN.Viewing.Extension.Color loaded');
+        
+        function addMaterial(color, name) {
+            if (name in materials){
+                return materials[name]
+            } else {
+                console.log('Creating Material for ', name)
+                const material = new THREE.Vector4(color[0], color[1], color[2], color[3]);
+                materials[name] = material
+                return material;
+            }
+
+        }
+
+        Autodesk.Viewing.Viewer3D.prototype.setColorMaterial = function(objectIds, color, name) {
+            var material = addMaterial(color, name);
+            const frags = viewer.model.getFragmentList();
+            //from dbid to node, to fragid
+            var it = viewer.model.getData().instanceTree;
+            for (var i=0; i<objectIds.length; i++) {
+                var dbid = objectIds[i];
+                viewer.setThemingColor(dbid, material, null, true);
+            }
+            viewer.impl.invalidate(true);
+        }
+
+        Autodesk.Viewing.Viewer3D.prototype.restoreColorMaterial = function(objectIds) {
+            viewer.clearThemingColors();
+            viewer.impl.invalidate(true);
+        }
+
+        _self.unload = function() {
+            console.log('Autodesk.ADN.Viewing.Extension.Color unloaded');
+            return true;
+        };
+    };
+};
+Autodesk.ADN.Viewing.Extension.Color.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
+Autodesk.ADN.Viewing.Extension.Color.prototype.constructor = Autodesk.ADN.Viewing.Extension.Color;
+Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.ADN.Viewing.Extension.Color', Autodesk.ADN.Viewing.Extension.Color);
\ No newline at end of file
diff --git a/examples/dtwin_viewer_v0.html b/examples/dtwin_viewer_v0.html
new file mode 100644
index 00000000..0624ae6a
--- /dev/null
+++ b/examples/dtwin_viewer_v0.html
@@ -0,0 +1,3603 @@
+<!DOCTYPE html>
+<html lang="en">
+  <head>
+    <meta charset="utf-8" />
+    <meta name="description" content="" />
+    <meta name="author" content="" />
+    <meta
+      name="viewport"
+      content="width=device-width, initial-scale=1.0, user-scalable=no"
+    />
+    <title>Potree Viewer</title>
+
+    <link rel="stylesheet" type="text/css" href="../build/potree/potree.css" />
+    <link
+      rel="stylesheet"
+      type="text/css"
+      href="../libs/jquery-ui/jquery-ui.min.css"
+    />
+    <link rel="stylesheet" type="text/css" href="../libs/openlayers3/ol.css" />
+    <link
+      rel="stylesheet"
+      type="text/css"
+      href="../libs/spectrum/spectrum.css"
+    />
+    <link
+      rel="stylesheet"
+      type="text/css"
+      href="../libs/jstree/themes/mixed/style.css"
+    />
+    <link
+      rel="stylesheet"
+      href="https://developer.api.autodesk.com/modelderivative/v2/viewers/7.*/style.min.css"
+      type="text/css"
+    />
+    <script src="https://developer.api.autodesk.com/modelderivative/v2/viewers/7.*/viewer3D.min.js"></script>
+    <link
+      rel="stylesheet"
+      href="https://fonts.googleapis.com/icon?family=Material+Icons"
+    />
+    <link
+      rel="stylesheet"
+      href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css"
+    />
+    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
+    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
+    <script src="./colorextension_optimized.js"></script>
+    <script>
+      (function (h, o, t, j, a, r) {
+        h.hj =
+          h.hj ||
+          function () {
+            (h.hj.q = h.hj.q || []).push(arguments);
+          };
+        h._hjSettings = { hjid: 2746579, hjsv: 6 };
+        a = o.getElementsByTagName("head")[0];
+        r = o.createElement("script");
+        r.async = 1;
+        r.src = t + h._hjSettings.hjid + j + h._hjSettings.hjsv;
+        a.appendChild(r);
+      })(window, document, "https://static.hotjar.com/c/hotjar-", ".js?sv=");
+    </script>
+    <style>
+      .dropup .dropdown-menu,
+      .navbar-fixed-bottom .dropdown .dropdown-menu {
+        bottom: 5%;
+        background-color: rgba(34, 34, 34, 0.94);
+      }
+      .dropdown-menu {
+        min-width: 230px;
+        left: 50px;
+      }
+      .panoIcon {
+        background: greenyellow;
+        border-radius: 100%;
+        position: absolute;
+        z-index: 101;
+        opacity: 0.7;
+      }
+
+      .panoIcon:hover {
+        background: rgb(0, 217, 255);
+        cursor: pointer;
+        opacity: 1;
+      }
+
+      .userIcon {
+        width: 20px;
+        height: 20px;
+        position: absolute;
+        z-index: 1000;
+      }
+
+      .actionIcon {
+        font-size: 50px;
+        /* border-style: double; */
+        color: white;
+        border-radius: 10px;
+        background-color: rgba(34, 34, 34, 0.94);
+        display: inline-block;
+        position: relative;
+      }
+
+      .actionIcon:hover {
+        cursor: pointer;
+      }
+
+      .fpFullScreen {
+        position: absolute;
+        top: 1%;
+        right: 1%;
+      }
+
+      .fpFullScreen:hover {
+        cursor: pointer;
+      }
+
+      .actionButtons {
+        position: absolute;
+        bottom: 10px;
+        width: calc(100% - 20px);
+        height: 50px;
+        text-align: center;
+        z-index: 100;
+        display: none;
+      }
+
+      .floormap {
+        position: absolute;
+        right: 0px;
+        top: 10px;
+        z-index: 100;
+        display: none;
+      }
+
+      .goto3d {
+        right: 2%;
+        position: absolute;
+        display: none;
+      }
+
+      .noBIM {
+        background: #e1e1e1;
+        margin: 0 auto;
+        position: absolute;
+        z-index: 200;
+        top: 25%;
+        left: 25%;
+        height: calc(100% - 50%);
+        width: calc(100% - 50%);
+        padding: 30px;
+        -webkit-box-shadow: 0 0 10px rgba(0, 0, 0, 0.4);
+        -moz-box-shadow: 0 0 10px rgba(0, 0, 0, 0.4);
+        box-shadow: 0 0 10px rgba(0, 0, 0, 0.4);
+        display: none;
+        text-align: center;
+        vertical-align: middle;
+      }
+      .utility_icons {
+        position: relative;
+        cursor: pointer;
+        padding: 6px;
+        margin: 4px;
+        border: 1px solid rgba(34, 34, 34, 0);
+        border-radius: 4px;
+        display: inline-block;
+        padding-top: 3px;
+        font-size: 24px;
+        line-height: 1;
+        background-repeat: no-repeat;
+        background-position: 50%;
+      }
+      .actionButtonsTest {
+        color: #f4f4f4;
+        background-color: rgba(34, 34, 34, 0.94);
+        box-shadow: 1px 3px 10px 0 rgb(0 0 0 / 50%);
+        position: relative;
+        float: left;
+        cursor: pointer;
+        padding: 6px;
+        margin: 4px;
+        border: 1px solid rgba(34, 34, 34, 0);
+        border-radius: 4px;
+      }
+      .icon-test {
+        padding: 5px;
+      }
+      .icon-test:hover {
+        color: #f5ca52;
+        border: 1px solid #f5ca52;
+      }
+      .icon-test:focus {
+        color: #f5ca52;
+        outline: none;
+        border-radius: 3px;
+        box-shadow: inset 0 2px 2px 0 #000;
+      }
+      .s3-icon {
+        width: 30px;
+        height: 30px;
+        margin: 2px;
+      }
+      #datepickerLeft,
+      #datepickerRight {
+        color: #000;
+        padding: 4px;
+        margin-right: 5px;
+      }
+      .closeBtn {
+        position: absolute;
+        float: left;
+        z-index: 9;
+      }
+      .bim-legend-container {
+        right: 10px;
+        bottom: 10px;
+        position: absolute;
+        background-color: rgba(34, 34, 34, 0.94);
+        z-index: 2;
+        display: none;
+      }
+
+      .bim-legend {
+        list-style: none;
+      }
+      .bim-legend li {
+        margin-right: 10px;
+        color: #f4f4f4;
+        cursor: pointer;
+      }
+      .bim-legend span {
+        border: 1px solid #ccc;
+        float: left;
+        width: 12px;
+        height: 12px;
+        margin: 2px;
+      }
+      .bim-legend .not_started {
+        background-color: #ff0000;
+      }
+      .bim-legend .in_progress {
+        background-color: #f39b3a;
+      }
+      .bim-legend .complete {
+        background-color: #71e03a;
+      }
+
+      .bim-details-card {
+        float: right;
+        width: 20%;
+        /* background:rgb(249, 247, 249); */
+        right: 1%;
+        top: 50%;
+        height: 25%;
+        position: absolute;
+        z-index: 2;
+        display: none;
+      }
+
+      table {
+        font-family: arial, sans-serif;
+        border-collapse: collapse;
+        width: 100%;
+      }
+
+      td,
+      th {
+        border: 1px solid #dddddd;
+        text-align: left;
+        padding: 8px;
+        background-color: #dddddd;
+      }
+
+      .bim-card-close {
+        right: 0px;
+        top: 0px;
+        z-index: 2;
+        position: absolute;
+      }
+
+      .bim-card-close:hover {
+        /* background: rgb(0, 217, 255); */
+        cursor: pointer;
+        /* opacity: 1; */
+      }
+    </style>
+  </head>
+
+  <body>
+    <script src="../libs/jquery/jquery-3.1.1.min.js"></script>
+    <script src="../libs/spectrum/spectrum.js"></script>
+    <script src="../libs/jquery-ui/jquery-ui.min.js"></script>
+    <script src="../libs/other/BinaryHeap.js"></script>
+    <script src="../libs/tween/tween.min.js"></script>
+    <script src="../libs/d3/d3.js"></script>
+    <script src="../libs/proj4/proj4.js"></script>
+    <script src="../libs/openlayers3/ol.js"></script>
+    <script src="../libs/i18next/i18next.js"></script>
+    <script src="../libs/jstree/jstree.js"></script>
+    <script src="../build/potree/potree.js"></script>
+    <script src="../libs/plasio/js/laslaz.js"></script>
+
+    <div
+      id="viewer_1"
+      style="position: absolute; width: 100%; height: 100%; left: 0px; top: 0px"
+    >
+      <div id="fpContainer_1" class="floormap" onclick="actionIconClick()">
+        <i
+          title="fullscreen"
+          id="fp_fullscreen_1"
+          data='{"id": "viewer_1", "type": "fp_fullscreen"}'
+          class="material-icons fpFullScreen"
+          >fullscreen</i
+        >
+        <i
+          title="minimise"
+          id="fp_minimise_1"
+          data='{"id": "viewer_1", "type": "fp_fullscreen"}'
+          class="material-icons fpFullScreen"
+          style="display: none"
+          >fullscreen_exit</i
+        >
+        <canvas id="floormap_1"></canvas>
+      </div>
+      <div id="no_bim_1" class="noBIM">
+        <p>Data Not Available</p>
+      </div>
+      <div
+        id="bim_details_card_container_1"
+        class="bim-details-card"
+        onclick="actionIconClick()"
+      >
+        <i
+          data='{"id": "viewer_1", "type": "bim_card_close"}'
+          class="material-icons bim-card-close"
+          >clear</i
+        >
+        <div id="bim_details_card_1"></div>
+      </div>
+      <div
+        id="bim_legend_1"
+        class="bim-legend-container bim-legend"
+        onclick="actionIconClick()"
+      >
+        <li
+          id="bim_not_started"
+          data='{"id": "viewer_1", "type": "bim_legend"}'
+        >
+          <span class="not_started"></span> Not Started
+        </li>
+        <li
+          id="bim_in_progress"
+          data='{"id": "viewer_1", "type": "bim_legend"}'
+        >
+          <span class="in_progress"></span> In Progress
+        </li>
+        <li id="bim_complete" data='{"id": "viewer_1", "type": "bim_legend"}'>
+          <span class="complete"></span> Complete
+        </li>
+      </div>
+      <div
+        id="action_buttons_1"
+        onclick="actionIconClick()"
+        class="actionButtons"
+      >
+        <div class="dropup actionButtonsTest">
+          <input class="datepickerDigi" type="text" id="datepickerLeft" />
+        </div>
+        <div title="bim compare" class="dropup actionButtonsTest">
+          <img
+            id="bim_compare_view_1"
+            data='{"id": "viewer_1", "type":"bim-compare"}'
+            src="https://dtwin-viewers.s3.ap-south-1.amazonaws.com/icons/3d-bim1.png"
+            class="s3-icon"
+          />
+        </div>
+        <div class="dropup actionButtonsTest">
+          <i
+            title="timeline compare"
+            id="compare_view_1"
+            data='{"id": "viewer_1", "type": "compare"}'
+            class="material-icons icon-test"
+            >compare</i
+          >
+        </div>
+        <div class="dropup actionButtonsTest">
+          <i
+            title="point cloud"
+            id="3d_view_1"
+            data='{"id": "viewer_1", "type": "3d"}'
+            class="material-icons icon-test"
+            style="display: none"
+            >3d_rotation</i
+          >
+        </div>
+        <div class="dropup actionButtonsTest">
+          <i
+            title="show images"
+            id="cameras_on_1"
+            data='{"id": "viewer_1", "type": "cameras", "condition": "on"}'
+            class="material-icons icon-test"
+            style="display: none"
+            >photo_camera</i
+          >
+          <i
+            title="hide images"
+            id="cameras_off_1"
+            data='{"id": "viewer_1", "type": "cameras", "condition": "off"}'
+            class="material-icons icon-test"
+            style="display: none"
+            >no_photography</i
+          >
+        </div>
+
+        <div class="dropup actionButtonsTest">
+          <i
+            id="measure_top_1"
+            data='{"id": "viewer_1", "type": "measure"}'
+            title="measure"
+            data-toggle="dropdown"
+            class="material-icons icon-test"
+            >straighten</i
+          >
+          <ul id="measure_tool_1" class="dropdown-menu" style="margin: unset">
+            <i
+              title="point"
+              data='{"id": "viewer_1", "type": "point"}'
+              class="material-icons icon-test"
+              >gps_fixed</i
+            >
+            <i
+              title="distance"
+              data='{"id": "viewer_1", "type": "distance"}'
+              class="material-icons icon-test"
+              >timeline</i
+            >
+            <i
+              title="area"
+              data='{"id": "viewer_1", "type": "area"}'
+              class="material-icons icon-test"
+              >crop</i
+            >
+            <i
+              title="height"
+              data='{"id": "viewer_1", "type": "height"}'
+              class="material-icons icon-test"
+              >height</i
+            >
+            <i
+              title="clear"
+              data='{"id": "viewer_1", "type": "clear"}'
+              class="material-icons icon-test"
+              >clear</i
+            >
+            <i
+              title="save"
+              data='{"id": "viewer_1", "type": "save"}'
+              class="material-icons icon-test"
+              >save</i
+            >
+          </ul>
+        </div>
+      </div>
+    </div>
+    <div
+      id="viewer_2"
+      style="
+        position: absolute;
+        width: 50%;
+        height: 100%;
+        right: 0px;
+        top: 0px;
+        display: none;
+      "
+    >
+      <div id="fpContainer_2" class="floormap" onclick="actionIconClick()">
+        <i
+          title="fullscreen"
+          id="fp_fullscreen_2"
+          data='{"id": "viewer_2", "type": "fp_fullscreen"}'
+          class="material-icons fpFullScreen"
+          >fullscreen</i
+        >
+        <i
+          title="minimise"
+          id="fp_minimise_2"
+          data='{"id": "viewer_2", "type": "fp_fullscreen"}'
+          class="material-icons fpFullScreen"
+          style="display: none"
+          >fullscreen_exit</i
+        >
+        <canvas id="floormap_2"></canvas>
+      </div>
+      <div id="no_bim_2" class="noBIM">
+        <p>Data Not Available</p>
+      </div>
+
+      <div
+        id="bim_details_card_container_2"
+        class="bim-details-card"
+        onclick="actionIconClick()"
+      >
+        <i
+          data='{"id": "viewer_2", "type": "bim_card_close"}'
+          class="material-icons bim-card-close"
+          >clear</i
+        >
+        <div id="bim_details_card_2"></div>
+      </div>
+
+      <div
+        id="bim_legend_2"
+        class="bim-legend-container bim-legend"
+        onclick="actionIconClick()"
+      >
+        <li
+          title="not srated"
+          id="bim_not_started"
+          data='{"id": "viewer_2", "type": "bim_legend"}'
+        >
+          <span class="not_started"></span> Not Started
+        </li>
+        <li
+          title="in progress"
+          id="bim_in_progress"
+          data='{"id": "viewer_2", "type": "bim_legend"}'
+        >
+          <span class="in_progress"></span> In Progress
+        </li>
+        <li
+          title="completed"
+          id="bim_complete"
+          data='{"id": "viewer_2", "type": "bim_legend"}'
+        >
+          <span class="complete"></span> Complete
+        </li>
+      </div>
+      <div
+        id="action_buttons_2"
+        onclick="actionIconClick()"
+        class="actionButtons"
+      >
+        <div class="dropup actionButtonsTest">
+          <input class="datepickerDigi" type="text" id="datepickerRight" />
+        </div>
+        <div title="bim compare" class="dropup actionButtonsTest">
+          <img
+            id="bim_compare_view_2"
+            data='{"id": "viewer_2", "type" : "bim-compare"}'
+            src="https://dtwin-viewers.s3.ap-south-1.amazonaws.com/icons/3d-bim1.png"
+            class="s3-icon"
+          />
+        </div>
+        <div class="dropup actionButtonsTest">
+          <i
+            title="timeline compare"
+            id="compare_view_2"
+            data='{"id": "viewer_2", "type": "3d"}'
+            class="material-icons icon-test"
+            >compare</i
+          >
+        </div>
+        <div class="dropup actionButtonsTest">
+          <i
+            title="point cloud"
+            id="3d_view_2"
+            data='{"id": "viewer_2", "type": "3d"}'
+            class="material-icons icon-test"
+            style="display: none"
+            >3d_rotation</i
+          >
+        </div>
+
+        <div class="dropup actionButtonsTest">
+          <i
+            title="show images"
+            id="cameras_on_2"
+            data='{"id": "viewer_2", "type": "cameras", "condition": "on"}'
+            class="material-icons icon-test"
+            style="display: none"
+            >photo_camera</i
+          >
+          <i
+            title="hide images"
+            id="cameras_off_2"
+            data='{"id": "viewer_2", "type": "cameras", "condition": "off"}'
+            class="material-icons icon-test"
+            style="display: none"
+            >no_photography</i
+          >
+        </div>
+
+        <div class="dropup actionButtonsTest">
+          <i
+            id="measure_top_2"
+            data='{"id": "viewer_2", "type": "measure"}'
+            title="measure"
+            data-toggle="dropdown"
+            class="material-icons icon-test"
+            >straighten</i
+          >
+          <ul id="measure_tool_2" class="dropdown-menu" style="margin: unset">
+            <i
+              title="point"
+              data='{"id": "viewer_2", "type": "point"}'
+              class="material-icons icon-test"
+              >gps_fixed</i
+            >
+            <i
+              title="distance"
+              data='{"id": "viewer_2", "type": "distance"}'
+              class="material-icons icon-test"
+              >timeline</i
+            >
+            <i
+              title="area"
+              data='{"id": "viewer_2", "type": "area"}'
+              class="material-icons icon-test"
+              >crop</i
+            >
+            <i
+              title="height"
+              data='{"id": "viewer_2", "type": "height"}'
+              class="material-icons icon-test"
+              >height</i
+            >
+            <i
+              title="clear"
+              data='{"id": "viewer_2", "type": "clear"}'
+              class="material-icons icon-test"
+              >clear</i
+            >
+            <i
+              title="save"
+              data='{"id": "viewer_2", "type": "save"}'
+              class="material-icons icon-test"
+              >save</i
+            >
+          </ul>
+        </div>
+      </div>
+      <div class="closeBtn actionButtonsTest" onclick="actionIconClick()">
+        <i
+          title="close compare"
+          data='{"id": "viewer_2", "type": "compare-close"}'
+          class="material-icons icon-test"
+          >clear</i
+        >
+      </div>
+    </div>
+
+    <script type="module">
+      // http://localhost:4200/examples/tourWrapperAdv.html?project=16&snapshot1=12&snapshot2=11&isExterior=0&isFM=1&mode=compare_bim
+      // http://localhost:4200/examples/tourWrapperAdv.html?project=25&snapshot1=16&snapshot2=17&isExterior=1&isFM=0&mode=compare_bim
+
+      function getParameterByName(name, url = window.location.href) {
+        name = name.replace(/[\[\]]/g, "\\$&");
+        var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
+          results = regex.exec(url);
+        if (!results) return null;
+        if (!results[2]) return "";
+        return decodeURIComponent(results[2].replace(/\+/g, " "));
+      }
+
+      function doAPIcall(in_url, in_method, in_token) {
+        return new Promise((resolve, reject) => {
+          $.ajax({
+            url: in_url,
+            method: in_method,
+            headers: {
+              authorization: "Bearer " + in_token,
+            },
+
+            success: (rawData) => {
+              console.log(rawData);
+              resolve(rawData);
+            },
+            error: (e) => {
+              console.log(e);
+              resolve(null);
+            },
+          });
+        });
+      }
+      const mainProjectID = getParameterByName("project");
+      const structure_id = getParameterByName("structure");
+      const inTilesetID = getParameterByName("snapshot1");
+      const inTilesetID2 = getParameterByName("snapshot2");
+      // const isExterior = parseInt(getParameterByName('isExterior'));
+      // const isFloorMap = parseInt(getParameterByName('isFM'));
+      const mode = getParameterByName("mode");
+      const token = getParameterByName("token"); //'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiJVU1IzOTA4OTUiLCJmaXJzdE5hbWUiOiJLcmlzaG5hIFRlamEiLCJsYXN0TmFtZSI6IlRhbmdhdHVyaSIsImVtYWlsIjoia3RkYWlpY3RAZ21haWwuY29tIiwiY29udGFjdCI6eyJjb2RlIjoiKzkxIiwibnVtYmVyIjo5Njc2MzE2MzIzfSwiZG9iIjoiMTk4OS0wMi0xNlQwMDowMDowMC4wMDBaIiwidmVyaWZpZWQiOnRydWUsImNyZWF0ZWRBdCI6IjIwMjItMDMtMjJUMTI6MTY6MzAuODk0WiIsInVwZGF0ZWRBdCI6IjIwMjItMDMtMjJUMTI6MTc6NTMuMTIyWiIsIl9fdiI6MCwiZnVsbE5hbWUiOiJLcmlzaG5hIFRlamEgVGFuZ2F0dXJpIiwiYWdlIjozMywiaWF0IjoxNjUxNzY4MDExLCJleHAiOjE2NTE3NzE2MTF9.xJT4oa55tODe7KzK7YkYM62NrpgJfWzusbevVggL_Vg'
+      // const structure_id = 'STR772693' //getParameterByName('structure');
+      const inProjectID = structure_id;
+      const structure_id_details = await doAPIcall(
+        "https://api.dev.constructn.ai/api/v1/projects/" +
+          mainProjectID +
+          "/structures/" +
+          structure_id,
+        "GET",
+        token
+      );
+      console.log(
+        "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
+      );
+      // console.log(structure_id_details)
+
+      const isExterior = structure_id_details["result"]["isExterior"] ? 1 : 0;
+
+      const isFloorMap = structure_id_details["result"]["isExterior"] ? 0 : 1;
+
+      console.log("Exterior : ", isExterior);
+
+      const inputCamera = JSON.parse(getParameterByName("camera"));
+      console.log("Input Camera ", inputCamera);
+
+      const inputTag = JSON.parse(getParameterByName("tag"));
+      console.log("Input Tag", inputTag);
+
+      let isCompareMode = false;
+      let isMouseOnV1 = true;
+      let compareType = "potree";
+      let viewerMode = "image";
+      let syncPotreeEvent = false;
+      let syncForgeEvent = false;
+      let bimProgressData = {};
+      let bimProgressMode = false;
+      var tagToAddOnImageLoad = null;
+      let progress_walk_index = 0;
+      let progress_walk_mode = false;
+
+      let s3_bucket = "constructn-projects"; //'digitrack-projects'
+
+      import * as THREE from "../libs/three.js/build/three.module.js";
+      // initFirstPotree();
+      // window.compareMode = compareMode;
+      // window.loadSnapshot = loadSnapshot;
+      // window.closeCompareMode = closeCompareMode;
+      // window.addMeasure = addMeasure;
+      // window.removeMeasure = removeMeasure;
+      window.actionIconClick = actionIconClick;
+      window.locate = locate;
+      window.getInverse = getInverse;
+      window.select_group_bim = select_group_bim;
+      window.bimDefaultView = bimDefaultView;
+      window.remove_group_bim = remove_group_bim;
+      window.addTag = addTag;
+      window.start_progress_delta_walk = start_progress_delta_walk;
+      window.exit_progress_walk = exit_progress_walk;
+      window.update_progress_walk = update_progress_walk;
+
+      if (mode == "3d") {
+        initFirstPotree();
+      } else if (mode == "compare_3d") {
+        initFirstPotree();
+        compareMode("potree");
+      } else if (mode == "compare_bim") {
+        initFirstPotree();
+        compareMode("forge");
+      } else if (mode == "bim") {
+        viewerMode = "3d";
+        initForge(inProjectID, inTilesetID, "viewer_1", inputCamera);
+        // document.getElementById('fpContainer_2').style.display = 'none';
+      }
+
+      window.addEventListener("message", function (e) {
+        console.log("From Parent : ", e.data);
+        if (e.data.type == "getCamera") {
+          let cam = locate(viewer_1);
+          console.log("Sending Camera Details to Parent : ", cam);
+          window.top.postMessage(
+            { type: "camera", data: JSON.stringify(cam) },
+            "*"
+          );
+        } else if (e.data.type == "context") {
+          flyToContext(e.data.data);
+        } else if (e.data.type == "select-tag") {
+          let tagData = JSON.parse(e.data.data);
+          console.log(tagData);
+          flyToTagContext(tagData);
+        } else if (e.data.type == "bim-grouping") {
+          let data = e.data.data;
+          if (viewer_1.customtype == "forge") {
+            select_group_bim(data.guids, viewer_1, data.mode, data.condition);
+          } else if (compareMode && viewer_2.customtype == "forge") {
+            select_group_bim(data.guids, viewer_2, data.mode, data.condition);
+          }
+        } else if (e.data.type == "reset-bim-grouping") {
+          if (viewer_1.customtype == "forge") {
+            remove_group_bim(viewer_1, e.data.data.mode);
+          } else if (compareMode && viewer_2.customtype == "forge") {
+            remove_group_bim(viewer_2, e.data.data.mode);
+          }
+        }
+      });
+
+      function initFirstPotree() {
+        if (inTilesetID == "") {
+          document.getElementById("no_bim_1").style.display = "block";
+        } else {
+          window.viewer_1 = new Potree.Viewer(
+            document.getElementById("viewer_1")
+          );
+          viewer_1.setFOV(60);
+          viewer_1.setPointBudget(1 * 1000 * 1000);
+          document.title = "";
+          viewer_1.setEDLEnabled(false);
+          viewer_1.setBackground("gradient"); // ["skybox", "gradient", "black", "white"];
+          viewer_1.setDescription(``);
+          viewer_1.loadSettingsFromURL();
+          viewer_1.canvasId = "viewer_1";
+          viewer_1.customtype = "potree";
+
+          viewer_1.loadGUI(async () => {
+            viewer_1.setLanguage("en");
+            console.log("VIewer_1 Loaded");
+            viewer_1.fpContainerId = "fpContainer_1";
+            viewer_1.fpCanvasId = "floormap_1";
+            loadSnapshot(
+              viewer_1,
+              inProjectID,
+              inTilesetID,
+              false,
+              inputCamera
+            );
+            viewer_1.tileset = inTilesetID;
+            toggleVisibility("action_buttons_1", true);
+            addEventListeners();
+          });
+        }
+      }
+
+      function addEventListeners() {
+        document
+          .getElementById("viewer_1")
+          .addEventListener("mouseenter", () => {
+            isMouseOnV1 = true;
+          });
+        document
+          .getElementById("viewer_2")
+          .addEventListener("mouseenter", () => {
+            isMouseOnV1 = false;
+          });
+
+        document.addEventListener("imageLoad", (event) => {
+          console.log("imageLoad ", event.detail.viewer, event.detail.image);
+          viewer_1.scene.removeAllMeasurements();
+          if (isCompareMode && compareType == "potree") {
+            viewer_2.scene.removeAllMeasurements();
+          }
+          viewerMode = "image";
+          toggleVisibility("3d_view_1", true);
+          toggleVisibility("3d_view_2", true);
+
+          if (event.detail.viewer == "viewer_1") {
+            viewer_1.cur_loaded_image = event.detail.image.id;
+          } else {
+            viewer_2.cur_loaded_image = event.detail.image.id;
+          }
+
+          if (isCompareMode) {
+            if (compareType == "forge") {
+              setForgeControls("image");
+            } else {
+              maintainContext(event.detail.viewer, event.detail.image);
+            }
+          }
+          pointCloudView(true);
+
+          setTimeout(() => {
+            if (tagToAddOnImageLoad != null) {
+              console.log("Adding Tag");
+              console.log(tagToAddOnImageLoad["info"]);
+              addTag(
+                tagToAddOnImageLoad["info"],
+                tagToAddOnImageLoad["viewer"]
+              );
+              tagToAddOnImageLoad = null;
+            }
+          }, 100);
+        });
+
+        document.addEventListener("imageUnload", (event) => {
+          console.log("imageUnload ", event.detail.viewer);
+          toggleVisibility("3d_view_1", false);
+          toggleVisibility("3d_view_2", false);
+          viewer_1.scene.removeAllClipVolumes(); // To remove hovered image
+          viewer_1.scene.removeAllMeasurements();
+          viewer_1.cur_loaded_image = null;
+          if (isCompareMode) {
+            viewerMode = "3d";
+            if (isCompareMode && compareType == "potree") {
+              viewer_2.scene.removeAllMeasurements();
+            }
+            viewer_2.cur_loaded_image = null;
+            if (compareType == "forge") {
+              setForgeControls("orbit");
+            } else {
+              if (event.detail.viewer == "viewer_1") {
+                viewer_2.scene.orientedImages[0].release();
+              } else {
+                viewer_1.scene.orientedImages[0].release();
+              }
+              viewer_2.scene.removeAllClipVolumes(); // To remove hovered image
+            }
+            viewer_1.fitToScreen();
+            if (!isMouseOnV1) {
+              if (compareType == "potree") {
+                viewer_2.fitToScreen();
+              } else {
+                viewer_2.navigation.setRequestFitToView(true);
+              }
+            }
+            pointCloudView(false);
+          } else if (event.detail.viewer == "viewer_1") {
+            viewer_1.fitToScreen();
+            pointCloudView(false);
+            viewerMode = "3d";
+          }
+        });
+
+        let zoomHandler_1 = (e) => {
+          let fov_delta = e.wheelDelta < 0 ? -5 : 5;
+          let fov = viewer_1.getFOV() + fov_delta;
+          if (fov > 10 && fov < 100) {
+            viewer_1.setFOV(fov);
+          }
+          isCompareMode && syncViewers();
+        };
+
+        let zoomHandler_2 = (e) => {
+          let fov_delta = e.wheelDelta < 0 ? -5 : 5;
+          let fov = viewer_2.getFOV() + fov_delta;
+          if (fov > 10 && fov < 100) {
+            viewer_2.setFOV(fov);
+          }
+          isCompareMode && syncViewers();
+        };
+
+        document.addEventListener("panoLoad", (event) => {
+          console.log("panoLoad ", event.detail.viewer, event.detail.image);
+          viewerMode = "panorama";
+          viewer_1.renderArea.addEventListener("mousewheel", zoomHandler_1);
+          viewer_1.scene.removeAllMeasurements();
+          if (isCompareMode && compareType == "potree") {
+            viewer_2.renderArea.addEventListener("mousewheel", zoomHandler_2);
+            viewer_2.scene.removeAllMeasurements();
+          }
+          if (event.detail.viewer == "viewer_1") {
+            viewer_1.cur_loaded_image = event.detail.image.file
+              .split("/")
+              .pop();
+          } else {
+            viewer_2.cur_loaded_image = event.detail.image.file
+              .split("/")
+              .pop();
+          }
+          if (isCompareMode) {
+            if (compareType == "forge") {
+              setForgeControls("panorama");
+            } else {
+              maintainContext(event.detail.viewer, event.detail.image);
+            }
+          }
+          pointCloudView(true);
+
+          if (viewer_1.isFloorMap) {
+            toggleFloorMap(viewer_1, true);
+          }
+
+          if (isCompareMode && compareType == "potree" && viewer_2.isFloorMap) {
+            toggleFloorMap(viewer_2, true);
+          }
+
+          setTimeout(() => {
+            if (tagToAddOnImageLoad != null) {
+              console.log("Adding Tag");
+              console.log(tagToAddOnImageLoad["info"]);
+              addTag(
+                tagToAddOnImageLoad["info"],
+                tagToAddOnImageLoad["viewer"]
+              );
+              tagToAddOnImageLoad = null;
+            }
+          }, 100);
+        });
+
+        document.addEventListener("panoUnload", (event) => {
+          console.log("panoUnload ", event.detail.viewer);
+          viewer_1.cur_loaded_image = null;
+          viewer_1.scene.removeAllMeasurements();
+          viewer_1.renderArea.removeEventListener("mousewheel", zoomHandler_1);
+          if (isCompareMode) {
+            viewer_2.cur_loaded_image = null;
+            if (isCompareMode && compareType == "potree") {
+              viewer_2.renderArea.removeEventListener(
+                "mousewheel",
+                zoomHandler_2
+              );
+              viewer_2.scene.removeAllMeasurements();
+            }
+            viewerMode = "3d";
+            if (compareType == "forge") {
+              setForgeControls("orbit");
+            } else {
+              if (event.detail.viewer == "viewer_1") {
+                viewer_2.scene.images360[0].unfocus();
+              } else {
+                viewer_1.scene.images360[0].unfocus();
+              }
+            }
+            viewer_1.fitToScreen();
+            if (!isMouseOnV1) {
+              if (compareType == "potree") {
+                viewer_2.fitToScreen();
+              } else {
+                viewer_2.navigation.setRequestFitToView(true);
+              }
+            }
+            pointCloudView(false);
+
+            if (viewer_1.isFloorMap) {
+              toggleFloorMap(viewer_1, false);
+            }
+
+            if (compareType == "potree" && viewer_2.isFloorMap) {
+              toggleFloorMap(viewer_2, false);
+            }
+          } else if (event.detail.viewer == "viewer_1") {
+            viewer_1.fitToScreen();
+            pointCloudView(false);
+            if (viewer_1.isFloorMap) {
+              toggleFloorMap(viewer_1, false);
+            }
+            viewerMode = "3d";
+          }
+        });
+
+        // Keyboard Shortcuts
+
+        document.addEventListener("keydown", (event) => {
+          if (event.key === "Escape") {
+            // Exit in viewer 2 is already handled in contex maintanance
+            if (viewerMode == "image") {
+              viewer_1.controls.elExit.click();
+            }
+            // else if (viewerMode == 'panorama') {
+            //     viewer_1.scene.images360[0].unfocus();
+            // }
+          } else if (event.key === "ArrowUp") {
+            // up arrow
+            if (viewerMode == "image") {
+              viewer_1.controls.elUp.click();
+              if (isCompareMode && compareType == "potree") {
+                viewer_2.controls.elUp.click();
+              }
+            } else if (viewerMode == "panorama") {
+              if (event.ctrlKey) {
+                setPitch(viewer_1, 0.5);
+                if (isCompareMode && compareType == "potree") {
+                  setPitch(viewer_2, 0.5);
+                }
+              } else {
+                nextPanoImage(viewer_1);
+              }
+            }
+          } else if (event.key === "ArrowDown") {
+            // down arrow
+            if (viewerMode == "image") {
+              viewer_1.controls.elDown.click();
+              if (isCompareMode && compareType == "potree") {
+                viewer_2.controls.elDown.click();
+              }
+            } else if (viewerMode == "panorama") {
+              if (event.ctrlKey) {
+                setPitch(viewer_1, -0.5);
+                if (isCompareMode && compareType == "potree") {
+                  setPitch(viewer_2, -0.5);
+                }
+              }
+            }
+          } else if (event.key === "ArrowLeft") {
+            // left arrow
+            if (viewerMode == "image") {
+              viewer_1.controls.elLeft.click();
+              if (isCompareMode && compareType == "potree") {
+                viewer_2.controls.elLeft.click();
+              }
+            } else if (viewerMode == "panorama") {
+              setYaw(viewer_1, 0.5);
+              if (isCompareMode && compareType == "potree") {
+                setYaw(viewer_2, 0.5);
+              }
+            }
+          } else if (event.key === "ArrowRight") {
+            // right arrow
+            if (viewerMode == "image") {
+              viewer_1.controls.elRight.click();
+              if (isCompareMode && compareType == "potree") {
+                viewer_2.controls.elRight.click();
+              }
+            } else if (viewerMode == "panorama") {
+              setYaw(viewer_1, -0.5);
+              if (isCompareMode && compareType == "potree") {
+                setYaw(viewer_2, -0.5);
+              }
+            }
+          }
+        });
+
+        // document.addEventListener('mousedown', event => {
+        // 	sendSyncEvents = true;
+        // });
+        // document.addEventListener('mouseup', event => {
+        // 	sendSyncEvents = false;
+        // });
+
+        document.addEventListener("camerachange", (event) => {
+          syncPotreeEvent = true;
+        });
+      }
+
+      function pointCloudView(cond) {
+        viewer_1.setEDLEnabled(cond);
+        if (cond) {
+          viewer_1.setEDLOpacity(0);
+        } else {
+          viewer_1.setEDLOpacity(1);
+        }
+        if (isCompareMode && compareType == "potree") {
+          viewer_2.setEDLEnabled(cond);
+          if (cond) {
+            viewer_2.setEDLOpacity(0);
+          } else {
+            viewer_2.setEDLOpacity(1);
+          }
+        }
+      }
+
+      function maintainContext(viewerId, info) {
+        if (viewerMode == "image") {
+          let nearestImage = null;
+          let nearestImageDist = 10000;
+          if (viewerId == "viewer_1" && viewer_2.scene.orientedImages[0]) {
+            viewer_2.scene.orientedImages[0].images.forEach((image) => {
+              let curDist = image.position.distanceTo(info.position);
+              if (curDist < nearestImageDist) {
+                nearestImageDist = curDist;
+                nearestImage = image;
+              }
+            });
+            if (nearestImage) {
+              console.log(nearestImage.id);
+              viewer_2.scene.orientedImages[0].moveToImage(nearestImage, false);
+              viewer_2.cur_loaded_image = nearestImage.id;
+            }
+          } else if (viewer_1.scene.orientedImages[0]) {
+            viewer_1.scene.orientedImages[0].images.forEach((image) => {
+              let curDist = image.position.distanceTo(info.position);
+              if (curDist < nearestImageDist) {
+                nearestImageDist = curDist;
+                nearestImage = image;
+              }
+            });
+            if (nearestImage) {
+              console.log(nearestImage.id);
+              viewer_1.scene.orientedImages[0].moveToImage(nearestImage, false);
+              viewer_1.cur_loaded_image = nearestImage.id;
+            }
+          }
+        } else {
+          let nearestImage = null;
+          let nearestImageDist = 1000;
+          let inputPos = new THREE.Vector2().fromArray([
+            info.position[0],
+            info.position[1],
+          ]);
+          if (viewerId == "viewer_1") {
+            if (viewer_2.scene.images360[0]) {
+              viewer_2.scene.images360[0].images.forEach((pano) => {
+                let curPos = new THREE.Vector2().fromArray([
+                  pano.position[0],
+                  pano.position[1],
+                ]);
+                let curDist = curPos.distanceTo(inputPos);
+                if (curDist < nearestImageDist) {
+                  nearestImageDist = curDist;
+                  nearestImage = pano;
+                }
+              });
+              if (nearestImage) {
+                console.log(nearestImage.file);
+                viewer_2.scene.images360[0].focus(nearestImage, false);
+                viewer_2.cur_loaded_image = nearestImage.file.split("/").pop();
+              }
+            }
+          } else if (viewer_1.scene.images360[0]) {
+            viewer_1.scene.images360[0].images.forEach((pano) => {
+              let curPos = new THREE.Vector2().fromArray([
+                pano.position[0],
+                pano.position[1],
+              ]);
+              let curDist = curPos.distanceTo(inputPos);
+              if (curDist < nearestImageDist) {
+                nearestImageDist = curDist;
+                nearestImage = pano;
+              }
+            });
+            if (nearestImage) {
+              console.log(nearestImage.file);
+              viewer_1.scene.images360[0].focus(nearestImage, false);
+              viewer_1.cur_loaded_image = nearestImage.file.split("/").pop();
+            }
+          }
+        }
+      }
+
+      function getNearestImage(viewer, camInfo, mode) {
+        let nearestImage = null;
+        let nearestImageDist = 10000;
+        if (mode == "image") {
+          viewer.scene.orientedImages[0].images.forEach((image) => {
+            let curDist = image.position.distanceTo(camInfo.position);
+            if (curDist < nearestImageDist) {
+              nearestImageDist = curDist;
+              nearestImage = image;
+            }
+          });
+          if (nearestImage) {
+            console.log(nearestImage.id);
+            viewer.scene.orientedImages[0].moveToImage(nearestImage);
+          }
+        } else {
+          let inputPos = new THREE.Vector2().fromArray([
+            camInfo.position.x,
+            camInfo.position.y,
+          ]);
+          viewer.scene.images360[0].images.forEach((pano) => {
+            let curPos = new THREE.Vector2().fromArray([
+              pano.position[0],
+              pano.position[1],
+            ]);
+            let curDist = curPos.distanceTo(inputPos);
+            if (curDist < nearestImageDist) {
+              nearestImageDist = curDist;
+              nearestImage = pano;
+            }
+          });
+          if (nearestImage) {
+            console.log(nearestImage.file);
+            viewer.scene.images360[0].focus(nearestImage, true, camInfo);
+          }
+        }
+      }
+
+      function syncViewers() {
+        if (isCompareMode) {
+          if (viewerMode == "3d") {
+            if (isMouseOnV1) {
+              if (compareType == "potree") {
+                let v1Pos = viewer_1.scene.view.position.toArray();
+                viewer_2.scene.view.position.set(v1Pos[0], v1Pos[1], v1Pos[2]);
+                viewer_2.scene.view.lookAt(viewer_1.scene.view.getPivot());
+                viewer_2.setFOV(viewer_1.fov);
+              } else if (syncPotreeEvent) {
+                // Conditional syncing only for forge
+                viewer_2.navigation.setPosition(
+                  viewer_1.scene.view.position.clone()
+                );
+                viewer_2.navigation.setTarget(viewer_1.scene.view.getPivot());
+                viewer_2.navigation.setVerticalFov(viewer_1.fov, false);
+              }
+            } else {
+              if (compareType == "potree") {
+                let v2Pos = viewer_2.scene.view.position.toArray();
+                viewer_1.scene.view.position.set(v2Pos[0], v2Pos[1], v2Pos[2]);
+                viewer_1.scene.view.lookAt(viewer_2.scene.view.getPivot());
+                viewer_1.setFOV(viewer_2.fov);
+              } else if (syncForgeEvent) {
+                viewer_2.navigation.setCameraUpVector(
+                  new THREE.Vector3().fromArray([0, 0, 1])
+                );
+                const state = viewer_2.getState({ viewport: true }).viewport;
+                viewer_1.scene.view.position.set(
+                  state.eye[0],
+                  state.eye[1],
+                  state.eye[2]
+                );
+                viewer_1.scene.view.lookAt(
+                  new THREE.Vector3().fromArray(state.target)
+                );
+                viewer_1.setFOV(state.fieldOfView);
+                // viewer_2.navigation.setWorldUpVector(new THREE.Vector3().fromArray([0, 0, 1]), false);
+              }
+            }
+          } else if (viewerMode == "panorama" && compareType == "potree") {
+            if (isMouseOnV1) {
+              viewer_2.scene.view.pitch = viewer_1.scene.view.pitch;
+              viewer_2.scene.view.yaw = viewer_1.scene.view.yaw;
+              viewer_2.fov = viewer_1.fov;
+            } else {
+              viewer_1.scene.view.pitch = viewer_2.scene.view.pitch;
+              viewer_1.scene.view.yaw = viewer_2.scene.view.yaw;
+              viewer_1.fov = viewer_2.fov;
+            }
+          } else if (compareType == "forge" && syncPotreeEvent) {
+            // Do nothing if secondary viewer is potree
+            viewer_2.navigation.setPosition(
+              viewer_1.scene.view.position.clone()
+            );
+            viewer_2.navigation.setTarget(viewer_1.scene.view.getPivot());
+            viewer_2.navigation.setVerticalFov(viewer_1.fov, false);
+          }
+          syncPotreeEvent = false;
+          syncForgeEvent = false;
+        }
+      }
+
+      async function loadPointCloud(
+        viewer,
+        projectID,
+        tilesetID,
+        secondary = false,
+        inCamera
+      ) {
+        let pcMatrix = new THREE.Matrix4().set(
+          1,
+          0,
+          0,
+          0,
+          0,
+          1,
+          0,
+          0,
+          0,
+          0,
+          1,
+          0,
+          0,
+          0,
+          0,
+          1
+        );
+        let pcOffset = [0, 0, 0];
+        viewer["globalOffset"] = pcOffset;
+        const tm_json_raw = await fetch(
+          `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${projectID}/snapshots/${tilesetID}/pointcloud/tm.json`
+        );
+        if (tm_json_raw.status == 200) {
+          const tm_json = JSON.parse(await tm_json_raw.text());
+          if (tm_json.tm) {
+            pcMatrix = new THREE.Matrix4().fromArray(tm_json.tm).transpose();
+          }
+          if (tm_json.offset) {
+            pcOffset = tm_json.offset;
+          }
+          viewer["globalOffset"] = pcOffset;
+          if (inCamera) {
+            let pos = inCamera.position;
+            let tar = inCamera.target;
+            let offset = viewer.globalOffset;
+            inCamera.position = new THREE.Vector3(
+              pos[0] - offset[0],
+              pos[1] - offset[1],
+              pos[2] - offset[2]
+            );
+            inCamera.target = new THREE.Vector3(
+              tar[0] - offset[0],
+              tar[1] - offset[1],
+              tar[2] - offset[2]
+            );
+          }
+          console.log("PC TM Loaded", tm_json);
+        }
+
+        Potree.loadPointCloud(
+          `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${projectID}/snapshots/${tilesetID}/pointcloud/cloud.json`,
+          projectID + "_" + tilesetID,
+          (e) => {
+            let scene = viewer.scene;
+            let pointcloud = e.pointcloud;
+
+            let material = pointcloud.material;
+            material.size = 1;
+            material.pointSizeType = Potree.PointSizeType.FIXED;
+            material.shape = Potree.PointShape.SQUARE;
+            pointcloud.applyMatrix(pcMatrix);
+            const assetPosition = pointcloud.position.clone();
+            pointcloud.position.set(
+              assetPosition.x - pcOffset[0],
+              assetPosition.y - pcOffset[1],
+              assetPosition.z - pcOffset[2]
+            );
+            scene.addPointCloud(pointcloud);
+            viewer.fitToScreen();
+            console.log("Point Cloud Loaded");
+
+            let startWithImage = true;
+
+            if (inputTag && !inputTag.image) {
+              let startWithImage = false;
+              viewerMode = "3d";
+              flyToContext(inputTag.camera);
+            }
+
+            if (isExterior) {
+              console.log("Exterior Project");
+              loadDroneImages(
+                viewer,
+                projectID,
+                tilesetID,
+                { tm: pcMatrix, offset: pcOffset },
+                secondary,
+                inCamera,
+                startWithImage
+              );
+              if (viewer.canvasId == "viewer_1") {
+                document.getElementById("cameras_off_1").style.display =
+                  "inline-block";
+              } else {
+                document.getElementById("cameras_off_2").style.display =
+                  "inline-block";
+              }
+            } else {
+              console.log("Interior Project");
+              // loadPanoImages(viewer, projectID, tilesetID, {tm: pcMatrix, offset1: [232067.2387, 1936749.6433, 563], offset: pcOffset}, secondary);
+              loadPanoImages(
+                viewer,
+                projectID,
+                tilesetID,
+                { tm: new THREE.Matrix4(), offset: pcOffset },
+                secondary,
+                inCamera,
+                startWithImage
+              );
+            }
+          }
+        );
+      }
+
+      function loadDroneImages(
+        viewer,
+        projectID,
+        tilesetID,
+        tmatrix,
+        secondary,
+        inCamera,
+        showImage
+      ) {
+        const imageParamsPath = `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${projectID}/snapshots/${tilesetID}/images.json`;
+        const imagesPath = `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${projectID}/snapshots/${tilesetID}/images`;
+        Potree.OrientedImageLoader.load(
+          imageParamsPath,
+          imagesPath,
+          viewer,
+          tmatrix
+        ).then((images) => {
+          viewer.scene.addOrientedImages(images);
+          // setTimeout(() => {
+          if (showImage) {
+            if (secondary && viewerMode == "image") {
+              maintainContext(
+                "viewer_1",
+                viewer_1.scene.orientedImages[0].focused
+              );
+              pointCloudView(true);
+            } else if (!secondary) {
+              // setTimeout(() => {
+              if (inputTag) {
+                flyToTagContext(inputTag);
+              } else if (inCamera) {
+                if (Array.isArray(inCamera.position)) {
+                  inCamera.position = new THREE.Vector3().fromArray(
+                    inCamera.position
+                  );
+                  inCamera.target = new THREE.Vector3().fromArray(
+                    inCamera.target
+                  );
+                }
+                getNearestImage(viewer, inCamera, "image");
+              } else {
+                viewer.scene.orientedImages[0].moveToImage(
+                  viewer.scene.orientedImages[0].images[0]
+                );
+              }
+              // }, 2000);
+            }
+          }
+          // }, 2000);
+        });
+      }
+
+      function loadPanoImages(
+        viewer,
+        projectID,
+        tilesetID,
+        tmatrix,
+        secondary,
+        inCamera,
+        showImage
+      ) {
+        viewerMode = "panorama";
+        const imageParamsPath = `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${projectID}/snapshots/${tilesetID}/images.json`;
+        // const imageParamsPath = `http://localhost:1234/indoor_images_15_17_48_66.json`;
+        // const imagesPath = `https://localhost:1234`
+        const imagesPath = `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${projectID}/snapshots/${tilesetID}/images`;
+        Potree.Images360Loader.load(
+          imageParamsPath,
+          imagesPath,
+          viewer,
+          tmatrix
+        ).then((images) => {
+          viewer.scene.add360Images(images);
+          if (showImage) {
+            if (secondary && viewerMode == "panorama") {
+              maintainContext(
+                "viewer_1",
+                viewer_1.scene.images360[0].focusedImage
+              );
+              // pointCloudView(true);viewer_2.navigation.setCameraUpVector(new THREE.Vector3().fromArray([0, 0, 1]));
+            } else if (!secondary) {
+              if (inputTag) {
+                flyToTagContext(inputTag);
+              } else if (inCamera) {
+                getNearestImage(viewer, inCamera, "panorama");
+              } else {
+                viewer.scene.images360[0].focus(
+                  viewer.scene.images360[0].images[0]
+                );
+              }
+            }
+          }
+        });
+      }
+
+      function compareMode(type) {
+        let pid = inProjectID;
+        let tid = inTilesetID2;
+        if (isCompareMode) {
+          closeCompareMode();
+        }
+        compareType = type;
+        document.getElementById("viewer_1").style.width = "50%";
+        document.getElementById("viewer_2").style.display = "block";
+
+        isCompareMode = true;
+        if (type == "potree") {
+          initSecondPotree(pid, tid);
+        } else {
+          initForge(pid, inTilesetID, "viewer_2");
+          document.getElementById("fpContainer_2").style.display = "none";
+        }
+
+        if (viewer_1.isFloorMap) {
+          updateFPSize(viewer_1.floorMap);
+        }
+      }
+
+      function closeCompareMode() {
+        isCompareMode = false;
+        document.getElementById("viewer_1").style.width = "100%";
+        document.getElementById("viewer_2").style.display = "none";
+        if (compareType == "forge") {
+          viewer_2.finish();
+          viewer_2 = null;
+          Autodesk.Viewing.shutdown();
+        } else {
+          removeAssets(viewer_2);
+          viewer_2 = null;
+        }
+
+        if (viewer_1.isFloorMap) {
+          updateFPSize(viewer_1.floorMap);
+        }
+      }
+
+      function initSecondPotree(pid_2, tid_2) {
+        if (tid_2 == "") {
+          document.getElementById("no_bim_2").style.display = "block";
+          isCompareMode = false;
+        } else {
+          window.viewer_2 = new Potree.Viewer(
+            document.getElementById("viewer_2")
+          );
+          viewer_2.setFOV(60);
+          viewer_2.setPointBudget(1 * 1000 * 1000);
+          document.title = "";
+          viewer_2.setEDLEnabled(false);
+          viewer_2.setBackground("gradient"); // ["skybox", "gradient", "black", "white"];
+          viewer_2.setDescription(``);
+          viewer_2.loadSettingsFromURL();
+          viewer_2.canvasId = "viewer_2";
+          viewer_2.customtype = "potree";
+
+          viewer_2.loadGUI(async () => {
+            viewer_2.setLanguage("en");
+            console.log("Viewer_2 Loaded");
+            isCompareMode = true;
+            viewer_2.fpContainerId = "fpContainer_2";
+            viewer_2.fpCanvasId = "floormap_2";
+            loadSnapshot(viewer_2, pid_2, tid_2, true);
+            viewer_2.tileset = tid_2;
+            toggleVisibility("action_buttons_2", true);
+          });
+        }
+      }
+
+      function removeAssets(viewer) {
+        viewer.scene.scenePointCloud.remove(viewer.scene.pointclouds[0]);
+        viewer.scene.pointclouds = [];
+        if (viewer.scene.orientedImages.length) {
+          viewer.scene.orientedImages[0].release();
+          viewer.scene.orientedImages[0].images.forEach((image) => {
+            viewer.scene.scene.children[0].remove(image.mesh);
+            viewer.scene.scene.children[0].remove(image.line);
+          });
+          viewer.scene.scene.remove(viewer.scene.scene.children[0]);
+          viewer.scene.removeOrientedImages(viewer.scene.orientedImages[0]);
+        }
+
+        if (viewer.scene.images360.length) {
+          viewer.scene.images360[0].unfocus(false);
+          viewer.scene.images360[0].images.forEach((image) => {
+            viewer.scene.scene.children[0].remove(image.mesh);
+          });
+          viewer.scene.scene.children[0].remove(
+            viewer.scene.images360[0].sphere
+          );
+          viewer.scene.scene.remove(viewer.scene.scene.children[0]);
+          viewer.scene.remove360Images(viewer.scene.images360[0]);
+        }
+        if (viewer.isFloorMap) {
+          removeFloorMap(viewer);
+        }
+      }
+
+      function loadSnapshot(
+        viewer,
+        pid,
+        tid,
+        secondary = false,
+        inCamera = null
+      ) {
+        removeAssets(viewer);
+        loadPointCloud(viewer, pid, tid, secondary, inCamera);
+        isFloorMap &&
+          loadFloormap(
+            viewer.fpContainerId,
+            viewer.fpCanvasId,
+            viewer,
+            pid,
+            tid
+          );
+      }
+
+      function getAutodeskToken() {
+        return new Promise((resolve, reject) => {
+          $.ajax({
+            url: "https://developer.api.autodesk.com/authentication/v1/authenticate",
+            method: "POST",
+            headers: {
+              "Content-Type": "application/x-www-form-urlencoded",
+            },
+            data: {
+              client_id: "aJRMrmok5UAbsdsXjckJmSBmoNnYKLzM",
+              // client_id: 'iXWYm3FVGMhLYLssAQAwdMGMq5HsAwNb',
+              client_secret: "mSqemcEE53l4THBJ",
+              // client_Secret: 'hPvkyDrWToKUG8c3',
+              grant_type: "client_credentials",
+              scope: "data:read",
+            },
+            success: (rawData) => {
+              resolve(rawData);
+            },
+            error: (e) => {
+              resolve(null);
+            },
+          });
+        });
+      }
+
+      function pointerToRaycasterForge(domElement, camera, pointer) {
+        const pointerVector = new THREE.Vector3();
+        const pointerDir = new THREE.Vector3();
+        const ray = new THREE.Raycaster();
+        const rect = domElement.getBoundingClientRect();
+        const x = ((pointer.clientX - rect.left) / rect.width) * 2 - 1;
+        const y = -((pointer.clientY - rect.top) / rect.height) * 2 + 1;
+        if (camera.isPerspective) {
+          pointerVector.set(x, y, 0.5);
+          pointerVector.unproject(camera);
+          ray.set(
+            camera.position,
+            pointerVector.sub(camera.position).normalize()
+          );
+        } else {
+          pointerVector.set(x, y, -1);
+          pointerVector.unproject(camera);
+          pointerDir.set(0, 0, -1);
+          ray.set(
+            pointerVector,
+            pointerDir.transformDirection(camera.matrixWorld)
+          );
+        }
+        return ray;
+      }
+
+      function getAllDbIds(viewer) {
+        const { instanceTree } = viewer.model.getData();
+        const { dbIdToIndex } = instanceTree.nodeAccess;
+        return Object.keys(dbIdToIndex).map((dbId) => {
+          return parseInt(dbId);
+        });
+      }
+
+      function initForge(pid, tid, divId, inCamera = null) {
+        var options = {
+          env: "Local",
+          api: "derivativeV2", // for models uploaded to EMEA change this option to 'derivativeV2_EU'
+          getAccessToken: async function (onTokenReady) {
+            const res = await getAutodeskToken();
+            onTokenReady(res.access_token, res.expires_in);
+          },
+        };
+        Autodesk.Viewing.Initializer(options, function () {
+          var htmlDiv = document.getElementById(divId);
+
+          const config3d = {
+            extensions: ["Autodesk.ADN.Viewing.Extension.Color"],
+          };
+
+          if (
+            inProjectID == "161" ||
+            inProjectID == "165" ||
+            inProjectID == "166"
+          ) {
+            config3d["navToolsConfig"] = {
+              dollyScrollScale: 0.005,
+            };
+          } else if (inProjectID == "235") {
+            config3d["navToolsConfig"] = {
+              dollyScrollScale: 0.001,
+            };
+          }
+
+          let viewer = new Autodesk.Viewing.GuiViewer3D(htmlDiv, config3d);
+          window[divId] = viewer;
+          var startedCode = viewer.start();
+          viewer.canvasId = divId;
+          if (startedCode > 0) {
+            console.error("Failed to create a Viewer: WebGL not supported.");
+            return;
+          }
+          console.log("Initialization complete, loading a model next...");
+          // isCompareMode = true;
+
+          viewer.navigation.setWorldUpVector(
+            new THREE.Vector3().fromArray([0, 0, 1]),
+            false
+          );
+
+          viewer.navigation.setReverseZoomDirection(true);
+
+          localStorage.setItem(
+            "Autodesk.Viewing.Private.GuiViewer3D.SavedSettings.viewCube",
+            false
+          );
+          localStorage.setItem(
+            "Autodesk.Viewing.Private.GuiViewer3D.SavedSettings.groundShadow",
+            false
+          );
+
+          viewer.addEventListener(
+            Autodesk.Viewing.CAMERA_CHANGE_EVENT,
+            (event) => {
+              syncForgeEvent = true;
+            }
+          );
+
+          viewer.container.addEventListener("click", function (ev) {
+            const result = viewer.clientToWorld(ev.clientX, ev.clientY);
+            if (result) {
+              console.log("Click Point", result.point);
+            }
+          });
+
+          viewer.addEventListener(
+            Autodesk.Viewing.SELECTION_CHANGED_EVENT,
+            (event) => {
+              var currSelection = viewer.getSelection();
+              console.log("Selection: ");
+
+              if (currSelection.length && bimProgressData[viewer.canvasId]) {
+                let guid =
+                  bimProgressData[viewer.canvasId]["dbtoguid"][
+                    currSelection[0]
+                  ];
+                let progress =
+                  bimProgressData[viewer.canvasId]["progress"][guid];
+
+                console.log(
+                  "dbid: ",
+                  currSelection[0],
+                  "guid: ",
+                  guid,
+                  "progress: ",
+                  progress
+                );
+
+                // let card_container_id = divId == 'viewer_1' ? 'bim_details_card_container_1' : 'bim_details_card_container_2'
+                // let card_id = divId == 'viewer_1' ? 'bim_details_card_1' : 'bim_details_card_2'
+                // let card_container = document.getElementById(card_container_id);
+                // let card = document.getElementById(card_id);
+                // let card_details = '<table>'
+                // card_details += `<tr> <td>    </td> <td>    </td> </tr>`
+                // card_details += `<tr> <td> GUID </td> <td> ${guid} </td> </tr>`
+                // card_details += `<tr> <td> Progress </td> <td> ${progress} </td> </tr>`
+
+                // card_details += '</table>'
+                // card.innerHTML = card_details;
+                // card_container.style.display = 'block';
+                let bim_element_details = { guid: guid, progress: progress };
+                window.top.postMessage(
+                  {
+                    type: "bim-click",
+                    data: JSON.stringify(bim_element_details),
+                  },
+                  "*"
+                );
+                console.log("Sending ", bim_element_details);
+
+                // const pointer = event.pointers ? event.pointers[0] : event;
+                // const rayCaster = pointerToRaycasterForge(viewer.canvas, viewer.navigation.getCamera(), pointer);
+                // const forgeClickObject = viewer.model.rayIntersect(rayCaster, true, this.getAllDbIds(viewer));
+                // console.log('Click point')
+                // console.log(forgeClickObject)
+
+                // const result = viewer.clientToWorld(event.clientX, event.clientY);
+                // if (result) {
+                // 	console.log(result.point);
+                // }
+              } else {
+                window.top.postMessage(
+                  { type: "bim-click", data: JSON.stringify({}) },
+                  "*"
+                );
+                // closeBimDetailsCard(divId);
+              }
+            }
+          );
+
+          viewer.customtype = "forge";
+          loadBIM(viewer, pid, tid, inCamera);
+        });
+      }
+
+      function closeBimDetailsCard(viewer_id) {
+        let container_id =
+          viewer_id == "viewer_1"
+            ? "bim_details_card_container_1"
+            : "bim_details_card_container_2";
+        let card = document.getElementById(container_id);
+        card.style.display = "none";
+        viewer_id == "viewer_1"
+          ? viewer_1.clearSelection()
+          : viewer_2.clearSelection();
+      }
+
+      async function loadBIM(viewer, pid, tid, inCamera) {
+        // let path = `http://localhost:1234/0.svf`;
+        let path = `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${pid}/forge/model/0.svf`;
+        const modelOptions = { applyScaling: "m" };
+        modelOptions.globalOffset = { x: 0, y: 0, z: 0 };
+        let globalOff = [0, 0, 0];
+        viewer["globalOffset"] = globalOff;
+        viewer["properties_child"] = ["GLOBALID", "NAME"];
+        viewer["properties_head"] = ["IFC"];
+
+        const tm_json_raw = await fetch(
+          `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${pid}/forge/tm_forge.json`
+        );
+        if (tm_json_raw.status == 200) {
+          const tm_json = JSON.parse(await tm_json_raw.text());
+          if (tm_json.tm) {
+            modelOptions.placementTransform = new THREE.Matrix4()
+              .fromArray(tm_json.tm)
+              .transpose();
+            // modelOptions.placementTransform = new THREE.Matrix4().fromArray([0.216,1.022,-0.007,367033.477,-1.022,0.216,-0.001,2053135.281,-0.000,0.007,1.045,-57.5,0.000,0.000,0.000,1.000]).transpose()
+            console.log("BIM TM Loaded");
+          }
+
+          if (tm_json.offset) {
+            globalOff = tm_json.offset;
+            modelOptions.globalOffset = {
+              x: globalOff[0],
+              y: globalOff[1],
+              z: globalOff[2],
+            };
+          }
+
+          if (tm_json.properties_child) {
+            viewer["properties_child"] = tm_json.properties_child;
+          }
+
+          if (tm_json.properties_head) {
+            viewer["properties_head"] = tm_json.properties_head;
+          }
+
+          viewer["globalOffset"] = globalOff;
+          if (inCamera) {
+            let pos = inCamera.position;
+            let tar = inCamera.target;
+            let offset = viewer.globalOffset;
+            inCamera.position = new THREE.Vector3(
+              pos[0] - offset[0],
+              pos[1] - offset[1],
+              pos[2] - offset[2]
+            );
+            inCamera.target = new THREE.Vector3(
+              tar[0] - offset[0],
+              tar[1] - offset[1],
+              tar[2] - offset[2]
+            );
+          }
+        }
+
+        viewer.loadModel(
+          path,
+          modelOptions,
+          async (model) => {
+            if (inCamera) {
+              // Only Happens in 'bim' only mode
+              viewer.navigation.setPosition(inCamera.position);
+              viewer.navigation.setTarget(inCamera.target);
+            } else if (viewer.canvasId == "viewer_2") {
+              if (viewerMode != "3d") {
+                function checkFlag() {
+                  if (!viewer.getExtension("Autodesk.BimWalk")) {
+                    console.log("Loading BimWalk Extension ...");
+                    window.setTimeout(checkFlag, 1000);
+                  } else {
+                    setForgeControls(viewerMode);
+                  }
+                }
+                checkFlag();
+              }
+              viewer_2.navigation.setPosition(
+                viewer_1.scene.view.position.clone()
+              );
+              viewer_2.navigation.setTarget(viewer_1.scene.view.getPivot());
+              viewer_2.navigation.setVerticalFov(viewer_1.fov, false);
+            }
+
+            // Set Pivot Point
+
+            let fuzzy_box = viewer.model.getFuzzyBox();
+            let fuzzy_min = fuzzy_box["min"];
+            let fuzzy_max = fuzzy_box["max"];
+            let fuzzy_center = new THREE.Vector3(
+              (fuzzy_min["x"] + fuzzy_max["x"]) / 2,
+              (fuzzy_min["y"] + fuzzy_max["y"]) / 2,
+              (fuzzy_min["z"] + fuzzy_max["z"]) / 2
+            );
+            viewer.navigation.setPivotPoint(fuzzy_center);
+
+            // Generate GUID - DBID Mapping and progress view/
+
+            loadProgressView(viewer, pid, tid);
+          },
+          (e) => {
+            if (viewer.canvasId == "viewer_2") {
+              document.getElementById("no_bim_2").style.display = "block";
+            } else {
+              document.getElementById("no_bim_1").style.display = "block";
+            }
+          }
+        );
+      }
+
+      function loop(timestamp) {
+        syncViewers();
+        requestAnimationFrame(loop);
+        if (viewer_1.isFloorMap) {
+          updateUserLocation(viewer_1);
+        }
+        if (isCompareMode && compareType == "potree" && viewer_2.isFloorMap) {
+          updateUserLocation(viewer_2);
+        }
+      }
+
+      function setForgeControls(type) {
+        if (type == "orbit") {
+          viewer_2.navigation.setIsLocked(false);
+          if (viewer_2.getExtension("Autodesk.BimWalk")) {
+            viewer_2.getExtension("Autodesk.BimWalk").deactivate();
+          }
+        } else {
+          viewer_2.navigation.setLockSettings({
+            orbit: false,
+            pan: false,
+            zoom: false,
+            roll: false,
+            fov: true,
+          });
+          viewer_2.navigation.setIsLocked(true);
+
+          if (viewer_2.getExtension("Autodesk.BimWalk")) {
+            viewer_2.getExtension("Autodesk.BimWalk").activate();
+          }
+        }
+      }
+
+      function setPitch(viewer, delta) {
+        const startPitch = { p: viewer.scene.view.pitch };
+        const endPitch = { p: startPitch.p + delta };
+        let tween = new TWEEN.Tween(startPitch).to(endPitch, 500);
+        tween.easing(TWEEN.Easing.Quartic.Out);
+        tween.onUpdate(() => {
+          viewer.scene.view.pitch = startPitch.p;
+          syncPotreeEvent = true;
+        });
+        tween.onComplete(() => {
+          viewer.scene.view.pitch = endPitch.p;
+          syncPotreeEvent = true;
+        });
+        tween.start();
+      }
+
+      function setYaw(viewer, delta) {
+        const startYaw = { y: viewer.scene.view.yaw };
+        const endYaw = { y: startYaw.y + delta };
+        let tween = new TWEEN.Tween(startYaw).to(endYaw, 500);
+        tween.easing(TWEEN.Easing.Quartic.Out);
+        tween.onUpdate(() => {
+          viewer.scene.view.yaw = startYaw.y;
+          syncPotreeEvent = true;
+        });
+        tween.onComplete(() => {
+          viewer.scene.view.yaw = endYaw.y;
+          syncPotreeEvent = true;
+        });
+        tween.start();
+      }
+
+      function nextPanoImage(viewer) {
+        let cameraInstance = viewer.scene.cameraP;
+        const camDir = new THREE.Vector3();
+        cameraInstance.getWorldDirection(camDir);
+        camDir.normalize();
+        const camPos = cameraInstance.position;
+        const weightages = { angle: 0.5, distance: 0.5 };
+        let totalSum = 10000;
+        let curSum;
+        let selectedPanoImageId;
+        let cameraViewProjectionMatrix;
+        let imgPos;
+        let dist;
+        let angle;
+        let frustum;
+        const camToImgDir = new THREE.Vector3();
+        const maxDist = 10;
+        const panoImgs = viewer.scene.images360[0].images;
+
+        for (let i = 0; i < panoImgs.length; i++) {
+          if (panoImgs[i].file == viewer.scene.images360[0].focusedImage.file) {
+            continue;
+          }
+          imgPos = new THREE.Vector3().fromArray(panoImgs[i].position);
+          frustum = new THREE.Frustum();
+          cameraViewProjectionMatrix = new THREE.Matrix4();
+          cameraInstance.updateMatrixWorld(); // make sure the camera matrix is updated
+          // cameraInstance.matrixWorldInverse.getInverse(cameraInstance.matrixWorld);
+          cameraInstance.matrixWorldInverse
+            .copy(cameraInstance.matrixWorld)
+            .invert();
+          cameraViewProjectionMatrix.multiplyMatrices(
+            cameraInstance.projectionMatrix,
+            cameraInstance.matrixWorldInverse
+          );
+          frustum.setFromMatrix(cameraViewProjectionMatrix);
+
+          // // if (frustum.containsPoint(imgPos)) {
+          dist = imgPos.distanceTo(camPos);
+          if (dist < maxDist) {
+            camToImgDir.subVectors(imgPos, camPos).normalize();
+            angle = Math.abs(camToImgDir.angleTo(camDir));
+            // tslint:disable-next-line: no-string-literal
+            curSum =
+              weightages["angle"] * angle + weightages["distance"] * dist;
+            if (curSum < totalSum) {
+              selectedPanoImageId = i;
+              totalSum = curSum;
+            }
+          }
+          // // }
+
+          // dist = imgPos.distanceTo(camPos);
+          // if (dist < maxDist) {
+          //     camToImgDir.subVectors(imgPos, camPos).normalize();
+          //     angle = Math.abs(camToImgDir.angleTo(camDir));
+          //     // tslint:disable-next-line: no-string-literal
+          //     // curSum = (weightages['angle'] * angle) + (weightages['distance'] * dist);
+          //     if (angle < totalSum) {
+          //         selectedPanoImageId = i;
+          //         totalSum = angle;
+          //     }
+          // }
+        }
+        if (selectedPanoImageId != undefined) {
+          viewer.scene.images360[0].focus(panoImgs[selectedPanoImageId]);
+        } else {
+          console.warn("No Nearest 360 Images");
+        }
+      }
+
+      function loadFloormap(fpContainerId, fpCanvasId, viewer, pid, tid) {
+        let base_image = new Image();
+        base_image.src = `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${pid}/floormap/floormap.png`;
+        // return new Promise((resolve, reject) => {
+        let fpCanvas = document.getElementById(fpCanvasId);
+        let fpContainer = document.getElementById(fpContainerId);
+        let viewerDiv = document.getElementById(viewer.canvasId);
+        fpContainer.style.display = viewerMode == "3d" ? "none" : "block";
+
+        viewer.floorMap = {};
+        viewer.floorMap.canvas = fpCanvas;
+        viewer.floorMap.container = fpContainer;
+        viewer.floorMap.div = viewerDiv;
+        viewer.floorMap.coverage = mode.includes("compare") ? 0.25 : 0.15;
+
+        base_image.onload = async () => {
+          viewer.floorMap.image = base_image;
+          updateFPSize(viewer.floorMap);
+
+          let fpMarix = new THREE.Matrix4().set(
+            1,
+            0,
+            0,
+            0,
+            0,
+            1,
+            0,
+            0,
+            0,
+            0,
+            1,
+            0,
+            0,
+            0,
+            0,
+            1
+          );
+          let fpOffset = [0, 0, 0];
+          const tm_json_raw = await fetch(
+            `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${pid}/floormap/tm.json`
+          );
+          if (tm_json_raw.status == 200) {
+            const tm_json = JSON.parse(await tm_json_raw.text());
+            if (tm_json.tm) {
+              fpMarix = new THREE.Matrix4().fromArray(tm_json.tm).transpose();
+              console.log("FP TM Loaded");
+            }
+            viewer.floorMap.tm = fpMarix;
+
+            if (tm_json.offset) {
+              fpOffset = tm_json.offset;
+            }
+            viewer.floorMap.offset = fpOffset;
+          }
+
+          const indoor_images_raw = await fetch(
+            `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${pid}/snapshots/${tid}/images.json`
+          );
+          // const indoor_images_raw = await fetch(`http://localhost:1234/indoor_images_15_17_48_66.json`);
+          if (indoor_images_raw.status == 200) {
+            const indoor_images = JSON.parse(await indoor_images_raw.text());
+            console.log("Indoor Images Loaded");
+            loadIcons(
+              indoor_images,
+              fpMarix,
+              base_image,
+              fpCanvas,
+              fpContainer,
+              viewer.floorMap,
+              viewer.canvasId
+            );
+            addUserLocation(
+              "https://dtwin-viewers.s3.ap-south-1.amazonaws.com/icons/fp_user.png",
+              viewer
+            ); // Update Required
+            viewer.floorMap.images = indoor_images;
+          }
+          viewer.isFloorMap = true;
+        };
+        fpContainer.addEventListener("click", (e) => {
+          const clickData = JSON.parse(e.target.getAttribute("data"));
+          if (clickData.id == "viewer_1") {
+            viewer_1.scene.images360[0].images.forEach((pano) => {
+              if (pano.file.split("/").pop() == clickData.name) {
+                viewer_1.scene.images360[0].focus(pano);
+              }
+            });
+          } else if (clickData.id == "viewer_2") {
+            viewer_2.scene.images360[0].images.forEach((pano) => {
+              if (pano.file.split("/").pop() == clickData.name) {
+                viewer_2.scene.images360[0].focus(pano);
+              }
+            });
+          }
+          console.log(clickData.name);
+        });
+      }
+
+      function toggleFloorMap(viewer, cond) {
+        viewer.floorMap.container.style.display = cond ? "block" : "none";
+      }
+
+      function loadIcons(
+        inData,
+        tm,
+        fpImage,
+        fpCanvas,
+        fpContainer,
+        fpStoreData,
+        id
+      ) {
+        let iconSize = 0.01;
+        fpStoreData.icons = [];
+        Object.keys(inData).forEach((imageName) => {
+          const cur_image_pos = inData[imageName].position;
+          const pixelCoords = worldToimage(
+            [cur_image_pos[0], cur_image_pos[1], cur_image_pos[2]],
+            tm
+          );
+          const screenCoords = imageToScreen(pixelCoords, fpImage, fpCanvas);
+          let icon = document.createElement("span");
+          icon.setAttribute("class", "panoIcon");
+          icon.setAttribute(
+            "data",
+            JSON.stringify({ name: imageName, id: id })
+          );
+          icon.style.width = fpCanvas.width * iconSize + "px";
+          icon.style.height = fpCanvas.width * iconSize + "px";
+          icon.style.top = screenCoords[1] - 5 + "px";
+          icon.style.left = screenCoords[0] - 5 + "px";
+          fpContainer.appendChild(icon);
+          fpStoreData.icons.push(icon);
+        });
+      }
+
+      function addUserLocation(path, viewer) {
+        let base_image = new Image();
+        base_image.src = path;
+        return new Promise((resolve, reject) => {
+          base_image.onload = () => {
+            base_image.setAttribute("class", "userIcon");
+            viewer.floorMap.userIcon = base_image;
+            viewer.floorMap.container.appendChild(base_image);
+          };
+        });
+      }
+
+      function calAngle(cx, cy, ex, ey) {
+        var dy = ey - cy;
+        var dx = ex - cx;
+        var theta = Math.atan2(dy, dx); // range (-PI, PI]
+        theta *= 180 / Math.PI; // rads to degs, range (-180, 180]
+        if (theta < 0) theta = 360 + theta; // range [0, 360)
+        return theta - 90 + 180;
+        // return 90 - theta;
+      }
+
+      function updateUserLocation(viewer) {
+        let curView = viewer.scene.view;
+        const position = curView.position.toArray();
+        position[0] += viewer.floorMap.offset[0];
+        position[1] += viewer.floorMap.offset[1];
+        position[2] += viewer.floorMap.offset[2];
+        const pixelCoordsOffset = worldToimage(position, viewer.floorMap.tm);
+        const screenCoords = imageToScreen(
+          pixelCoordsOffset,
+          viewer.floorMap.image,
+          viewer.floorMap.canvas
+        );
+        viewer.floorMap.userIcon.style.left =
+          screenCoords[0] - viewer.floorMap.userIcon.width / 2 + 5 + "px";
+        viewer.floorMap.userIcon.style.top =
+          screenCoords[1] - viewer.floorMap.userIcon.height / 2 + 5 + "px";
+        const camTarget = new THREE.Vector3()
+          .addVectors(curView.position, curView.direction.multiplyScalar(1))
+          .toArray();
+        camTarget[0] += viewer.floorMap.offset[0];
+        camTarget[1] += viewer.floorMap.offset[1];
+        camTarget[2] += viewer.floorMap.offset[2];
+        const camTargetPixel = worldToimage(camTarget, viewer.floorMap.tm);
+        const angle = calAngle(
+          pixelCoordsOffset[0],
+          pixelCoordsOffset[1],
+          camTargetPixel[0],
+          camTargetPixel[1]
+        );
+        viewer.floorMap.userIcon.style.transform = "rotate(" + angle + "deg)";
+      }
+
+      function worldToimage(coords, intm) {
+        const a = new THREE.Vector4(coords[0], coords[1], coords[2], 1);
+        a.applyMatrix4(intm);
+        return [Math.ceil(a.x), Math.ceil(a.y)];
+      }
+
+      function imageToScreen(pix, image, canvas) {
+        const pxx = (pix[0] * canvas.width) / image.naturalWidth;
+        const pyy = (pix[1] * canvas.height) / image.naturalHeight;
+        return [pxx, pyy];
+      }
+
+      function resizeFP(image, fpCanvas, v, coverage) {
+        // let coverage = 0.5;
+        // if (isCompareMode) {
+        // coverage = 0.25;
+        // }
+        // let coverage =
+        if (image.naturalWidth > image.naturalHeight) {
+          fpCanvas.width = v.clientWidth * coverage;
+          fpCanvas.height =
+            fpCanvas.width * (image.naturalHeight / image.naturalWidth);
+        } else {
+          fpCanvas.height = coverage * v.clientWidth;
+          fpCanvas.width =
+            fpCanvas.height * (image.naturalWidth / image.naturalHeight);
+        }
+      }
+
+      function updateFPSize(fpData) {
+        resizeFP(fpData.image, fpData.canvas, fpData.div, fpData.coverage);
+        let context = fpData.canvas.getContext("2d");
+        context.drawImage(
+          fpData.image,
+          0,
+          0,
+          fpData.canvas.width,
+          fpData.canvas.height
+        );
+        if (fpData.icons) {
+          updateFpIcons(fpData);
+        }
+      }
+
+      function updateFpIcons(fpInfo) {
+        let iconSize = 0.02;
+        Object.keys(fpInfo.images).forEach((imageName, index) => {
+          const cur_image_pos = fpInfo.images[imageName].position;
+          const pixelCoords = worldToimage(cur_image_pos, fpInfo.tm);
+          const screenCoords = imageToScreen(
+            pixelCoords,
+            fpInfo.image,
+            fpInfo.canvas
+          );
+          let icon = fpInfo.icons[index];
+          icon.style.width = fpInfo.canvas.width * iconSize + "px";
+          icon.style.height = fpInfo.canvas.width * iconSize + "px";
+          icon.style.top = screenCoords[1] - 5 + "px";
+          icon.style.left = screenCoords[0] - 5 + "px";
+        });
+      }
+
+      function removeFloorMap(viewer) {
+        viewer.floorMap.icons.forEach((icon) => {
+          viewer.floorMap.container.removeChild(icon);
+        });
+        viewer.floorMap.icons = [];
+        viewer.floorMap.container.removeChild(viewer.floorMap.userIcon);
+        viewer.floorMap.userIcon = null;
+        viewer.floorMap.images = null;
+        let context = viewer.floorMap.canvas.getContext("2d");
+        context.clearRect(
+          0,
+          0,
+          viewer.floorMap.canvas.width,
+          viewer.floorMap.canvas.height
+        );
+        viewer.floorMap = {};
+        viewer.isFloorMap = false;
+      }
+
+      async function addMeasure(type, id) {
+        let viewer;
+        if (id == "viewer_1") {
+          viewer = viewer_1;
+          document.getElementById("measure_tool_1").style.display = "block";
+          document
+            .getElementById("measure_top_1")
+            .setAttribute("measure_tool", true);
+        } else {
+          viewer = viewer_2;
+          document.getElementById("measure_tool_2").style.display = "block";
+          document
+            .getElementById("measure_top_2")
+            .setAttribute("measure_tool", true);
+        }
+        if (type == "point") {
+          console.log("Adding Point Measure");
+
+          if (viewerMode == "3d") {
+            let measurement = viewer.measuringTool.startInsertion({
+              showDistances: false,
+              showAngles: false,
+              showCoordinates: true,
+              showArea: false,
+              closed: true,
+              maxMarkers: 1,
+              name: "Point",
+            });
+          } else {
+            let clickHandler = (event) => {
+              const raycaster = new THREE.Raycaster();
+              let pickedObject = undefined;
+
+              const rect = viewer.renderArea.getBoundingClientRect();
+              let pos = {
+                x: event.clientX - rect.left,
+                y: event.clientY - rect.top,
+              };
+
+              // const pos = this.getCanvasRelativePosition(event);
+              let pickPosition = { x: 0, y: 0 };
+              pickPosition.x = (pos.x / viewer.renderArea.clientWidth) * 2 - 1;
+              pickPosition.y =
+                (pos.y / viewer.renderArea.clientHeight) * -2 + 1; // note we flip Y
+
+              raycaster.setFromCamera(pickPosition, viewer.scene.cameraP);
+              let objs =
+                viewerMode == "image"
+                  ? viewer.scene.scene.children
+                  : [viewer.scene.scene.children[0].children[0]];
+              const intersectedObjects = raycaster.intersectObjects(objs, true);
+              if (intersectedObjects.length) {
+                let click_point =
+                  viewerMode == "image"
+                    ? intersectedObjects[2].point
+                    : intersectedObjects[0].point;
+                let measure = new Potree.Measure();
+                measure.showDistances = false;
+                measure.showCoordinates = true;
+                measure.maxMarkers = 1;
+                measure.type = "Point";
+                measure.name = "Point";
+                measure.addMarker(click_point);
+                viewer.scene.addMeasurement(measure);
+              }
+              viewer.renderArea.removeEventListener("click", clickHandler);
+            };
+            setTimeout(() => {
+              viewer.renderArea.addEventListener("click", clickHandler);
+            }, 1);
+          }
+        } else if (type == "distance") {
+          console.log("Adding Distance Measure");
+          let measurement = viewer.measuringTool.startInsertion({
+            showDistances: true,
+            showArea: false,
+            closed: false,
+            name: "Distance",
+          });
+        } else if (type == "area") {
+          console.log("Adding Area Measure");
+          let measurement = viewer.measuringTool.startInsertion({
+            showDistances: true,
+            showArea: true,
+            closed: true,
+            name: "Area",
+          });
+        } else if (type == "height") {
+          console.log("Adding Area Measure");
+          let measurement = viewer.measuringTool.startInsertion({
+            showDistances: false,
+            showHeight: true,
+            showArea: false,
+            closed: false,
+            maxMarkers: 2,
+            name: "Height",
+          });
+        } else if (type == "clear") {
+          viewer.scene.removeAllMeasurements();
+        } else if (type == "save") {
+          let date_time = new Date();
+          let screenShotPath = `${mainProjectID}/structures/${inProjectID}/snapshots/${
+            viewer.tileset
+          }/${date_time.getTime()}.png`;
+          let latest_measure = viewer.scene.measurements.slice(-1)[0];
+          let save_obj = {
+            type: latest_measure.name,
+            points: latest_measure.points.map((point) =>
+              point.position.toArray()
+            ),
+            image: viewer.cur_loaded_image,
+            tileset: viewer.tileset,
+            camera: locate(viewer),
+            screenShot: `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${screenShotPath}`,
+          };
+          console.log("Saving Annotation: ", save_obj);
+          window.top.postMessage(
+            { type: "save-tag", data: JSON.stringify(save_obj) },
+            "*"
+          );
+          takeScreenshot(screenShotPath, viewer);
+        }
+      }
+
+      function toggleVisibility(id, cond) {
+        let div = document.getElementById(id);
+        if (cond) {
+          div.style.display = "block";
+        } else {
+          div.style.display = "none";
+        }
+        updateIconsDisplay();
+      }
+
+      function toggleOrientedImages(id, cond) {
+        if (id == "viewer_1") {
+          viewer_1.scene.orientedImages[0].visible = cond;
+          document.getElementById("cameras_on_1").style.display = cond
+            ? "none"
+            : "inline-block";
+          document.getElementById("cameras_off_1").style.display = cond
+            ? "inline-block"
+            : "none";
+        } else {
+          viewer_2.scene.orientedImages[0].visible = cond;
+          document.getElementById("cameras_on_2").style.display = cond
+            ? "none"
+            : "inline-block";
+          document.getElementById("cameras_off_2").style.display = cond
+            ? "inline-block"
+            : "none";
+        }
+      }
+
+      function actionIconClick(icon) {
+        const inData = JSON.parse(event.target.getAttribute("data"));
+        if (inData) {
+          // parent.postMessage(`${inData.type} button clicked`, "*");
+          if (inData.type == "3d") {
+            if (inData.id == "viewer_1") {
+              viewer_1.controls.elExit.click();
+            } else {
+              viewer_2.controls.elExit.click();
+            }
+          } else if (inData.type == "cameras") {
+            if (inData.id == "viewer_1") {
+              inData.condition == "on"
+                ? toggleOrientedImages("viewer_1", true)
+                : toggleOrientedImages("viewer_1", false);
+            } else {
+              inData.condition == "on"
+                ? toggleOrientedImages("viewer_2", true)
+                : toggleOrientedImages("viewer_2", false);
+            }
+          } else if (inData.type == "compare") {
+            let cam = locate(viewer_1);
+            console.log("3D COMPARE");
+            window.location.href =
+              "https://internal.constructn.ai/tour1?project=" +
+              mainProjectID +
+              "&structure=" +
+              structure_id +
+              "&snapshot1=" +
+              inTilesetID +
+              "&snapshot2=" +
+              inTilesetID2 +
+              "&token=" +
+              token +
+              "&mode=compare_3d" +
+              "&camera=" +
+              JSON.stringify(cam);
+          } else if (inData.type == "bim-compare") {
+            let cam = locate(viewer_1);
+            console.log("BIM COMPARE");
+            window.location.href =
+              "https://internal.constructn.ai/tour1?project=" +
+              mainProjectID +
+              "&structure=" +
+              structure_id +
+              "&snapshot1=" +
+              inTilesetID +
+              "&snapshot2=" +
+              inTilesetID2 +
+              "&mode=compare_bim" +
+              "&camera=" +
+              JSON.stringify(cam) +
+              "&token=" +
+              token;
+          } else if (inData.type == "fp_fullscreen") {
+            if (inData.id == "viewer_1") {
+              if (event.target.id == "fp_fullscreen_1") {
+                document.getElementById("fp_fullscreen_1").style.display =
+                  "none";
+                document.getElementById("fp_minimise_1").style.display =
+                  "block";
+                viewer_1.floorMap.coverage = 0.5;
+                updateFPSize(viewer_1.floorMap);
+              } else {
+                document.getElementById("fp_fullscreen_1").style.display =
+                  "block";
+                document.getElementById("fp_minimise_1").style.display = "none";
+                viewer_1.floorMap.coverage = isCompareMode ? 0.25 : 0.15;
+                updateFPSize(viewer_1.floorMap);
+              }
+            } else if (inData.id == "viewer_2") {
+              if (event.target.id == "fp_fullscreen_2") {
+                document.getElementById("fp_fullscreen_2").style.display =
+                  "none";
+                document.getElementById("fp_minimise_2").style.display =
+                  "block";
+                viewer_2.floorMap.coverage = 0.5;
+                updateFPSize(viewer_2.floorMap);
+              } else {
+                document.getElementById("fp_fullscreen_2").style.display =
+                  "block";
+                document.getElementById("fp_minimise_2").style.display = "none";
+                viewer_2.floorMap.coverage = isCompareMode ? 0.25 : 0.15;
+                updateFPSize(viewer_2.floorMap);
+              }
+            }
+          } else if (inData.type == "compare-close") {
+            let cam = locate(viewer_1);
+            window.location.href =
+              "https://internal.constructn.ai/tour1?project=" +
+              mainProjectID +
+              "&structure=" +
+              structure_id +
+              "&snapshot1=" +
+              inTilesetID +
+              "&snapshot2=" +
+              inTilesetID2 +
+              "&mode=3d" +
+              "&camera=" +
+              JSON.stringify(cam) +
+              "&token=" +
+              token;
+          } else if (inData.type == "bim_legend") {
+            let visible = false;
+            if (event.target.style.opacity == 0.5) {
+              visible = true;
+              event.target.style.opacity = 1;
+            } else {
+              event.target.style.opacity = 0.5;
+            }
+
+            if (inData.id == "viewer_1") {
+              bimFilters(viewer_1, "progress", event.target.id, visible);
+            } else {
+              bimFilters(viewer_2, "progress", event.target.id, visible);
+            }
+          } else if (inData.type == "bim_card_close") {
+            // if (inData.id == 'viewer_1') {
+            // 	closeBimDetailsCard('viewer_1');
+            // } else if (inData.id == 'viewer_2') {
+            // 	closeBimDetailsCard('viewer_2');
+            // }
+          } else if (inData.type == "measure") {
+            if (inData.id == "viewer_1") {
+              if (event.target.getAttribute("measure_tool") == null) {
+                event.target.setAttribute("measure_tool", false);
+              }
+              if (event.target.getAttribute("measure_tool") == "true") {
+                document.getElementById("measure_tool_1").style.display =
+                  "none";
+                event.target.setAttribute("measure_tool", false);
+              } else {
+                document.getElementById("measure_tool_1").style.display =
+                  "block";
+                event.target.setAttribute("measure_tool", true);
+              }
+            } else {
+              if (event.target.getAttribute("measure_tool") == "true") {
+                document.getElementById("measure_tool_2").style.display =
+                  "none";
+                event.target.setAttribute("measure_tool", false);
+              } else {
+                document.getElementById("measure_tool_1").style.display =
+                  "block";
+                event.target.setAttribute("measure_tool", true);
+              }
+            }
+          } else {
+            // event.stopPropagation()
+            addMeasure(inData.type, inData.id);
+          }
+        }
+      }
+
+      function getAllLeafComponents(viewer, callback) {
+        var cbCount = 0; // count pending callbacks
+        var components = []; // store the results
+        var tree; // the instance tree
+
+        function getLeafComponentsRec(parent) {
+          cbCount++;
+          if (tree.getChildCount(parent) != 0) {
+            tree.enumNodeChildren(
+              parent,
+              function (children) {
+                getLeafComponentsRec(children);
+              },
+              false
+            );
+          } else {
+            components.push(parent);
+          }
+          if (--cbCount == 0) callback(components);
+        }
+        viewer.getObjectTree(function (objectTree) {
+          tree = objectTree;
+          var allLeafComponents = getLeafComponentsRec(tree.getRootId());
+        });
+      }
+
+      function getRecursiveGUID(viewer, dbIds) {
+        return new Promise((resolve, reject) => {
+          let guidMapping = {};
+          let guidTodbid = {};
+          let parentMapping = {};
+          let guidToName = {};
+          let dbIdToGuid = {};
+          let property_childs = viewer["properties_child"];
+          let property_head = viewer["properties_head"][0];
+
+          function getGUID(ids) {
+            let dbIdsProcessed = [];
+            viewer.model.getBulkProperties(ids, property_childs, (data) => {
+              data.map((elementDetails) => {
+                let id = elementDetails.properties.filter(
+                  (details) =>
+                    details.displayCategory == property_head &&
+                    details.displayName == property_childs[0]
+                )[0]["displayValue"];
+                let name = elementDetails.properties.filter(
+                  (details) =>
+                    details.displayCategory == property_head &&
+                    details.displayName == property_childs[1]
+                )[0]["displayValue"];
+                if (id) {
+                  guidMapping[elementDetails.dbId] = id;
+                  dbIdsProcessed.push(elementDetails.dbId);
+                  guidToName[id] = name;
+                } else {
+                  console.log("No IFC id for ", elementDetails);
+                }
+              });
+              // console.log('Got ' + dbIdsProcessed.length + ' guids ....')
+              // Get GUID from parent for remaining Ids
+              let remainingDbIds = ids.filter(
+                (lid) => !dbIdsProcessed.includes(lid)
+              );
+              if (remainingDbIds.length) {
+                // console.log('Getting Parents for ' + remainingDbIds.length + ' dbids ....')
+                viewer.model.getBulkProperties(
+                  remainingDbIds,
+                  ["parent"],
+                  (data) => {
+                    let parentsForRemaining = data.map((elementDetails) => {
+                      parentMapping[elementDetails.dbId] =
+                        elementDetails.properties[0].displayValue;
+                      return elementDetails.properties[0].displayValue;
+                    });
+                    getGUID(parentsForRemaining);
+                  }
+                );
+              } else {
+                function getGIdFromParent(id) {
+                  if (guidMapping[parentMapping[id]]) {
+                    return guidMapping[parentMapping[id]];
+                  } else {
+                    return getGIdFromParent(parentMapping[id]);
+                  }
+                }
+
+                dbIds.map((dbid) => {
+                  let gid = guidMapping[dbid];
+                  if (gid) {
+                    if (guidTodbid[gid]) {
+                      guidTodbid[gid].push(dbid);
+                    } else {
+                      guidTodbid[gid] = [dbid];
+                    }
+                    dbIdToGuid[dbid] = gid;
+                  } else {
+                    gid = getGIdFromParent(dbid);
+                    if (guidTodbid[gid]) {
+                      guidTodbid[gid].push(dbid);
+                    } else {
+                      guidTodbid[gid] = [dbid];
+                    }
+                    dbIdToGuid[dbid] = gid;
+                  }
+                });
+
+                // console.log(guidTodbid)
+                console.log(guidToName);
+                bimProgressData[viewer.canvasId] = resolve({
+                  guidMapping: guidTodbid,
+                  dbIdToGuid: dbIdToGuid,
+                });
+              }
+            });
+          }
+
+          console.log("Got " + dbIds.length + " input ids");
+          getGUID(dbIds);
+        });
+      }
+
+      function getguidTodbidMapping(viewer) {
+        return new Promise((resolve, reject) => {
+          getAllLeafComponents(viewer, async (leafIds) => {
+            let guidDetails = await getRecursiveGUID(viewer, leafIds);
+            resolve(guidDetails);
+          });
+        });
+      }
+
+      async function bimProgressView(viewer) {
+        if (
+          inProjectID == "161" ||
+          inProjectID == "165" ||
+          inProjectID == "166"
+        ) {
+          viewer.hideAll();
+          viewer.show(bimProgressData[viewer.canvasId]["green"]);
+          viewer.show(bimProgressData[viewer.canvasId]["blue"]);
+        }
+
+        viewer.setColorMaterial(
+          bimProgressData[viewer.canvasId]["red"],
+          [1, 0, 0, 0.5],
+          "red"
+        );
+        viewer.setColorMaterial(
+          bimProgressData[viewer.canvasId]["green"],
+          [0.5, 0.88, 0.22, 0.5],
+          "green"
+        );
+        viewer.setColorMaterial(
+          bimProgressData[viewer.canvasId]["blue"],
+          [0.95, 0.6, 0.22, 0.5],
+          "blue"
+        );
+
+        // viewer.setColorMaterial(bimProgressData[viewer.canvasId]['red'], 0xFF0000, 'red')
+        // viewer.setColorMaterial(bimProgressData[viewer.canvasId]['green'], 0x71E03A, 'green')
+        // viewer.setColorMaterial(bimProgressData[viewer.canvasId]['blue'], 0xF39B3A, 'blue')
+
+        // viewer.setLightPreset(4)
+        viewer.setQualityLevel(false, false);
+      }
+
+      function bimFilters(viewer, filterType, filterName, visible) {
+        if (filterType == "progress") {
+          if (filterName == "bim_not_started") {
+            visible
+              ? viewer.show(bimProgressData[viewer.canvasId]["red"])
+              : viewer.hide(bimProgressData[viewer.canvasId]["red"]);
+          } else if (filterName == "bim_complete") {
+            visible
+              ? viewer.show(bimProgressData[viewer.canvasId]["green"])
+              : viewer.hide(bimProgressData[viewer.canvasId]["green"]);
+          } else if (filterName == "bim_in_progress") {
+            visible
+              ? viewer.show(bimProgressData[viewer.canvasId]["blue"])
+              : viewer.hide(bimProgressData[viewer.canvasId]["blue"]);
+          }
+        }
+      }
+
+      function bimDefaultView(viewer) {
+        if (
+          inProjectID == "161" ||
+          inProjectID == "165" ||
+          inProjectID == "166"
+        ) {
+          viewer.showAll();
+        }
+        var instanceTree = viewer.model.getData().instanceTree;
+
+        var allDbIdsStr = Object.keys(instanceTree.nodeAccess.dbIdToIndex);
+
+        let dbIds = allDbIdsStr.map(function (id) {
+          return parseInt(id);
+        });
+        viewer.restoreColorMaterial(dbIds);
+        // viewer.setLightPreset(1)
+        viewer.setQualityLevel(true, true);
+      }
+
+      function addProgressButton(viewer) {
+        let group = new Autodesk.Viewing.UI.ControlGroup("BimProgress");
+        viewer.toolbar.addControl(group);
+
+        // Add a new button to the toolbar group
+        let button = new Autodesk.Viewing.UI.Button("progress");
+        // instead of using bootstrap classes e.g.
+        // button.icon.classList.add("fas", "fa-arrows-alt");
+        // you can do this
+        let iconPath =
+          "https://dtwin-viewers.s3.ap-south-1.amazonaws.com/icons/progress.png";
+        button.icon.style = `background-image: url(${iconPath}); background-size: 24px 24px;`;
+
+        button.setToolTip("Progress View");
+
+        button.onClick = function (e) {
+          toggleBimProgressView(viewer);
+
+          // button.icon.classList.add('adsk-viewing-viewer', 'dark-theme', 'adsk-button.active', 'adsk-button')
+          // button.icon.classList.add("fas", "fa-arrows-alt");
+        };
+
+        group.addControl(button);
+
+        toggleBimProgressView(viewer);
+
+        let elems = document.querySelectorAll("[id=bim_not_started]");
+
+        if (viewer.canvasId == "viewer_1") {
+          elems[0].click();
+        } else {
+          elems[1].click();
+        }
+      }
+
+      function toggleBimProgressView(viewer) {
+        console.log("Go to Progress View");
+        bimProgressMode ? bimDefaultView(viewer) : bimProgressView(viewer);
+        if (viewer.canvasId == "viewer_1") {
+          bimProgressMode
+            ? (document.getElementById("bim_legend_1").style.display = "none")
+            : (document.getElementById("bim_legend_1").style.display = "block");
+        } else {
+          bimProgressMode
+            ? (document.getElementById("bim_legend_2").style.display = "none")
+            : (document.getElementById("bim_legend_2").style.display = "block");
+        }
+        bimProgressMode = !bimProgressMode;
+      }
+
+      async function loadProgressView(viewer, projectID, tilesetID) {
+        const progress_data_raw = await fetch(
+          `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${projectID}/snapshots/${tilesetID}/bim_progress.json`
+        );
+        if (progress_data_raw.status == 200) {
+          let guidDetails = await getguidTodbidMapping(viewer);
+          let guidMapping = guidDetails.guidMapping;
+          let guids = Object.keys(guidDetails.guidMapping);
+
+          bimProgressData[viewer.canvasId] = {
+            mapping: guidDetails.guidMapping,
+            dbtoguid: guidDetails.dbIdToGuid,
+            guids: guids,
+          };
+
+          console.log("GUID - DBID mapping done");
+          const progress_data = JSON.parse(await progress_data_raw.text());
+          console.log("BIM progress json loaded");
+
+          bimProgressData[viewer.canvasId]["progress"] = progress_data;
+
+          // let guids = bimProgressData[viewer.canvasId]['guids']
+          // let guidMapping = bimProgressData[viewer.canvasId]['mapping']
+
+          let redArr = guids.filter((key) => progress_data[key] == 0);
+          let greenArr = guids.filter((key) => progress_data[key] == 100);
+          let blueArr = guids.filter(
+            (key) => !redArr.includes(key) && !greenArr.includes(key)
+          );
+          let redDbArr = [];
+          let greenDbArr = [];
+          let blueDbArr = [];
+          if (
+            inProjectID != "161" &&
+            inProjectID != "165" &&
+            inProjectID != "166"
+          ) {
+            redArr.map((id) => (redDbArr = redDbArr.concat(guidMapping[id])));
+          }
+          blueArr.map((id) => (blueDbArr = blueDbArr.concat(guidMapping[id])));
+          greenArr.map(
+            (id) => (greenDbArr = greenDbArr.concat(guidMapping[id]))
+          );
+
+          bimProgressData[viewer.canvasId]["red"] = redDbArr;
+          bimProgressData[viewer.canvasId]["green"] = greenDbArr;
+          bimProgressData[viewer.canvasId]["blue"] = blueDbArr;
+
+          console.log("###############################");
+          console.log(redArr);
+
+          addProgressButton(viewer);
+
+          loadProgressWalk(viewer, projectID, tilesetID);
+        }
+      }
+
+      function select_group_bim(in_guids, viewer, mode, in_field) {
+        let dbArr = [];
+        let guidMapping = bimProgressData[viewer.canvasId]["mapping"];
+        in_guids.map((id) => (dbArr = dbArr.concat(guidMapping[id])));
+
+        if (mode == "material") {
+          bimDefaultView(viewer);
+          viewer.setColorMaterial(dbArr, in_field, "temp_mat");
+        } else if (mode == "visibility") {
+          in_field ? viewer.show(dbArr) : viewer.hide(dbArr);
+        }
+      }
+
+      function remove_group_bim(viewer, mode) {
+        if (mode == "material") {
+          bimDefaultView(viewer);
+        } else if (mode == "visibility") {
+          viewer.showAll();
+        }
+      }
+
+      function locate(viewer) {
+        let camObject;
+        if (viewer.customtype == "potree") {
+          let pos = viewer.scene.view.position.toArray();
+          let tar = viewer.scene.view.getPivot().toArray();
+          let offset = viewer.globalOffset;
+          camObject = {
+            position: [
+              pos[0] + offset[0],
+              pos[1] + offset[1],
+              pos[2] + offset[2],
+            ],
+            target: [
+              tar[0] + offset[0],
+              tar[1] + offset[1],
+              tar[2] + offset[2],
+            ],
+            pitch: viewer.scene.view.pitch,
+            yaw: viewer.scene.view.yaw,
+          };
+        } else if (viewer.customtype == "forge") {
+          const state = viewer.getState({ viewport: true }).viewport;
+          let offset = viewer.globalOffset;
+          camObject = {
+            position: [
+              state.eye[0] + offset[0],
+              state.eye[1] + offset[1],
+              state.eye[2] + offset[2],
+            ],
+            target: [
+              state.target[0] + offset[0],
+              state.target[1] + offset[1],
+              state.target[2] + offset[2],
+            ],
+          };
+        }
+        console.log("Camera : ", camObject);
+        return camObject;
+      }
+
+      function getInverse(org_mat) {
+        var m4 = new THREE.Matrix4();
+        m4.getInverse(org_mat);
+        m4.transpose();
+        return m4.toArray();
+      }
+
+      function flyToContext(info) {
+        let viewer = viewer_1;
+        let offset = viewer.globalOffset;
+        let inCamera_withOffset = {
+          position: new THREE.Vector3().fromArray([
+            info.position[0] - offset[0],
+            info.position[1] - offset[1],
+            info.position[2] - offset[2],
+          ]),
+          target: new THREE.Vector3().fromArray([
+            info.target[0] - offset[0],
+            info.target[1] - offset[1],
+            info.target[2] - offset[2],
+          ]),
+          pitch: info.pitch ? info.pitch : null,
+          yaw: info.yaw ? info.yaw : null,
+        };
+        let inCamera = {
+          position: new THREE.Vector3().fromArray([
+            info.position[0],
+            info.position[1],
+            info.position[2],
+          ]),
+          target: new THREE.Vector3().fromArray([
+            info.target[0],
+            info.target[1],
+            info.target[2],
+          ]),
+        };
+        if (viewerMode == "image") {
+          getNearestImage(viewer, inCamera_withOffset, "image");
+        } else if (viewerMode == "panorama") {
+          getNearestImage(viewer, inCamera_withOffset, "panorama");
+        } else {
+          if (viewer.customtype == "potree") {
+            viewer.scene.view.setView(
+              inCamera_withOffset.position,
+              inCamera_withOffset.target
+            );
+          } else {
+            viewer.navigation.setPosition(inCamera_withOffset.position);
+            viewer.navigation.setTarget(inCamera_withOffset.target);
+          }
+          if (isCompareMode) {
+            isMouseOnV1 = true;
+            syncViewers();
+          }
+        }
+      }
+
+      function flyToImage(viewer, imageName, inCamera) {
+        if (viewerMode == "panorama") {
+          viewer.scene.images360[0].images.forEach((image) => {
+            if (image.file.split("/").pop() == imageName) {
+              viewer.scene.images360[0].focus(image, true, inCamera);
+            }
+          });
+        } else {
+          viewer.scene.orientedImages[0].images.forEach((image) => {
+            if (image.id == imageName) {
+              viewer.scene.orientedImages[0].moveToImage(image);
+            }
+          });
+        }
+      }
+
+      function flyToTagContext(info) {
+        let offset = viewer_1.globalOffset;
+        let inCamera_withOffset = {
+          position: new THREE.Vector3().fromArray([
+            info.camera.position[0] - offset[0],
+            info.camera.position[1] - offset[1],
+            info.camera.position[2] - offset[2],
+          ]),
+          target: new THREE.Vector3().fromArray([
+            info.camera.target[0] - offset[0],
+            info.camera.target[1] - offset[1],
+            info.camera.target[2] - offset[2],
+          ]),
+          pitch: info.camera.pitch ? info.camera.pitch : null,
+          yaw: info.camera.yaw ? info.camera.yaw : null,
+        };
+
+        // if (info.image) {
+        // 	flyToImage_AddTag(viewer_1, info.image, inCamera_withOffset, info)
+        // 	if (isCompareMode) {
+        // 		flyToImage_AddTag(viewer_2, info.image, inCamera_withOffset, info)
+        // 	}
+        // } else {
+        // 	console.log('No Tag Support in 3d')
+        // }
+        if (info.image) {
+          if (viewer_1.tileset == info.tileset) {
+            isMouseOnV1 = true;
+
+            tagToAddOnImageLoad = {
+              info: info,
+              viewer: viewer_1,
+            };
+
+            flyToImage(viewer_1, info.image, inCamera_withOffset);
+            // addTag(info, viewer_1)
+            isMouseOnV1 = true;
+          } else if (isCompareMode && viewer_2.tileset == info.tileset) {
+            isMouseOnV1 = false;
+            // addTag(info, viewer_2)
+            tagToAddOnImageLoad = {
+              info: info,
+              viewer: viewer_2,
+            };
+            flyToImage(viewer_2, info.image, inCamera_withOffset);
+            isMouseOnV1 = false;
+          } else {
+            window.location.href =
+              "https://internal.constructn.ai/tour1?project=" +
+              mainProjectID +
+              "&structure=" +
+              structure_id +
+              "&snapshot1=" +
+              info.tileset +
+              "&snapshot2=" +
+              inTilesetID2 +
+              "&mode=" +
+              mode +
+              "&tag=" +
+              JSON.stringify(info) +
+              "&token=" +
+              token;
+          }
+        } else if (isExterior) {
+          console.log("Load 3d tags");
+          // viewer_1.controls.elExit.click();
+          if (viewer_1.cur_loaded_image) {
+            viewer_1.controls.elExit.click();
+          }
+          // if (isCompareMode) {
+          // 	viewer_2.scene.orientedImages[0].release()
+          // }
+
+          setTimeout(() => {
+            if (viewer_1.tileset == info.tileset) {
+              isMouseOnV1 = true;
+              flyToContext(info.camera);
+              addTag(info, viewer_1);
+              isMouseOnV1 = true;
+            } else if (isCompareMode && viewer_2.tileset == info.tileset) {
+              isMouseOnV1 = false;
+              flyToContext(info.camera);
+              addTag(info, viewer_2);
+              isMouseOnV1 = false;
+            } else {
+              window.location.href =
+                "https://internal.constructn.ai/tour1?project=" +
+                mainProjectID +
+                "&structure=" +
+                structure_id +
+                "&snapshot1=" +
+                info.tileset +
+                "&snapshot2=" +
+                inTilesetID2 +
+                "&mode=" +
+                mode +
+                "&tag=" +
+                JSON.stringify(info) +
+                "&token=" +
+                token;
+            }
+          }, 1000);
+        }
+
+        // if (viewerMode == 'image') {
+        // 	getNearestImage(viewer_1,inCamera_withOffset, 'image')
+        // } else if (viewerMode == 'panorama') {
+        // 	getNearestImage(viewer_1,inCamera_withOffset, 'panorama')
+        // } else {
+        // 	if (viewer_1.customtype == 'potree') {
+        // 		viewer.scene.view.setView(inCamera_withOffset.position, inCamera_withOffset.target)
+        // 	} else {
+        // 		viewer_1.navigation.setPosition(inCamera_withOffset.position);
+        // 		viewer_1.navigation.setTarget(inCamera_withOffset.target);
+        // 	}
+        // 	if (isCompareMode) {
+        // 		isMouseOnV1 = true
+        // 		syncViewers();
+        // 	}
+        // }
+      }
+
+      function addTag(inData, viewer) {
+        if (inData.type == "Point") {
+          let measure = new Potree.Measure();
+          measure.showDistances = false;
+          measure.showCoordinates = true;
+          measure.maxMarkers = 1;
+          measure.addMarker(new THREE.Vector3().fromArray(inData.points[0]));
+          viewer.scene.addMeasurement(measure);
+        } else if (inData.type == "Distance") {
+          let measure = new Potree.Measure();
+          measure.closed = false;
+          inData.points.forEach((point) => {
+            measure.addMarker(new THREE.Vector3().fromArray(point));
+          });
+          viewer.scene.addMeasurement(measure);
+        } else if (inData.type == "Area") {
+          let measure = new Potree.Measure();
+          measure.name = "Area";
+          measure.closed = true;
+          measure.showArea = true;
+          inData.points.forEach((point) => {
+            measure.addMarker(new THREE.Vector3().fromArray(point));
+          });
+          viewer.scene.addMeasurement(measure);
+        } else if (inData.type == "Height") {
+          let measure = new Potree.Measure();
+          measure.name = "Tree Height";
+          measure.closed = false;
+          measure.showDistances = false;
+          measure.showHeight = true;
+          inData.points.forEach((point) => {
+            measure.addMarker(new THREE.Vector3().fromArray(point));
+          });
+          viewer.scene.addMeasurement(measure);
+        }
+      }
+
+      requestAnimationFrame(loop);
+
+      var datesIdMapRight = {};
+      var datesIdMapLeft = {};
+      getDate("#datepickerLeft", datesIdMapLeft, 0, 1);
+      getDate("#datepickerRight", datesIdMapRight, 1, 2);
+
+      function getDate(dateObject, datesMap, defaultValue, snapshotNo) {
+        return new Promise((resolve, reject) => {
+          $.ajax({
+            url: `https://api.dev.constructn.ai/api/v1/snapshots?structure=${structure_id}`,
+            method: "GET",
+            headers: {
+              "Content-Type": "application/json",
+              Authorization: `Bearer ${token}`,
+            },
+            success: (rawData) => {
+              console.log(rawData);
+              if (rawData.result[defaultValue]) {
+                updateDateObject(
+                  rawData,
+                  dateObject,
+                  datesMap,
+                  defaultValue,
+                  snapshotNo
+                );
+              } else if (
+                defaultValue === 1 &&
+                rawData.records[defaultValue - 1]
+              ) {
+                updateDateObject(
+                  rawData,
+                  dateObject,
+                  datesMap,
+                  defaultValue - 1,
+                  snapshotNo
+                );
+              } else {
+                console.log("No records found for Snapshot " + defaultValue);
+              }
+            },
+            error: (e) => {
+              resolve(null);
+            },
+          });
+        });
+      }
+
+      function updateDateObject(
+        rawData,
+        dateObject,
+        datesMap,
+        defaultValue,
+        snapshotNo
+      ) {
+        rawData.result.forEach((record) => {
+          const date = new Date(record["date"]).toISOString().split("T")[0];
+          datesMap[date] = record._id;
+        });
+        console.log(window.location.host);
+        const snapshot = snapshotNo === 1 ? inTilesetID : inTilesetID2;
+        const defaultDate = getValue(datesMap, snapshot)
+          ? getValue(datesMap, snapshot)
+          : new Date(rawData.result[defaultValue]["date"])
+              .toISOString()
+              .split("T")[0];
+        $(dateObject)
+          .datepicker({
+            showOn: "button",
+            buttonImage:
+              "https://dtwin-viewers.s3.ap-south-1.amazonaws.com/icons/calendar.svg",
+            buttonImageOnly: true,
+            buttonText: "Select date",
+            dateFormat: "yy-mm-dd",
+            changeMonth: true,
+            changeYear: true,
+            beforeShowDay: function (date) {
+              var string = jQuery.datepicker.formatDate("yy-mm-dd", date);
+              return [Object.keys(datesMap).indexOf(string) > -1];
+            },
+            onSelect: function (dateText, inst) {
+              let cam = locate(viewer_1);
+              if (snapshotNo === 1) {
+                window.location.href =
+                  "https://internal.constructn.ai/tour1?project=" +
+                  mainProjectID +
+                  "&structure=" +
+                  structure_id +
+                  "&snapshot1=" +
+                  datesMap[dateText] +
+                  "&snapshot2=" +
+                  inTilesetID2 +
+                  "&mode=" +
+                  mode +
+                  "&camera=" +
+                  JSON.stringify(cam) +
+                  "&token=" +
+                  token;
+              } else {
+                window.location.href =
+                  "https://internal.constructn.ai/tour1?project=" +
+                  mainProjectID +
+                  "&structure=" +
+                  structure_id +
+                  "&snapshot1=" +
+                  inTilesetID +
+                  "&snapshot2=" +
+                  datesMap[dateText] +
+                  "&mode=" +
+                  mode +
+                  "&camera=" +
+                  JSON.stringify(cam) +
+                  "&token=" +
+                  token;
+              }
+              // window.location.href = 'https://'+ window.location.host + '/tour?project=' + inProjectID + '&snapshot1=' + datesMap[dateText] + '&snapshot2=' + inTilesetID2 + '&isExterior=0&isFM=1&mode=3d'
+            },
+          })
+          .datepicker("setDate", new Date(defaultDate));
+      }
+
+      function updateIconsDisplay() {
+        Array.from(
+          document.getElementsByClassName("actionButtonsTest")
+        ).forEach((ele) => {
+          $(ele).show();
+          if ($(ele).children(":visible").length === 0) {
+            $(ele).hide();
+          }
+        });
+      }
+
+      function getValue(datesMap, value) {
+        for (let key of Object.keys(datesMap)) {
+          if (datesMap[key] === value) return key;
+        }
+      }
+
+      function takeScreenshot(uploadPath, viewer) {
+        return new Promise((resolve, reject) => {
+          viewer.renderer.domElement.toBlob(function (blob) {
+            // saveAs(blob, "wholePage.png");
+            let file = new File([blob], "task.png");
+            let bodyData = {
+              paths: [uploadPath],
+            };
+
+            $.ajax({
+              url: `https://internal.constructn.ai/api/v1/aws/put-signed-url?bucket=${s3_bucket}`,
+              method: "POST",
+              crossDomain: true,
+              data: JSON.stringify(bodyData),
+              processData: false,
+              contentType: "application/json",
+              success: (reqUrl) => {
+                console.log(reqUrl);
+                $.ajax({
+                  url: reqUrl[0],
+                  method: "PUT",
+                  processData: false,
+                  contentType: false,
+                  data: blob,
+                  success: (reqUrl) => {
+                    console.log("Uploaded Screenshot to S3");
+                    resolve(
+                      `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${uploadPath}`
+                    );
+                  },
+                  error: (e) => {
+                    console.log(e);
+                  },
+                });
+              },
+              error: (e) => {
+                console.log(e);
+              },
+            });
+          });
+          // let div =
+          //     document.getElementById('fpContainer_1');
+
+          // 	return new Promise(resolve => {
+
+          // 		html2canvas(div, {
+          // 			dpi: 200,
+          // 			onrendered: function (canvas) {
+          // 				canvas.toBlob(function(blob) {
+          // 					// saveAs(blob, "wholePage.png");
+          // 					let file = new File([blob], 'task.png')
+        });
+      }
+
+      function fly_progress_walk(in_guid, viewer) {
+        console.log("Progress Walk : Flying to ", in_guid);
+        let db_ids = bimProgressData[viewer.canvasId]["mapping"][in_guid];
+        console.log("DB ID : ", db_ids);
+        viewer.isolate(db_ids);
+        viewer.fitToView(db_ids);
+      }
+
+      function exit_progress_walk(viewer) {
+        viewer.showAll();
+        viewer.fitToView();
+        progress_walk_index = 0;
+      }
+
+      function update_progress_walk(viewer, direction) {
+        if (direction == "next") {
+          progress_walk_index += 1;
+        } else if (direction == "prev") {
+          progress_walk_index -= 1;
+        }
+
+        if (progress_walk_index < 0) {
+          progress_walk_index =
+            bimProgressData[viewer.canvasId]["progress_delta"].length - 1;
+        } else if (
+          progress_walk_index >=
+          bimProgressData[viewer.canvasId]["progress_delta"].length
+        ) {
+          progress_walk_index = 0;
+        }
+
+        fly_progress_walk(
+          bimProgressData[viewer.canvasId]["progress_delta"][
+            progress_walk_index
+          ],
+          viewer
+        );
+      }
+
+      function addProgressWalkButtons(viewer) {
+        // let group = new Autodesk.Viewing.UI.ControlGroup('BimProgress');
+        // viewer.toolbar.addControl(group);
+
+        let group = viewer.toolbar.getControl("BimProgress");
+
+        // Add a new button to the toolbar group
+        let button_walk = new Autodesk.Viewing.UI.Button("progress_walk");
+        let icon_walk =
+          "https://dtwin-viewers.s3.ap-south-1.amazonaws.com/icons/progress_walk.png";
+        button_walk.icon.style = `background-image: url(${icon_walk}); background-size: 24px 24px;`;
+        button_walk.setToolTip("Progress Walk");
+        button_walk.onClick = function (e) {
+          if (progress_walk_mode) {
+            exit_progress_walk(viewer);
+          } else {
+            update_progress_walk(viewer);
+          }
+          progress_walk_mode = !progress_walk_mode;
+        };
+
+        group.addControl(button_walk);
+
+        let button_next = new Autodesk.Viewing.UI.Button("progress_next");
+        let icon_next =
+          "https://dtwin-viewers.s3.ap-south-1.amazonaws.com/icons/progress_walk_next.png";
+        button_next.icon.style = `background-image: url(${icon_next}); background-size: 24px 24px;`;
+        button_next.setToolTip("Next");
+        button_next.onClick = function (e) {
+          if (progress_walk_mode) {
+            update_progress_walk(viewer, "next");
+          }
+        };
+
+        group.addControl(button_next);
+
+        let button_prev = new Autodesk.Viewing.UI.Button("progress_prev");
+        let icon_prev =
+          "https://dtwin-viewers.s3.ap-south-1.amazonaws.com/icons/progress_walk_prev.png";
+        button_prev.icon.style = `background-image: url(${icon_prev}); background-size: 24px 24px;`;
+        button_prev.setToolTip("Prev");
+        button_prev.onClick = function (e) {
+          if (progress_walk_mode) {
+            update_progress_walk(viewer, "prev");
+          }
+        };
+
+        group.addControl(button_prev);
+      }
+
+      async function start_progress_delta_walk(viewer) {
+        // const progress_delta_raw = await fetch(`http://localhost:4200/progress_delta.json`);
+        // if (progress_delta_raw.status == 200) {
+        // const progress_delta = JSON.parse(await progress_delta_raw.text())['delta_elements'];
+        // console.log(progress_delta);
+        // bimProgressData[viewer.canvasId]['progress_delta'] = progress_delta;
+        // fly_progress_walk(bimProgressData[viewer.canvasId]['progress_delta'][progress_walk_index], viewer)
+        // }
+      }
+
+      async function loadProgressWalk(viewer, projectID, tilesetID) {
+        // const progress_delta_raw = await fetch(`http://localhost:4200/progress_delta.json`);
+        const progress_delta_raw = await fetch(
+          `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${projectID}/snapshots/${tilesetID}/bim_progress_delta.json`
+        );
+        if (progress_delta_raw.status == 200) {
+          const progress_delta = JSON.parse(await progress_delta_raw.text())[
+            "delta_elements"
+          ];
+          bimProgressData[viewer.canvasId]["progress_delta"] = progress_delta;
+          addProgressWalkButtons(viewer);
+          console.log("Progress Walk Loaded");
+        }
+      }
+    </script>
+  </body>
+</html>
diff --git a/examples/lion_las.html b/examples/lion_las.html
index 1907e7d8..2df2bdb5 100644
--- a/examples/lion_las.html
+++ b/examples/lion_las.html
@@ -1,77 +1,350 @@
 <!DOCTYPE html>
 <html lang="en">
-<head>
-	<meta charset="utf-8">
-	<meta name="description" content="">
-	<meta name="author" content="">
-	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
-	<title>Potree Viewer</title>
+  <head>
+    <meta charset="utf-8" />
+    <meta name="description" content="" />
+    <meta name="author" content="" />
+    <meta
+      name="viewport"
+      content="width=device-width, initial-scale=1.0, user-scalable=no"
+    />
+    <title>Potree Viewer</title>
 
-	<link rel="stylesheet" type="text/css" href="../build/potree/potree.css">
-	<link rel="stylesheet" type="text/css" href="../libs/jquery-ui/jquery-ui.min.css">
-	<link rel="stylesheet" type="text/css" href="../libs/openlayers3/ol.css">
-	<link rel="stylesheet" type="text/css" href="../libs/spectrum/spectrum.css">
-	<link rel="stylesheet" type="text/css" href="../libs/jstree/themes/mixed/style.css">
-</head>
+    <link rel="stylesheet" type="text/css" href="../build/potree/potree.css" />
+    <link
+      rel="stylesheet"
+      type="text/css"
+      href="../libs/jquery-ui/jquery-ui.min.css"
+    />
+    <link rel="stylesheet" type="text/css" href="../libs/openlayers3/ol.css" />
+    <link
+      rel="stylesheet"
+      type="text/css"
+      href="../libs/spectrum/spectrum.css"
+    />
+    <link
+      rel="stylesheet"
+      type="text/css"
+      href="../libs/jstree/themes/mixed/style.css"
+    />
+  </head>
 
-<body>
-	<script src="../libs/jquery/jquery-3.1.1.min.js"></script>
-	<script src="../libs/spectrum/spectrum.js"></script>
-	<script src="../libs/jquery-ui/jquery-ui.min.js"></script>
-	<script src="../libs/other/BinaryHeap.js"></script>
-	<script src="../libs/tween/tween.min.js"></script>
-	<script src="../libs/d3/d3.js"></script>
-	<script src="../libs/proj4/proj4.js"></script>
-	<script src="../libs/openlayers3/ol.js"></script>
-	<script src="../libs/i18next/i18next.js"></script>
-	<script src="../libs/jstree/jstree.js"></script>
-	<script src="../build/potree/potree.js"></script>
-	<script src="../libs/plasio/js/laslaz.js"></script>
-	
-	<!-- INCLUDE ADDITIONAL DEPENDENCIES HERE -->
-	<!-- INCLUDE SETTINGS HERE -->
-	
-	<div class="potree_container" style="position: absolute; width: 100%; height: 100%; left: 0px; top: 0px; ">
-		<div id="potree_render_area" style="background-image: url('../build/potree/resources/images/background.jpg');"></div>
-		<div id="potree_sidebar_container"> </div>
-	</div>
-	
-	<script type="module">
+  <body>
+    <script src="../libs/jquery/jquery-3.1.1.min.js"></script>
+    <script src="../libs/spectrum/spectrum.js"></script>
+    <script src="../libs/jquery-ui/jquery-ui.min.js"></script>
+    <script src="../libs/other/BinaryHeap.js"></script>
+    <script src="../libs/tween/tween.min.js"></script>
+    <script src="../libs/d3/d3.js"></script>
+    <script src="../libs/proj4/proj4.js"></script>
+    <script src="../libs/openlayers3/ol.js"></script>
+    <script src="../libs/i18next/i18next.js"></script>
+    <script src="../libs/jstree/jstree.js"></script>
+    <script src="../build/potree/potree.js"></script>
+    <script src="../libs/plasio/js/laslaz.js"></script>
 
-	import * as THREE from "../libs/three.js/build/three.module.js";
-	
-		window.viewer = new Potree.Viewer(document.getElementById("potree_render_area"));
-		
-		viewer.setEDLEnabled(true);
-		viewer.setFOV(60);
-		viewer.setPointBudget(1_000_000);
-		viewer.loadSettingsFromURL();
-		
-		viewer.setDescription("Loading Octree of LAS files");
-		
-		viewer.loadGUI(() => {
-			viewer.setLanguage('en');
-			$("#menu_appearance").next().show();
-			//viewer.toggleSidebar();
-		});
-		
-		// Sigeom
-		Potree.loadPointCloud("../pointclouds/lion_takanawa_las/cloud.js", "lion", function(e){
-			viewer.scene.addPointCloud(e.pointcloud);
-			
-			let material = e.pointcloud.material;
-			material.size = 1;
-			material.pointSizeType = Potree.PointSizeType.ADAPTIVE;
-			
-			e.pointcloud.position.x += 3;
-			e.pointcloud.position.y -= 3;
-			e.pointcloud.position.z += 4;
-			
-			viewer.fitToScreen();
-		});
-		
-	</script>
-	
-	
+    <!-- INCLUDE ADDITIONAL DEPENDENCIES HERE -->
+    <!-- INCLUDE SETTINGS HERE -->
+
+    <div
+      class="potree_container"
+      style="position: absolute; width: 100%; height: 100%; left: 0px; top: 0px"
+    >
+      <div
+        id="potree_render_area"
+        style="
+          background-image: url('../build/potree/resources/images/background.jpg');
+        "
+      ></div>
+      <div id="potree_sidebar_container"></div>
+    </div>
+
+    <script type="module">
+      import * as THREE from "../libs/three.js/build/three.module.js";
+      let i = 0;
+      window.viewer = new Potree.Viewer(
+        document.getElementById("potree_render_area")
+      );
+      //viewer.setDescription(`<button id="myButton">Next Image</button> `);
+      viewer.setEDLEnabled(true);
+      viewer.setFOV(60);
+      viewer.setPointBudget(1_000_000);
+      viewer.loadSettingsFromURL();
+      viewer.loadGUI(() => {
+        viewer.setLanguage("en");
+        $("#menu_appearance").next().show();
+      });
+
+     
+      let viewerMode = "image";
+      // Sigeom
+      Potree.loadPointCloud(
+        "https://constructn-projects-us.s3.us-west-2.amazonaws.com/PRJ957090/structures/STR527991/snapshots/SNP153355/reality/RLT166449/pointcloud/cloud.js",
+        "lion",
+        function (e) {
+          viewer.scene.addPointCloud(e.pointcloud);
+
+          let scene = viewer.scene;
+          let pointcloud = e.pointcloud;
+
+          let material = pointcloud.material;
+          material.size = 0.5;
+          material.minSize = 2.0;
+          material.pointSizeType = Potree.PointSizeType.ADAPTIVE;
+          material.shape = Potree.PointShape.SQUARE;
+          material.activeAttributeName = "rgba";
+          let pcMatrix = new THREE.Matrix4().set(
+            1,
+            0,
+            0,
+            0,
+            0,
+            1,
+            0,
+            0,
+            0,
+            0,
+            1,
+            0,
+            0,
+            0,
+            0,
+            1
+          );
+          let pcOffset = [0, 0, 0];
+          pcMatrix = new THREE.Matrix4()
+            .fromArray([
+            1,
+            0,
+            0,
+            0,
+            0,
+            1,
+            0,
+            0,
+            0,
+            0,
+            1,
+            0,
+            0,
+            0,
+            0,
+            1
+            ])
+            .transpose();
+          pointcloud.applyMatrix(pcMatrix);
+          const assetPosition = pointcloud.position.clone();
+          pointcloud.position.set(
+            assetPosition.x - pcOffset[0],
+            assetPosition.y - pcOffset[1],
+            assetPosition.z - pcOffset[2]
+          );
+          scene.addPointCloud(pointcloud);
+          viewer.fitToScreen();
+          run();
+        }
+      );
+      //   async function run() {
+      //     viewerMode = "image";
+      //     let pcOffset = [0, 0, 0];
+      //     Potree.OrientedImageLoader.load(
+      //       "https://constructn-projects.s3.ap-south-1.amazonaws.com/PRJ156801/structures/STR238477/snapshots/SNP076949/images.json",
+      //       "https://constructn-projects.s3.ap-south-1.amazonaws.com/PRJ156801/structures/STR238477/snapshots/SNP076949/images",
+      //       viewer,
+      //       { tm: new THREE.Matrix4(), offset: pcOffset }
+      //     ).then((images) => {
+      //       console.log("images", images);
+      //       viewer.scene.addOrientedImages(images);
+      //       viewer.scene.orientedImages[0].moveToImage(
+      //         viewer.scene.orientedImages[0].images[i]
+      //       );
+      //     });
+
+      //viewer.mapView.showSources(false);
+      //}
+      //360 images loading
+      async function run() {
+        let pcOffset = [0, 0, 0];
+        Potree.Images360Loader.load(
+          "https://constructn-projects-us.s3.us-west-2.amazonaws.com/PRJ957090/structures/STR527991/snapshots/SNP153355/reality/RLT166449/images.json",
+          "https://constructn-projects-us.s3.us-west-2.amazonaws.com/PRJ957090/structures/STR527991/snapshots/SNP153355/reality/RLT166449/images",
+          viewer,
+          { tm: new THREE.Matrix4(), offset: pcOffset }
+        ).then((images) => {
+          viewer.scene.add360Images(images);
+          viewer.scene.images360[0].focus(viewer.scene.images360[0].images[i]);
+        });
+
+        //viewer.mapView.showSources(false);
+      }
+
+      //   function removeAssets(viewer) {
+      //     viewer.scene.scenePointCloud.remove(viewer.scene.pointclouds[0]);
+      //     viewer.scene.pointclouds = [];
+      //     if (viewer.scene.orientedImages.length) {
+      //       viewer.scene.orientedImages[0].release();
+      //       viewer.scene.orientedImages[0].images.forEach((image) => {
+      //         viewer.scene.scene.children[0].remove(image.mesh);
+      //         viewer.scene.scene.children[0].remove(image.line);
+      //       });
+      //       viewer.scene.scene.remove(viewer.scene.scene.children[0]);
+      //       viewer.scene.removeOrientedImages(viewer.scene.orientedImages[0]);
+      //     }
+
+      //     if (viewer.scene.images360.length) {
+      //       viewer.scene.images360[0].unfocus(false);
+      //       viewer.scene.images360[0].images.forEach((image) => {
+      //         viewer.scene.scene.children[0].remove(image.mesh);
+      //       });
+      //       viewer.scene.scene.children[0].remove(
+      //         viewer.scene.images360[0].sphere
+      //       );
+      //       viewer.scene.scene.remove(viewer.scene.scene.children[0]);
+      //       viewer.scene.remove360Images(viewer.scene.images360[0]);
+      //     }
+      //     if (viewer.isFloorMap) {
+      //       removeFloorMap(viewer);
+      //     }
+      //   }
+      document.addEventListener("keydown", (event) => {
+        if (event.key === "Escape") {
+          // Exit in viewer 2 is already handled in contex maintanance
+          if (viewerMode == "image") {
+            viewer.controls.elExit.click();
+          }
+          // else if (viewerMode == 'panorama') {
+          //     viewer.scene.images360[0].unfocus();
+          // }
+        } else if (event.key === "ArrowUp") {
+          // up arrow
+          if (viewerMode == "image") {
+            viewer.controls.elUp.click();
+            // if (isCompareMode && compareType == "potree") {
+            //   viewer_2.controls.elUp.click();
+            // }
+          } else if (viewerMode == "panorama") {
+            if (event.ctrlKey) {
+              setPitch(viewer, 0.5);
+              //   if (isCompareMode && compareType == "potree") {
+              //     setPitch(viewer_2, 0.5);
+              //   }
+            } else {
+              nextPanoImage(viewer);
+            }
+          }
+        } else if (event.key === "ArrowDown") {
+          // down arrow
+          if (viewerMode == "image") {
+            viewer.controls.elDown.click();
+            if (isCompareMode && compareType == "potree") {
+              viewer_2.controls.elDown.click();
+            }
+          } else if (viewerMode == "panorama") {
+            if (event.ctrlKey) {
+              setPitch(viewer, -0.5);
+              if (isCompareMode && compareType == "potree") {
+                setPitch(viewer_2, -0.5);
+              }
+            }
+          }
+        } else if (event.key === "ArrowLeft") {
+          // left arrow
+          if (viewerMode == "image") {
+            viewer.controls.elLeft.click();
+            if (isCompareMode && compareType == "potree") {
+              viewer_2.controls.elLeft.click();
+            }
+          } else if (viewerMode == "panorama") {
+            setYaw(viewer, 0.5);
+            if (isCompareMode && compareType == "potree") {
+              setYaw(viewer_2, 0.5);
+            }
+          }
+        } else if (event.key === "ArrowRight") {
+          // right arrow
+          if (viewerMode == "image") {
+            viewer.controls.elRight.click();
+            if (isCompareMode && compareType == "potree") {
+              viewer_2.controls.elRight.click();
+            }
+          } else if (viewerMode == "panorama") {
+            setYaw(viewer, -0.5);
+            if (isCompareMode && compareType == "potree") {
+              setYaw(viewer_2, -0.5);
+            }
+          }
+        }
+      });
+      //   function nextPanoImage(viewer) {
+      //     let cameraInstance = viewer.scene.cameraP;
+      //     const camDir = new THREE.Vector3();
+      //     cameraInstance.getWorldDirection(camDir);
+      //     camDir.normalize();
+      //     const camPos = cameraInstance.position;
+      //     const weightages = { angle: 0.5, distance: 0.5 };
+      //     let totalSum = 10000;
+      //     let curSum;
+      //     let selectedPanoImageId;
+      //     let cameraViewProjectionMatrix;
+      //     let imgPos;
+      //     let dist;
+      //     let angle;
+      //     let frustum;
+      //     const camToImgDir = new THREE.Vector3();
+      //     const maxDist = 10;
+      //     const panoImgs = viewer.scene.images360[0].images;
+
+      //     for (let i = 0; i < panoImgs.length; i++) {
+      //       if (panoImgs[i].file == viewer.scene.images360[0].focusedImage.file) {
+      //         continue;
+      //       }
+      //       imgPos = new THREE.Vector3().fromArray(panoImgs[i].position);
+      //       frustum = new THREE.Frustum();
+      //       cameraViewProjectionMatrix = new THREE.Matrix4();
+      //       cameraInstance.updateMatrixWorld(); // make sure the camera matrix is updated
+      //       // cameraInstance.matrixWorldInverse.getInverse(cameraInstance.matrixWorld);
+      //       cameraInstance.matrixWorldInverse
+      //         .copy(cameraInstance.matrixWorld)
+      //         .invert();
+      //       cameraViewProjectionMatrix.multiplyMatrices(
+      //         cameraInstance.projectionMatrix,
+      //         cameraInstance.matrixWorldInverse
+      //       );
+      //       frustum.setFromMatrix(cameraViewProjectionMatrix);
+
+      //       // // if (frustum.containsPoint(imgPos)) {
+      //       dist = imgPos.distanceTo(camPos);
+      //       if (dist < maxDist) {
+      //         camToImgDir.subVectors(imgPos, camPos).normalize();
+      //         angle = Math.abs(camToImgDir.angleTo(camDir));
+      //         // tslint:disable-next-line: no-string-literal
+      //         curSum =
+      //           weightages["angle"] * angle + weightages["distance"] * dist;
+      //         if (curSum < totalSum) {
+      //           selectedPanoImageId = i;
+      //           totalSum = curSum;
+      //         }
+      //       }
+      //       // // }
+
+      //       // dist = imgPos.distanceTo(camPos);
+      //       // if (dist < maxDist) {
+      //       //     camToImgDir.subVectors(imgPos, camPos).normalize();
+      //       //     angle = Math.abs(camToImgDir.angleTo(camDir));
+      //       //     // tslint:disable-next-line: no-string-literal
+      //       //     // curSum = (weightages['angle'] * angle) + (weightages['distance'] * dist);
+      //       //     if (angle < totalSum) {
+      //       //         selectedPanoImageId = i;
+      //       //         totalSum = angle;
+      //       //     }
+      //       // }
+      //     }
+      //     if (selectedPanoImageId != undefined) {
+      //       viewer.scene.images360[0].focus(panoImgs[selectedPanoImageId]);
+      //     } else {
+      //       console.warn("No Nearest 360 Images");
+      //     }
+      //   }
+    </script>
   </body>
 </html>
diff --git a/patch-constructN.patch b/patch-constructN.patch
new file mode 100644
index 00000000..80fce7fb
--- /dev/null
+++ b/patch-constructN.patch
@@ -0,0 +1,9115 @@
+From 255ec3d4fbc8c841288d2f5cb5f447824ec165ba Mon Sep 17 00:00:00 2001
+From: SathyaKrishna Vanama <sathyakrishna.vanama@constructn.ai>
+Date: Wed, 14 Jun 2023 17:21:46 +0530
+Subject: [PATCH 1/9] code enhancements completed
+
+---
+ commands.txt                                  |   19 +
+ examples/colorextension.js                    |  109 +
+ examples/colorextension_optimized.js          |   52 +
+ examples/dtwin_viewer_v0.html                 | 3603 +++++++++++++++++
+ examples/lion_las.html                        |  445 +-
+ src/modules/Images360/Images360.js            |  643 ++-
+ .../OrientedImages/OrientedImageControls.js   |   37 +-
+ src/modules/OrientedImages/OrientedImages.js  |  902 ++---
+ src/navigation/OrbitControls.js               |  580 +--
+ src/viewer/Scene.js                           |  885 ++--
+ src/viewer/map.js                             |    2 +-
+ src/viewer/viewer.js                          |  172 +-
+ 12 files changed, 5784 insertions(+), 1665 deletions(-)
+ create mode 100644 commands.txt
+ create mode 100644 examples/colorextension.js
+ create mode 100644 examples/colorextension_optimized.js
+ create mode 100644 examples/dtwin_viewer_v0.html
+
+diff --git a/commands.txt b/commands.txt
+new file mode 100644
+index 00000000..ddfbd1a3
+--- /dev/null
++++ b/commands.txt
+@@ -0,0 +1,19 @@
++curl -v 'https://developer.api.autodesk.com/authentication/v1/authenticate' -X 'POST' -H 'Content-Type: application/x-www-form-urlencoded' -d 'client_id=aJRMrmok5UAbsdsXjckJmSBmoNnYKLzM&client_secret=mSqemcEE53l4THBJ&grant_type=client_credentials&scope=data:read%20data:write%20viewables:read%20bucket:create%20bucket:read'
++
++eyJhbGciOiJSUzI1NiIsImtpZCI6IlU3c0dGRldUTzlBekNhSzBqZURRM2dQZXBURVdWN2VhIn0.eyJzY29wZSI6WyJkYXRhOnJlYWQiLCJkYXRhOndyaXRlIiwidmlld2FibGVzOnJlYWQiLCJidWNrZXQ6Y3JlYXRlIiwiYnVja2V0OnJlYWQiXSwiY2xpZW50X2lkIjoiYUpSTXJtb2s1VUFic2RzWGpja0ptU0Jtb05uWUtMek0iLCJhdWQiOiJodHRwczovL2F1dG9kZXNrLmNvbS9hdWQvYWp3dGV4cDYwIiwianRpIjoibk5iYVlqamRLME5OU1QzVndneHFtbEVVRFZaM1h0b2VydUtBM1FQSkxva2JQSVBMbWRaeWlQMUNIb2JnalZwUCIsImV4cCI6MTYyNTY1OTQ0NH0.CdolgqfI6YO4Bc7U7c3FGIR080fwlwDAXauXKPg4eqgjSdaYYdgK_ch-ahO-STi_Nl2p7a2TirotH3opgYp0CbyyXL6_fd8ETkk6eX0vKU0LOo7D6gk0CtigKWF7Xxta6icsWUM80lDNppYiSW1Cn1pWaAxHyQ4aSqfjlNVRdQ48V-d8MJ6VmbgCz57UyCcmUtkESrwgYzxOmvoVqwWDA72J6Uoj4gHU5pJnDjaOtzaOzIui11V1dgMZgsUkkoa1GpzarIsRKMeBGhyldTOD474pKn-L-vhM7qtfYjTbq24w9hHAHsnxWvuBdCMogwoWLh4mek4HPO72YpwTQAd8wA
++
++curl -v 'https://developer.api.autodesk.com/oss/v2/buckets' -X 'POST' -H 'Content-Type: application/json' -H 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsImtpZCI6Imp3dF9zeW1tZXRyaWNfa2V5In0.eyJjbGllbnRfaWQiOiJpWFdZbTNGVkdNaExZTHNzQVFBd2RNR01xNUhzQXdOYiIsImV4cCI6MTU4NTEyMTY0NSwic2NvcGUiOlsiZGF0YTpyZWFkIiwiZGF0YTp3cml0ZSIsInZpZXdhYmxlczpyZWFkIiwiYnVja2V0OmNyZWF0ZSIsImJ1Y2tldDpyZWFkIl0sImF1ZCI6Imh0dHBzOi8vYXV0b2Rlc2suY29tL2F1ZC9qd3RleHA2MCIsImp0aSI6Im10VklEWGtrOUJwUVBUYU84UlpEV3NWNWpCSHR3VkRObUIwVlN3dnJVeXFiNTVveFlibW5vaUNsMk02Vks4Ym4ifQ.71YkbtExiXDVkWeGODigBWGViNj9_5RSHwTjgvd_MME' -d '{"bucketKey":"threeforge","policyKey":"transient"}'
++digitaltwins
++Verify Bucket
++curl -v 'https://developer.api.autodesk.com/oss/v2/buckets/dtwin/details' -X 'GET' -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IlU3c0dGRldUTzlBekNhSzBqZURRM2dQZXBURVdWN2VhIn0.eyJzY29wZSI6WyJkYXRhOnJlYWQiLCJkYXRhOndyaXRlIiwidmlld2FibGVzOnJlYWQiLCJidWNrZXQ6Y3JlYXRlIiwiYnVja2V0OnJlYWQiXSwiY2xpZW50X2lkIjoiYUpSTXJtb2s1VUFic2RzWGpja0ptU0Jtb05uWUtMek0iLCJhdWQiOiJodHRwczovL2F1dG9kZXNrLmNvbS9hdWQvYWp3dGV4cDYwIiwianRpIjoibk5iYVlqamRLME5OU1QzVndneHFtbEVVRFZaM1h0b2VydUtBM1FQSkxva2JQSVBMbWRaeWlQMUNIb2JnalZwUCIsImV4cCI6MTYyNTY1OTQ0NH0.CdolgqfI6YO4Bc7U7c3FGIR080fwlwDAXauXKPg4eqgjSdaYYdgK_ch-ahO-STi_Nl2p7a2TirotH3opgYp0CbyyXL6_fd8ETkk6eX0vKU0LOo7D6gk0CtigKWF7Xxta6icsWUM80lDNppYiSW1Cn1pWaAxHyQ4aSqfjlNVRdQ48V-d8MJ6VmbgCz57UyCcmUtkESrwgYzxOmvoVqwWDA72J6Uoj4gHU5pJnDjaOtzaOzIui11V1dgMZgsUkkoa1GpzarIsRKMeBGhyldTOD474pKn-L-vhM7qtfYjTbq24w9hHAHsnxWvuBdCMogwoWLh4mek4HPO72YpwTQAd8wA'
++
++
++curl -v 'https://developer.api.autodesk.com/oss/v2/buckets/dtwin/objects/floor_4.ifc' -X 'PUT' -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IlU3c0dGRldUTzlBekNhSzBqZURRM2dQZXBURVdWN2VhIn0.eyJzY29wZSI6WyJkYXRhOnJlYWQiLCJkYXRhOndyaXRlIiwidmlld2FibGVzOnJlYWQiLCJidWNrZXQ6Y3JlYXRlIiwiYnVja2V0OnJlYWQiXSwiY2xpZW50X2lkIjoiYUpSTXJtb2s1VUFic2RzWGpja0ptU0Jtb05uWUtMek0iLCJhdWQiOiJodHRwczovL2F1dG9kZXNrLmNvbS9hdWQvYWp3dGV4cDYwIiwianRpIjoibk5iYVlqamRLME5OU1QzVndneHFtbEVVRFZaM1h0b2VydUtBM1FQSkxva2JQSVBMbWRaeWlQMUNIb2JnalZwUCIsImV4cCI6MTYyNTY1OTQ0NH0.CdolgqfI6YO4Bc7U7c3FGIR080fwlwDAXauXKPg4eqgjSdaYYdgK_ch-ahO-STi_Nl2p7a2TirotH3opgYp0CbyyXL6_fd8ETkk6eX0vKU0LOo7D6gk0CtigKWF7Xxta6icsWUM80lDNppYiSW1Cn1pWaAxHyQ4aSqfjlNVRdQ48V-d8MJ6VmbgCz57UyCcmUtkESrwgYzxOmvoVqwWDA72J6Uoj4gHU5pJnDjaOtzaOzIui11V1dgMZgsUkkoa1GpzarIsRKMeBGhyldTOD474pKn-L-vhM7qtfYjTbq24w9hHAHsnxWvuBdCMogwoWLh4mek4HPO72YpwTQAd8wA' -H 'Content-Type: application/octet-stream' -T 'floor_4.ifc'
++
++urn:adsk.objects:os.object:dtwin/floor_4.ifc
++
++dXJuOmFkc2sub2JqZWN0czpvcy5vYmplY3Q6ZHR3aW4vZmxvb3JfNC5pZmM=
++
++curl -X 'POST' -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IlU3c0dGRldUTzlBekNhSzBqZURRM2dQZXBURVdWN2VhIn0.eyJzY29wZSI6WyJkYXRhOnJlYWQiLCJkYXRhOndyaXRlIiwidmlld2FibGVzOnJlYWQiLCJidWNrZXQ6Y3JlYXRlIiwiYnVja2V0OnJlYWQiXSwiY2xpZW50X2lkIjoiYUpSTXJtb2s1VUFic2RzWGpja0ptU0Jtb05uWUtMek0iLCJhdWQiOiJodHRwczovL2F1dG9kZXNrLmNvbS9hdWQvYWp3dGV4cDYwIiwianRpIjoibk5iYVlqamRLME5OU1QzVndneHFtbEVVRFZaM1h0b2VydUtBM1FQSkxva2JQSVBMbWRaeWlQMUNIb2JnalZwUCIsImV4cCI6MTYyNTY1OTQ0NH0.CdolgqfI6YO4Bc7U7c3FGIR080fwlwDAXauXKPg4eqgjSdaYYdgK_ch-ahO-STi_Nl2p7a2TirotH3opgYp0CbyyXL6_fd8ETkk6eX0vKU0LOo7D6gk0CtigKWF7Xxta6icsWUM80lDNppYiSW1Cn1pWaAxHyQ4aSqfjlNVRdQ48V-d8MJ6VmbgCz57UyCcmUtkESrwgYzxOmvoVqwWDA72J6Uoj4gHU5pJnDjaOtzaOzIui11V1dgMZgsUkkoa1GpzarIsRKMeBGhyldTOD474pKn-L-vhM7qtfYjTbq24w9hHAHsnxWvuBdCMogwoWLh4mek4HPO72YpwTQAd8wA' -H 'Content-Type: application/json' -v 'https://developer.api.autodesk.com/modelderivative/v2/designdata/job' -d '{"input": {"urn": "dXJuOmFkc2sub2JqZWN0czpvcy5vYmplY3Q6ZHR3aW4vZmxvb3JfNC5pZmM="},"output":{"formats":[{"type":"svf","views":["2d","3d"]}]}}'
++
++curl -X 'GET' -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IlU3c0dGRldUTzlBekNhSzBqZURRM2dQZXBURVdWN2VhIn0.eyJzY29wZSI6WyJkYXRhOnJlYWQiLCJkYXRhOndyaXRlIiwidmlld2FibGVzOnJlYWQiLCJidWNrZXQ6Y3JlYXRlIiwiYnVja2V0OnJlYWQiXSwiY2xpZW50X2lkIjoiYUpSTXJtb2s1VUFic2RzWGpja0ptU0Jtb05uWUtMek0iLCJhdWQiOiJodHRwczovL2F1dG9kZXNrLmNvbS9hdWQvYWp3dGV4cDYwIiwianRpIjoibk5iYVlqamRLME5OU1QzVndneHFtbEVVRFZaM1h0b2VydUtBM1FQSkxva2JQSVBMbWRaeWlQMUNIb2JnalZwUCIsImV4cCI6MTYyNTY1OTQ0NH0.CdolgqfI6YO4Bc7U7c3FGIR080fwlwDAXauXKPg4eqgjSdaYYdgK_ch-ahO-STi_Nl2p7a2TirotH3opgYp0CbyyXL6_fd8ETkk6eX0vKU0LOo7D6gk0CtigKWF7Xxta6icsWUM80lDNppYiSW1Cn1pWaAxHyQ4aSqfjlNVRdQ48V-d8MJ6VmbgCz57UyCcmUtkESrwgYzxOmvoVqwWDA72J6Uoj4gHU5pJnDjaOtzaOzIui11V1dgMZgsUkkoa1GpzarIsRKMeBGhyldTOD474pKn-L-vhM7qtfYjTbq24w9hHAHsnxWvuBdCMogwoWLh4mek4HPO72YpwTQAd8wA' -v 'https://developer.api.autodesk.com/modelderivative/v2/designdata/dXJuOmFkc2sub2JqZWN0czpvcy5vYmplY3Q6ZHR3aW4vZmxvb3JfNC5pZmM=/manifest'
+\ No newline at end of file
+diff --git a/examples/colorextension.js b/examples/colorextension.js
+new file mode 100644
+index 00000000..a1bdf86f
+--- /dev/null
++++ b/examples/colorextension.js
+@@ -0,0 +1,109 @@
++///////////////////////////////////////////////////////////////////////////////
++// Autodesk.ADN.Viewing.Extension.Color
++//
++///////////////////////////////////////////////////////////////////////////////
++AutodeskNamespace("Autodesk.ADN.Viewing.Extension");
++Autodesk.ADN.Viewing.Extension.Color = function(viewer, options) {
++
++    Autodesk.Viewing.Extension.call(this, viewer, options);
++
++    var overlayName = "temperary-colored-overlay";
++    var _self = this;
++    var defMaterials = {}
++
++    _self.load = function() {
++
++        console.log('Autodesk.ADN.Viewing.Extension.Color loaded');
++        ///////////////////////////////////////////////////////////////////////////
++        // Generate GUID
++        //
++        ///////////////////////////////////////////////////////////////////////////
++        // function newGuid() {
++        //     var d = new Date().getTime();
++        //     var guid = 'xxxx-xxxx-xxxx-xxxx-xxxx'.replace(/[xy]/g, function(c) {
++        //         var r = (d + Math.random() * 16) % 16 | 0;
++        //         d = Math.floor(d / 16);
++        //         return (c == 'x' ? r : (r & 0x7 | 0x8)).toString(16);
++        //     });
++        //     return guid;
++        // };
++
++        ///////////////////////////////////////////////////////////////////////////
++        // add new material
++        //
++        ///////////////////////////////////////////////////////////////////////////
++        function addMaterial(color, name) {
++            var material =  new THREE.MeshPhongMaterial({side: THREE.DoubleSide, color, opacity: 1, transparent: false})
++            viewer.impl.matman().addMaterial(name, material);
++            // viewer.impl.createOverlayScene(name, material, material);
++            return material;
++        }
++
++        ///////////////////////////////////////////////////////////////////////////
++        // Set color for nodes
++        // objectIds should be an array of dbId
++        // 
++        //
++        ///////////////////////////////////////////////////////////////////////////
++        Autodesk.Viewing.Viewer3D.prototype.setColorMaterial = function(objectIds, color, name) {
++            var material = addMaterial(color, name);
++            const frags = viewer.model.getFragmentList();
++            for (var i=0; i<objectIds.length; i++) {
++
++                var dbid = objectIds[i];
++
++                //from dbid to node, to fragid
++                var it = viewer.model.getData().instanceTree;
++
++                it.enumNodeFragments(dbid, function (fragId) {
++    
++                    defMaterials[dbid] = viewer.model.getFragmentList().getMaterial(fragId);
++                    // var renderProxy = viewer.impl.getRenderProxy(viewer.model, fragId);
++                    
++                    // renderProxy.meshProxy = new THREE.Mesh(renderProxy.geometry, renderProxy.material);
++
++                    // renderProxy.meshProxy.matrix.copy(renderProxy.matrixWorld);
++                    // renderProxy.meshProxy.matrixWorldNeedsUpdate = true;
++                    // renderProxy.meshProxy.matrixAutoUpdate = false;
++                    // renderProxy.meshProxy.frustumCulled = false;
++
++                    // viewer.impl.addOverlay(name, renderProxy.meshProxy);
++                    frags.setMaterial(fragId, material);
++                    viewer.impl.invalidate(true);
++                    
++                }, false);
++            }
++
++        }
++
++
++        Autodesk.Viewing.Viewer3D.prototype.restoreColorMaterial = function(objectIds) {
++       
++            const frags = viewer.model.getFragmentList();
++            for (var i=0; i<objectIds.length; i++) {
++
++                var dbid = objectIds[i];
++
++                //from dbid to node, to fragid
++                var it = viewer.model.getData().instanceTree;
++
++                it.enumNodeFragments(dbid, function (fragId) {
++                    if (defMaterials[dbid]) {
++                        frags.setMaterial(fragId, defMaterials[dbid]);
++                        viewer.impl.invalidate(true);
++                    }
++                    
++                }, false);
++            }
++  
++        }
++
++        _self.unload = function() {
++            console.log('Autodesk.ADN.Viewing.Extension.Color unloaded');
++            return true;
++        };
++    };
++};
++Autodesk.ADN.Viewing.Extension.Color.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
++Autodesk.ADN.Viewing.Extension.Color.prototype.constructor = Autodesk.ADN.Viewing.Extension.Color;
++Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.ADN.Viewing.Extension.Color', Autodesk.ADN.Viewing.Extension.Color);
+\ No newline at end of file
+diff --git a/examples/colorextension_optimized.js b/examples/colorextension_optimized.js
+new file mode 100644
+index 00000000..15ac71c9
+--- /dev/null
++++ b/examples/colorextension_optimized.js
+@@ -0,0 +1,52 @@
++AutodeskNamespace("Autodesk.ADN.Viewing.Extension");
++Autodesk.ADN.Viewing.Extension.Color = function(viewer, options) {
++
++    Autodesk.Viewing.Extension.call(this, viewer, options);
++
++    var overlayName = "temperary-colored-overlay";
++    var _self = this;
++    var defMaterials = {}
++    var materials = {}
++
++    _self.load = function() {
++
++        console.log('Autodesk.ADN.Viewing.Extension.Color loaded');
++        
++        function addMaterial(color, name) {
++            if (name in materials){
++                return materials[name]
++            } else {
++                console.log('Creating Material for ', name)
++                const material = new THREE.Vector4(color[0], color[1], color[2], color[3]);
++                materials[name] = material
++                return material;
++            }
++
++        }
++
++        Autodesk.Viewing.Viewer3D.prototype.setColorMaterial = function(objectIds, color, name) {
++            var material = addMaterial(color, name);
++            const frags = viewer.model.getFragmentList();
++            //from dbid to node, to fragid
++            var it = viewer.model.getData().instanceTree;
++            for (var i=0; i<objectIds.length; i++) {
++                var dbid = objectIds[i];
++                viewer.setThemingColor(dbid, material, null, true);
++            }
++            viewer.impl.invalidate(true);
++        }
++
++        Autodesk.Viewing.Viewer3D.prototype.restoreColorMaterial = function(objectIds) {
++            viewer.clearThemingColors();
++            viewer.impl.invalidate(true);
++        }
++
++        _self.unload = function() {
++            console.log('Autodesk.ADN.Viewing.Extension.Color unloaded');
++            return true;
++        };
++    };
++};
++Autodesk.ADN.Viewing.Extension.Color.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
++Autodesk.ADN.Viewing.Extension.Color.prototype.constructor = Autodesk.ADN.Viewing.Extension.Color;
++Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.ADN.Viewing.Extension.Color', Autodesk.ADN.Viewing.Extension.Color);
+\ No newline at end of file
+diff --git a/examples/dtwin_viewer_v0.html b/examples/dtwin_viewer_v0.html
+new file mode 100644
+index 00000000..0624ae6a
+--- /dev/null
++++ b/examples/dtwin_viewer_v0.html
+@@ -0,0 +1,3603 @@
++<!DOCTYPE html>
++<html lang="en">
++  <head>
++    <meta charset="utf-8" />
++    <meta name="description" content="" />
++    <meta name="author" content="" />
++    <meta
++      name="viewport"
++      content="width=device-width, initial-scale=1.0, user-scalable=no"
++    />
++    <title>Potree Viewer</title>
++
++    <link rel="stylesheet" type="text/css" href="../build/potree/potree.css" />
++    <link
++      rel="stylesheet"
++      type="text/css"
++      href="../libs/jquery-ui/jquery-ui.min.css"
++    />
++    <link rel="stylesheet" type="text/css" href="../libs/openlayers3/ol.css" />
++    <link
++      rel="stylesheet"
++      type="text/css"
++      href="../libs/spectrum/spectrum.css"
++    />
++    <link
++      rel="stylesheet"
++      type="text/css"
++      href="../libs/jstree/themes/mixed/style.css"
++    />
++    <link
++      rel="stylesheet"
++      href="https://developer.api.autodesk.com/modelderivative/v2/viewers/7.*/style.min.css"
++      type="text/css"
++    />
++    <script src="https://developer.api.autodesk.com/modelderivative/v2/viewers/7.*/viewer3D.min.js"></script>
++    <link
++      rel="stylesheet"
++      href="https://fonts.googleapis.com/icon?family=Material+Icons"
++    />
++    <link
++      rel="stylesheet"
++      href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css"
++    />
++    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
++    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
++    <script src="./colorextension_optimized.js"></script>
++    <script>
++      (function (h, o, t, j, a, r) {
++        h.hj =
++          h.hj ||
++          function () {
++            (h.hj.q = h.hj.q || []).push(arguments);
++          };
++        h._hjSettings = { hjid: 2746579, hjsv: 6 };
++        a = o.getElementsByTagName("head")[0];
++        r = o.createElement("script");
++        r.async = 1;
++        r.src = t + h._hjSettings.hjid + j + h._hjSettings.hjsv;
++        a.appendChild(r);
++      })(window, document, "https://static.hotjar.com/c/hotjar-", ".js?sv=");
++    </script>
++    <style>
++      .dropup .dropdown-menu,
++      .navbar-fixed-bottom .dropdown .dropdown-menu {
++        bottom: 5%;
++        background-color: rgba(34, 34, 34, 0.94);
++      }
++      .dropdown-menu {
++        min-width: 230px;
++        left: 50px;
++      }
++      .panoIcon {
++        background: greenyellow;
++        border-radius: 100%;
++        position: absolute;
++        z-index: 101;
++        opacity: 0.7;
++      }
++
++      .panoIcon:hover {
++        background: rgb(0, 217, 255);
++        cursor: pointer;
++        opacity: 1;
++      }
++
++      .userIcon {
++        width: 20px;
++        height: 20px;
++        position: absolute;
++        z-index: 1000;
++      }
++
++      .actionIcon {
++        font-size: 50px;
++        /* border-style: double; */
++        color: white;
++        border-radius: 10px;
++        background-color: rgba(34, 34, 34, 0.94);
++        display: inline-block;
++        position: relative;
++      }
++
++      .actionIcon:hover {
++        cursor: pointer;
++      }
++
++      .fpFullScreen {
++        position: absolute;
++        top: 1%;
++        right: 1%;
++      }
++
++      .fpFullScreen:hover {
++        cursor: pointer;
++      }
++
++      .actionButtons {
++        position: absolute;
++        bottom: 10px;
++        width: calc(100% - 20px);
++        height: 50px;
++        text-align: center;
++        z-index: 100;
++        display: none;
++      }
++
++      .floormap {
++        position: absolute;
++        right: 0px;
++        top: 10px;
++        z-index: 100;
++        display: none;
++      }
++
++      .goto3d {
++        right: 2%;
++        position: absolute;
++        display: none;
++      }
++
++      .noBIM {
++        background: #e1e1e1;
++        margin: 0 auto;
++        position: absolute;
++        z-index: 200;
++        top: 25%;
++        left: 25%;
++        height: calc(100% - 50%);
++        width: calc(100% - 50%);
++        padding: 30px;
++        -webkit-box-shadow: 0 0 10px rgba(0, 0, 0, 0.4);
++        -moz-box-shadow: 0 0 10px rgba(0, 0, 0, 0.4);
++        box-shadow: 0 0 10px rgba(0, 0, 0, 0.4);
++        display: none;
++        text-align: center;
++        vertical-align: middle;
++      }
++      .utility_icons {
++        position: relative;
++        cursor: pointer;
++        padding: 6px;
++        margin: 4px;
++        border: 1px solid rgba(34, 34, 34, 0);
++        border-radius: 4px;
++        display: inline-block;
++        padding-top: 3px;
++        font-size: 24px;
++        line-height: 1;
++        background-repeat: no-repeat;
++        background-position: 50%;
++      }
++      .actionButtonsTest {
++        color: #f4f4f4;
++        background-color: rgba(34, 34, 34, 0.94);
++        box-shadow: 1px 3px 10px 0 rgb(0 0 0 / 50%);
++        position: relative;
++        float: left;
++        cursor: pointer;
++        padding: 6px;
++        margin: 4px;
++        border: 1px solid rgba(34, 34, 34, 0);
++        border-radius: 4px;
++      }
++      .icon-test {
++        padding: 5px;
++      }
++      .icon-test:hover {
++        color: #f5ca52;
++        border: 1px solid #f5ca52;
++      }
++      .icon-test:focus {
++        color: #f5ca52;
++        outline: none;
++        border-radius: 3px;
++        box-shadow: inset 0 2px 2px 0 #000;
++      }
++      .s3-icon {
++        width: 30px;
++        height: 30px;
++        margin: 2px;
++      }
++      #datepickerLeft,
++      #datepickerRight {
++        color: #000;
++        padding: 4px;
++        margin-right: 5px;
++      }
++      .closeBtn {
++        position: absolute;
++        float: left;
++        z-index: 9;
++      }
++      .bim-legend-container {
++        right: 10px;
++        bottom: 10px;
++        position: absolute;
++        background-color: rgba(34, 34, 34, 0.94);
++        z-index: 2;
++        display: none;
++      }
++
++      .bim-legend {
++        list-style: none;
++      }
++      .bim-legend li {
++        margin-right: 10px;
++        color: #f4f4f4;
++        cursor: pointer;
++      }
++      .bim-legend span {
++        border: 1px solid #ccc;
++        float: left;
++        width: 12px;
++        height: 12px;
++        margin: 2px;
++      }
++      .bim-legend .not_started {
++        background-color: #ff0000;
++      }
++      .bim-legend .in_progress {
++        background-color: #f39b3a;
++      }
++      .bim-legend .complete {
++        background-color: #71e03a;
++      }
++
++      .bim-details-card {
++        float: right;
++        width: 20%;
++        /* background:rgb(249, 247, 249); */
++        right: 1%;
++        top: 50%;
++        height: 25%;
++        position: absolute;
++        z-index: 2;
++        display: none;
++      }
++
++      table {
++        font-family: arial, sans-serif;
++        border-collapse: collapse;
++        width: 100%;
++      }
++
++      td,
++      th {
++        border: 1px solid #dddddd;
++        text-align: left;
++        padding: 8px;
++        background-color: #dddddd;
++      }
++
++      .bim-card-close {
++        right: 0px;
++        top: 0px;
++        z-index: 2;
++        position: absolute;
++      }
++
++      .bim-card-close:hover {
++        /* background: rgb(0, 217, 255); */
++        cursor: pointer;
++        /* opacity: 1; */
++      }
++    </style>
++  </head>
++
++  <body>
++    <script src="../libs/jquery/jquery-3.1.1.min.js"></script>
++    <script src="../libs/spectrum/spectrum.js"></script>
++    <script src="../libs/jquery-ui/jquery-ui.min.js"></script>
++    <script src="../libs/other/BinaryHeap.js"></script>
++    <script src="../libs/tween/tween.min.js"></script>
++    <script src="../libs/d3/d3.js"></script>
++    <script src="../libs/proj4/proj4.js"></script>
++    <script src="../libs/openlayers3/ol.js"></script>
++    <script src="../libs/i18next/i18next.js"></script>
++    <script src="../libs/jstree/jstree.js"></script>
++    <script src="../build/potree/potree.js"></script>
++    <script src="../libs/plasio/js/laslaz.js"></script>
++
++    <div
++      id="viewer_1"
++      style="position: absolute; width: 100%; height: 100%; left: 0px; top: 0px"
++    >
++      <div id="fpContainer_1" class="floormap" onclick="actionIconClick()">
++        <i
++          title="fullscreen"
++          id="fp_fullscreen_1"
++          data='{"id": "viewer_1", "type": "fp_fullscreen"}'
++          class="material-icons fpFullScreen"
++          >fullscreen</i
++        >
++        <i
++          title="minimise"
++          id="fp_minimise_1"
++          data='{"id": "viewer_1", "type": "fp_fullscreen"}'
++          class="material-icons fpFullScreen"
++          style="display: none"
++          >fullscreen_exit</i
++        >
++        <canvas id="floormap_1"></canvas>
++      </div>
++      <div id="no_bim_1" class="noBIM">
++        <p>Data Not Available</p>
++      </div>
++      <div
++        id="bim_details_card_container_1"
++        class="bim-details-card"
++        onclick="actionIconClick()"
++      >
++        <i
++          data='{"id": "viewer_1", "type": "bim_card_close"}'
++          class="material-icons bim-card-close"
++          >clear</i
++        >
++        <div id="bim_details_card_1"></div>
++      </div>
++      <div
++        id="bim_legend_1"
++        class="bim-legend-container bim-legend"
++        onclick="actionIconClick()"
++      >
++        <li
++          id="bim_not_started"
++          data='{"id": "viewer_1", "type": "bim_legend"}'
++        >
++          <span class="not_started"></span> Not Started
++        </li>
++        <li
++          id="bim_in_progress"
++          data='{"id": "viewer_1", "type": "bim_legend"}'
++        >
++          <span class="in_progress"></span> In Progress
++        </li>
++        <li id="bim_complete" data='{"id": "viewer_1", "type": "bim_legend"}'>
++          <span class="complete"></span> Complete
++        </li>
++      </div>
++      <div
++        id="action_buttons_1"
++        onclick="actionIconClick()"
++        class="actionButtons"
++      >
++        <div class="dropup actionButtonsTest">
++          <input class="datepickerDigi" type="text" id="datepickerLeft" />
++        </div>
++        <div title="bim compare" class="dropup actionButtonsTest">
++          <img
++            id="bim_compare_view_1"
++            data='{"id": "viewer_1", "type":"bim-compare"}'
++            src="https://dtwin-viewers.s3.ap-south-1.amazonaws.com/icons/3d-bim1.png"
++            class="s3-icon"
++          />
++        </div>
++        <div class="dropup actionButtonsTest">
++          <i
++            title="timeline compare"
++            id="compare_view_1"
++            data='{"id": "viewer_1", "type": "compare"}'
++            class="material-icons icon-test"
++            >compare</i
++          >
++        </div>
++        <div class="dropup actionButtonsTest">
++          <i
++            title="point cloud"
++            id="3d_view_1"
++            data='{"id": "viewer_1", "type": "3d"}'
++            class="material-icons icon-test"
++            style="display: none"
++            >3d_rotation</i
++          >
++        </div>
++        <div class="dropup actionButtonsTest">
++          <i
++            title="show images"
++            id="cameras_on_1"
++            data='{"id": "viewer_1", "type": "cameras", "condition": "on"}'
++            class="material-icons icon-test"
++            style="display: none"
++            >photo_camera</i
++          >
++          <i
++            title="hide images"
++            id="cameras_off_1"
++            data='{"id": "viewer_1", "type": "cameras", "condition": "off"}'
++            class="material-icons icon-test"
++            style="display: none"
++            >no_photography</i
++          >
++        </div>
++
++        <div class="dropup actionButtonsTest">
++          <i
++            id="measure_top_1"
++            data='{"id": "viewer_1", "type": "measure"}'
++            title="measure"
++            data-toggle="dropdown"
++            class="material-icons icon-test"
++            >straighten</i
++          >
++          <ul id="measure_tool_1" class="dropdown-menu" style="margin: unset">
++            <i
++              title="point"
++              data='{"id": "viewer_1", "type": "point"}'
++              class="material-icons icon-test"
++              >gps_fixed</i
++            >
++            <i
++              title="distance"
++              data='{"id": "viewer_1", "type": "distance"}'
++              class="material-icons icon-test"
++              >timeline</i
++            >
++            <i
++              title="area"
++              data='{"id": "viewer_1", "type": "area"}'
++              class="material-icons icon-test"
++              >crop</i
++            >
++            <i
++              title="height"
++              data='{"id": "viewer_1", "type": "height"}'
++              class="material-icons icon-test"
++              >height</i
++            >
++            <i
++              title="clear"
++              data='{"id": "viewer_1", "type": "clear"}'
++              class="material-icons icon-test"
++              >clear</i
++            >
++            <i
++              title="save"
++              data='{"id": "viewer_1", "type": "save"}'
++              class="material-icons icon-test"
++              >save</i
++            >
++          </ul>
++        </div>
++      </div>
++    </div>
++    <div
++      id="viewer_2"
++      style="
++        position: absolute;
++        width: 50%;
++        height: 100%;
++        right: 0px;
++        top: 0px;
++        display: none;
++      "
++    >
++      <div id="fpContainer_2" class="floormap" onclick="actionIconClick()">
++        <i
++          title="fullscreen"
++          id="fp_fullscreen_2"
++          data='{"id": "viewer_2", "type": "fp_fullscreen"}'
++          class="material-icons fpFullScreen"
++          >fullscreen</i
++        >
++        <i
++          title="minimise"
++          id="fp_minimise_2"
++          data='{"id": "viewer_2", "type": "fp_fullscreen"}'
++          class="material-icons fpFullScreen"
++          style="display: none"
++          >fullscreen_exit</i
++        >
++        <canvas id="floormap_2"></canvas>
++      </div>
++      <div id="no_bim_2" class="noBIM">
++        <p>Data Not Available</p>
++      </div>
++
++      <div
++        id="bim_details_card_container_2"
++        class="bim-details-card"
++        onclick="actionIconClick()"
++      >
++        <i
++          data='{"id": "viewer_2", "type": "bim_card_close"}'
++          class="material-icons bim-card-close"
++          >clear</i
++        >
++        <div id="bim_details_card_2"></div>
++      </div>
++
++      <div
++        id="bim_legend_2"
++        class="bim-legend-container bim-legend"
++        onclick="actionIconClick()"
++      >
++        <li
++          title="not srated"
++          id="bim_not_started"
++          data='{"id": "viewer_2", "type": "bim_legend"}'
++        >
++          <span class="not_started"></span> Not Started
++        </li>
++        <li
++          title="in progress"
++          id="bim_in_progress"
++          data='{"id": "viewer_2", "type": "bim_legend"}'
++        >
++          <span class="in_progress"></span> In Progress
++        </li>
++        <li
++          title="completed"
++          id="bim_complete"
++          data='{"id": "viewer_2", "type": "bim_legend"}'
++        >
++          <span class="complete"></span> Complete
++        </li>
++      </div>
++      <div
++        id="action_buttons_2"
++        onclick="actionIconClick()"
++        class="actionButtons"
++      >
++        <div class="dropup actionButtonsTest">
++          <input class="datepickerDigi" type="text" id="datepickerRight" />
++        </div>
++        <div title="bim compare" class="dropup actionButtonsTest">
++          <img
++            id="bim_compare_view_2"
++            data='{"id": "viewer_2", "type" : "bim-compare"}'
++            src="https://dtwin-viewers.s3.ap-south-1.amazonaws.com/icons/3d-bim1.png"
++            class="s3-icon"
++          />
++        </div>
++        <div class="dropup actionButtonsTest">
++          <i
++            title="timeline compare"
++            id="compare_view_2"
++            data='{"id": "viewer_2", "type": "3d"}'
++            class="material-icons icon-test"
++            >compare</i
++          >
++        </div>
++        <div class="dropup actionButtonsTest">
++          <i
++            title="point cloud"
++            id="3d_view_2"
++            data='{"id": "viewer_2", "type": "3d"}'
++            class="material-icons icon-test"
++            style="display: none"
++            >3d_rotation</i
++          >
++        </div>
++
++        <div class="dropup actionButtonsTest">
++          <i
++            title="show images"
++            id="cameras_on_2"
++            data='{"id": "viewer_2", "type": "cameras", "condition": "on"}'
++            class="material-icons icon-test"
++            style="display: none"
++            >photo_camera</i
++          >
++          <i
++            title="hide images"
++            id="cameras_off_2"
++            data='{"id": "viewer_2", "type": "cameras", "condition": "off"}'
++            class="material-icons icon-test"
++            style="display: none"
++            >no_photography</i
++          >
++        </div>
++
++        <div class="dropup actionButtonsTest">
++          <i
++            id="measure_top_2"
++            data='{"id": "viewer_2", "type": "measure"}'
++            title="measure"
++            data-toggle="dropdown"
++            class="material-icons icon-test"
++            >straighten</i
++          >
++          <ul id="measure_tool_2" class="dropdown-menu" style="margin: unset">
++            <i
++              title="point"
++              data='{"id": "viewer_2", "type": "point"}'
++              class="material-icons icon-test"
++              >gps_fixed</i
++            >
++            <i
++              title="distance"
++              data='{"id": "viewer_2", "type": "distance"}'
++              class="material-icons icon-test"
++              >timeline</i
++            >
++            <i
++              title="area"
++              data='{"id": "viewer_2", "type": "area"}'
++              class="material-icons icon-test"
++              >crop</i
++            >
++            <i
++              title="height"
++              data='{"id": "viewer_2", "type": "height"}'
++              class="material-icons icon-test"
++              >height</i
++            >
++            <i
++              title="clear"
++              data='{"id": "viewer_2", "type": "clear"}'
++              class="material-icons icon-test"
++              >clear</i
++            >
++            <i
++              title="save"
++              data='{"id": "viewer_2", "type": "save"}'
++              class="material-icons icon-test"
++              >save</i
++            >
++          </ul>
++        </div>
++      </div>
++      <div class="closeBtn actionButtonsTest" onclick="actionIconClick()">
++        <i
++          title="close compare"
++          data='{"id": "viewer_2", "type": "compare-close"}'
++          class="material-icons icon-test"
++          >clear</i
++        >
++      </div>
++    </div>
++
++    <script type="module">
++      // http://localhost:4200/examples/tourWrapperAdv.html?project=16&snapshot1=12&snapshot2=11&isExterior=0&isFM=1&mode=compare_bim
++      // http://localhost:4200/examples/tourWrapperAdv.html?project=25&snapshot1=16&snapshot2=17&isExterior=1&isFM=0&mode=compare_bim
++
++      function getParameterByName(name, url = window.location.href) {
++        name = name.replace(/[\[\]]/g, "\\$&");
++        var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
++          results = regex.exec(url);
++        if (!results) return null;
++        if (!results[2]) return "";
++        return decodeURIComponent(results[2].replace(/\+/g, " "));
++      }
++
++      function doAPIcall(in_url, in_method, in_token) {
++        return new Promise((resolve, reject) => {
++          $.ajax({
++            url: in_url,
++            method: in_method,
++            headers: {
++              authorization: "Bearer " + in_token,
++            },
++
++            success: (rawData) => {
++              console.log(rawData);
++              resolve(rawData);
++            },
++            error: (e) => {
++              console.log(e);
++              resolve(null);
++            },
++          });
++        });
++      }
++      const mainProjectID = getParameterByName("project");
++      const structure_id = getParameterByName("structure");
++      const inTilesetID = getParameterByName("snapshot1");
++      const inTilesetID2 = getParameterByName("snapshot2");
++      // const isExterior = parseInt(getParameterByName('isExterior'));
++      // const isFloorMap = parseInt(getParameterByName('isFM'));
++      const mode = getParameterByName("mode");
++      const token = getParameterByName("token"); //'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiJVU1IzOTA4OTUiLCJmaXJzdE5hbWUiOiJLcmlzaG5hIFRlamEiLCJsYXN0TmFtZSI6IlRhbmdhdHVyaSIsImVtYWlsIjoia3RkYWlpY3RAZ21haWwuY29tIiwiY29udGFjdCI6eyJjb2RlIjoiKzkxIiwibnVtYmVyIjo5Njc2MzE2MzIzfSwiZG9iIjoiMTk4OS0wMi0xNlQwMDowMDowMC4wMDBaIiwidmVyaWZpZWQiOnRydWUsImNyZWF0ZWRBdCI6IjIwMjItMDMtMjJUMTI6MTY6MzAuODk0WiIsInVwZGF0ZWRBdCI6IjIwMjItMDMtMjJUMTI6MTc6NTMuMTIyWiIsIl9fdiI6MCwiZnVsbE5hbWUiOiJLcmlzaG5hIFRlamEgVGFuZ2F0dXJpIiwiYWdlIjozMywiaWF0IjoxNjUxNzY4MDExLCJleHAiOjE2NTE3NzE2MTF9.xJT4oa55tODe7KzK7YkYM62NrpgJfWzusbevVggL_Vg'
++      // const structure_id = 'STR772693' //getParameterByName('structure');
++      const inProjectID = structure_id;
++      const structure_id_details = await doAPIcall(
++        "https://api.dev.constructn.ai/api/v1/projects/" +
++          mainProjectID +
++          "/structures/" +
++          structure_id,
++        "GET",
++        token
++      );
++      console.log(
++        "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
++      );
++      // console.log(structure_id_details)
++
++      const isExterior = structure_id_details["result"]["isExterior"] ? 1 : 0;
++
++      const isFloorMap = structure_id_details["result"]["isExterior"] ? 0 : 1;
++
++      console.log("Exterior : ", isExterior);
++
++      const inputCamera = JSON.parse(getParameterByName("camera"));
++      console.log("Input Camera ", inputCamera);
++
++      const inputTag = JSON.parse(getParameterByName("tag"));
++      console.log("Input Tag", inputTag);
++
++      let isCompareMode = false;
++      let isMouseOnV1 = true;
++      let compareType = "potree";
++      let viewerMode = "image";
++      let syncPotreeEvent = false;
++      let syncForgeEvent = false;
++      let bimProgressData = {};
++      let bimProgressMode = false;
++      var tagToAddOnImageLoad = null;
++      let progress_walk_index = 0;
++      let progress_walk_mode = false;
++
++      let s3_bucket = "constructn-projects"; //'digitrack-projects'
++
++      import * as THREE from "../libs/three.js/build/three.module.js";
++      // initFirstPotree();
++      // window.compareMode = compareMode;
++      // window.loadSnapshot = loadSnapshot;
++      // window.closeCompareMode = closeCompareMode;
++      // window.addMeasure = addMeasure;
++      // window.removeMeasure = removeMeasure;
++      window.actionIconClick = actionIconClick;
++      window.locate = locate;
++      window.getInverse = getInverse;
++      window.select_group_bim = select_group_bim;
++      window.bimDefaultView = bimDefaultView;
++      window.remove_group_bim = remove_group_bim;
++      window.addTag = addTag;
++      window.start_progress_delta_walk = start_progress_delta_walk;
++      window.exit_progress_walk = exit_progress_walk;
++      window.update_progress_walk = update_progress_walk;
++
++      if (mode == "3d") {
++        initFirstPotree();
++      } else if (mode == "compare_3d") {
++        initFirstPotree();
++        compareMode("potree");
++      } else if (mode == "compare_bim") {
++        initFirstPotree();
++        compareMode("forge");
++      } else if (mode == "bim") {
++        viewerMode = "3d";
++        initForge(inProjectID, inTilesetID, "viewer_1", inputCamera);
++        // document.getElementById('fpContainer_2').style.display = 'none';
++      }
++
++      window.addEventListener("message", function (e) {
++        console.log("From Parent : ", e.data);
++        if (e.data.type == "getCamera") {
++          let cam = locate(viewer_1);
++          console.log("Sending Camera Details to Parent : ", cam);
++          window.top.postMessage(
++            { type: "camera", data: JSON.stringify(cam) },
++            "*"
++          );
++        } else if (e.data.type == "context") {
++          flyToContext(e.data.data);
++        } else if (e.data.type == "select-tag") {
++          let tagData = JSON.parse(e.data.data);
++          console.log(tagData);
++          flyToTagContext(tagData);
++        } else if (e.data.type == "bim-grouping") {
++          let data = e.data.data;
++          if (viewer_1.customtype == "forge") {
++            select_group_bim(data.guids, viewer_1, data.mode, data.condition);
++          } else if (compareMode && viewer_2.customtype == "forge") {
++            select_group_bim(data.guids, viewer_2, data.mode, data.condition);
++          }
++        } else if (e.data.type == "reset-bim-grouping") {
++          if (viewer_1.customtype == "forge") {
++            remove_group_bim(viewer_1, e.data.data.mode);
++          } else if (compareMode && viewer_2.customtype == "forge") {
++            remove_group_bim(viewer_2, e.data.data.mode);
++          }
++        }
++      });
++
++      function initFirstPotree() {
++        if (inTilesetID == "") {
++          document.getElementById("no_bim_1").style.display = "block";
++        } else {
++          window.viewer_1 = new Potree.Viewer(
++            document.getElementById("viewer_1")
++          );
++          viewer_1.setFOV(60);
++          viewer_1.setPointBudget(1 * 1000 * 1000);
++          document.title = "";
++          viewer_1.setEDLEnabled(false);
++          viewer_1.setBackground("gradient"); // ["skybox", "gradient", "black", "white"];
++          viewer_1.setDescription(``);
++          viewer_1.loadSettingsFromURL();
++          viewer_1.canvasId = "viewer_1";
++          viewer_1.customtype = "potree";
++
++          viewer_1.loadGUI(async () => {
++            viewer_1.setLanguage("en");
++            console.log("VIewer_1 Loaded");
++            viewer_1.fpContainerId = "fpContainer_1";
++            viewer_1.fpCanvasId = "floormap_1";
++            loadSnapshot(
++              viewer_1,
++              inProjectID,
++              inTilesetID,
++              false,
++              inputCamera
++            );
++            viewer_1.tileset = inTilesetID;
++            toggleVisibility("action_buttons_1", true);
++            addEventListeners();
++          });
++        }
++      }
++
++      function addEventListeners() {
++        document
++          .getElementById("viewer_1")
++          .addEventListener("mouseenter", () => {
++            isMouseOnV1 = true;
++          });
++        document
++          .getElementById("viewer_2")
++          .addEventListener("mouseenter", () => {
++            isMouseOnV1 = false;
++          });
++
++        document.addEventListener("imageLoad", (event) => {
++          console.log("imageLoad ", event.detail.viewer, event.detail.image);
++          viewer_1.scene.removeAllMeasurements();
++          if (isCompareMode && compareType == "potree") {
++            viewer_2.scene.removeAllMeasurements();
++          }
++          viewerMode = "image";
++          toggleVisibility("3d_view_1", true);
++          toggleVisibility("3d_view_2", true);
++
++          if (event.detail.viewer == "viewer_1") {
++            viewer_1.cur_loaded_image = event.detail.image.id;
++          } else {
++            viewer_2.cur_loaded_image = event.detail.image.id;
++          }
++
++          if (isCompareMode) {
++            if (compareType == "forge") {
++              setForgeControls("image");
++            } else {
++              maintainContext(event.detail.viewer, event.detail.image);
++            }
++          }
++          pointCloudView(true);
++
++          setTimeout(() => {
++            if (tagToAddOnImageLoad != null) {
++              console.log("Adding Tag");
++              console.log(tagToAddOnImageLoad["info"]);
++              addTag(
++                tagToAddOnImageLoad["info"],
++                tagToAddOnImageLoad["viewer"]
++              );
++              tagToAddOnImageLoad = null;
++            }
++          }, 100);
++        });
++
++        document.addEventListener("imageUnload", (event) => {
++          console.log("imageUnload ", event.detail.viewer);
++          toggleVisibility("3d_view_1", false);
++          toggleVisibility("3d_view_2", false);
++          viewer_1.scene.removeAllClipVolumes(); // To remove hovered image
++          viewer_1.scene.removeAllMeasurements();
++          viewer_1.cur_loaded_image = null;
++          if (isCompareMode) {
++            viewerMode = "3d";
++            if (isCompareMode && compareType == "potree") {
++              viewer_2.scene.removeAllMeasurements();
++            }
++            viewer_2.cur_loaded_image = null;
++            if (compareType == "forge") {
++              setForgeControls("orbit");
++            } else {
++              if (event.detail.viewer == "viewer_1") {
++                viewer_2.scene.orientedImages[0].release();
++              } else {
++                viewer_1.scene.orientedImages[0].release();
++              }
++              viewer_2.scene.removeAllClipVolumes(); // To remove hovered image
++            }
++            viewer_1.fitToScreen();
++            if (!isMouseOnV1) {
++              if (compareType == "potree") {
++                viewer_2.fitToScreen();
++              } else {
++                viewer_2.navigation.setRequestFitToView(true);
++              }
++            }
++            pointCloudView(false);
++          } else if (event.detail.viewer == "viewer_1") {
++            viewer_1.fitToScreen();
++            pointCloudView(false);
++            viewerMode = "3d";
++          }
++        });
++
++        let zoomHandler_1 = (e) => {
++          let fov_delta = e.wheelDelta < 0 ? -5 : 5;
++          let fov = viewer_1.getFOV() + fov_delta;
++          if (fov > 10 && fov < 100) {
++            viewer_1.setFOV(fov);
++          }
++          isCompareMode && syncViewers();
++        };
++
++        let zoomHandler_2 = (e) => {
++          let fov_delta = e.wheelDelta < 0 ? -5 : 5;
++          let fov = viewer_2.getFOV() + fov_delta;
++          if (fov > 10 && fov < 100) {
++            viewer_2.setFOV(fov);
++          }
++          isCompareMode && syncViewers();
++        };
++
++        document.addEventListener("panoLoad", (event) => {
++          console.log("panoLoad ", event.detail.viewer, event.detail.image);
++          viewerMode = "panorama";
++          viewer_1.renderArea.addEventListener("mousewheel", zoomHandler_1);
++          viewer_1.scene.removeAllMeasurements();
++          if (isCompareMode && compareType == "potree") {
++            viewer_2.renderArea.addEventListener("mousewheel", zoomHandler_2);
++            viewer_2.scene.removeAllMeasurements();
++          }
++          if (event.detail.viewer == "viewer_1") {
++            viewer_1.cur_loaded_image = event.detail.image.file
++              .split("/")
++              .pop();
++          } else {
++            viewer_2.cur_loaded_image = event.detail.image.file
++              .split("/")
++              .pop();
++          }
++          if (isCompareMode) {
++            if (compareType == "forge") {
++              setForgeControls("panorama");
++            } else {
++              maintainContext(event.detail.viewer, event.detail.image);
++            }
++          }
++          pointCloudView(true);
++
++          if (viewer_1.isFloorMap) {
++            toggleFloorMap(viewer_1, true);
++          }
++
++          if (isCompareMode && compareType == "potree" && viewer_2.isFloorMap) {
++            toggleFloorMap(viewer_2, true);
++          }
++
++          setTimeout(() => {
++            if (tagToAddOnImageLoad != null) {
++              console.log("Adding Tag");
++              console.log(tagToAddOnImageLoad["info"]);
++              addTag(
++                tagToAddOnImageLoad["info"],
++                tagToAddOnImageLoad["viewer"]
++              );
++              tagToAddOnImageLoad = null;
++            }
++          }, 100);
++        });
++
++        document.addEventListener("panoUnload", (event) => {
++          console.log("panoUnload ", event.detail.viewer);
++          viewer_1.cur_loaded_image = null;
++          viewer_1.scene.removeAllMeasurements();
++          viewer_1.renderArea.removeEventListener("mousewheel", zoomHandler_1);
++          if (isCompareMode) {
++            viewer_2.cur_loaded_image = null;
++            if (isCompareMode && compareType == "potree") {
++              viewer_2.renderArea.removeEventListener(
++                "mousewheel",
++                zoomHandler_2
++              );
++              viewer_2.scene.removeAllMeasurements();
++            }
++            viewerMode = "3d";
++            if (compareType == "forge") {
++              setForgeControls("orbit");
++            } else {
++              if (event.detail.viewer == "viewer_1") {
++                viewer_2.scene.images360[0].unfocus();
++              } else {
++                viewer_1.scene.images360[0].unfocus();
++              }
++            }
++            viewer_1.fitToScreen();
++            if (!isMouseOnV1) {
++              if (compareType == "potree") {
++                viewer_2.fitToScreen();
++              } else {
++                viewer_2.navigation.setRequestFitToView(true);
++              }
++            }
++            pointCloudView(false);
++
++            if (viewer_1.isFloorMap) {
++              toggleFloorMap(viewer_1, false);
++            }
++
++            if (compareType == "potree" && viewer_2.isFloorMap) {
++              toggleFloorMap(viewer_2, false);
++            }
++          } else if (event.detail.viewer == "viewer_1") {
++            viewer_1.fitToScreen();
++            pointCloudView(false);
++            if (viewer_1.isFloorMap) {
++              toggleFloorMap(viewer_1, false);
++            }
++            viewerMode = "3d";
++          }
++        });
++
++        // Keyboard Shortcuts
++
++        document.addEventListener("keydown", (event) => {
++          if (event.key === "Escape") {
++            // Exit in viewer 2 is already handled in contex maintanance
++            if (viewerMode == "image") {
++              viewer_1.controls.elExit.click();
++            }
++            // else if (viewerMode == 'panorama') {
++            //     viewer_1.scene.images360[0].unfocus();
++            // }
++          } else if (event.key === "ArrowUp") {
++            // up arrow
++            if (viewerMode == "image") {
++              viewer_1.controls.elUp.click();
++              if (isCompareMode && compareType == "potree") {
++                viewer_2.controls.elUp.click();
++              }
++            } else if (viewerMode == "panorama") {
++              if (event.ctrlKey) {
++                setPitch(viewer_1, 0.5);
++                if (isCompareMode && compareType == "potree") {
++                  setPitch(viewer_2, 0.5);
++                }
++              } else {
++                nextPanoImage(viewer_1);
++              }
++            }
++          } else if (event.key === "ArrowDown") {
++            // down arrow
++            if (viewerMode == "image") {
++              viewer_1.controls.elDown.click();
++              if (isCompareMode && compareType == "potree") {
++                viewer_2.controls.elDown.click();
++              }
++            } else if (viewerMode == "panorama") {
++              if (event.ctrlKey) {
++                setPitch(viewer_1, -0.5);
++                if (isCompareMode && compareType == "potree") {
++                  setPitch(viewer_2, -0.5);
++                }
++              }
++            }
++          } else if (event.key === "ArrowLeft") {
++            // left arrow
++            if (viewerMode == "image") {
++              viewer_1.controls.elLeft.click();
++              if (isCompareMode && compareType == "potree") {
++                viewer_2.controls.elLeft.click();
++              }
++            } else if (viewerMode == "panorama") {
++              setYaw(viewer_1, 0.5);
++              if (isCompareMode && compareType == "potree") {
++                setYaw(viewer_2, 0.5);
++              }
++            }
++          } else if (event.key === "ArrowRight") {
++            // right arrow
++            if (viewerMode == "image") {
++              viewer_1.controls.elRight.click();
++              if (isCompareMode && compareType == "potree") {
++                viewer_2.controls.elRight.click();
++              }
++            } else if (viewerMode == "panorama") {
++              setYaw(viewer_1, -0.5);
++              if (isCompareMode && compareType == "potree") {
++                setYaw(viewer_2, -0.5);
++              }
++            }
++          }
++        });
++
++        // document.addEventListener('mousedown', event => {
++        // 	sendSyncEvents = true;
++        // });
++        // document.addEventListener('mouseup', event => {
++        // 	sendSyncEvents = false;
++        // });
++
++        document.addEventListener("camerachange", (event) => {
++          syncPotreeEvent = true;
++        });
++      }
++
++      function pointCloudView(cond) {
++        viewer_1.setEDLEnabled(cond);
++        if (cond) {
++          viewer_1.setEDLOpacity(0);
++        } else {
++          viewer_1.setEDLOpacity(1);
++        }
++        if (isCompareMode && compareType == "potree") {
++          viewer_2.setEDLEnabled(cond);
++          if (cond) {
++            viewer_2.setEDLOpacity(0);
++          } else {
++            viewer_2.setEDLOpacity(1);
++          }
++        }
++      }
++
++      function maintainContext(viewerId, info) {
++        if (viewerMode == "image") {
++          let nearestImage = null;
++          let nearestImageDist = 10000;
++          if (viewerId == "viewer_1" && viewer_2.scene.orientedImages[0]) {
++            viewer_2.scene.orientedImages[0].images.forEach((image) => {
++              let curDist = image.position.distanceTo(info.position);
++              if (curDist < nearestImageDist) {
++                nearestImageDist = curDist;
++                nearestImage = image;
++              }
++            });
++            if (nearestImage) {
++              console.log(nearestImage.id);
++              viewer_2.scene.orientedImages[0].moveToImage(nearestImage, false);
++              viewer_2.cur_loaded_image = nearestImage.id;
++            }
++          } else if (viewer_1.scene.orientedImages[0]) {
++            viewer_1.scene.orientedImages[0].images.forEach((image) => {
++              let curDist = image.position.distanceTo(info.position);
++              if (curDist < nearestImageDist) {
++                nearestImageDist = curDist;
++                nearestImage = image;
++              }
++            });
++            if (nearestImage) {
++              console.log(nearestImage.id);
++              viewer_1.scene.orientedImages[0].moveToImage(nearestImage, false);
++              viewer_1.cur_loaded_image = nearestImage.id;
++            }
++          }
++        } else {
++          let nearestImage = null;
++          let nearestImageDist = 1000;
++          let inputPos = new THREE.Vector2().fromArray([
++            info.position[0],
++            info.position[1],
++          ]);
++          if (viewerId == "viewer_1") {
++            if (viewer_2.scene.images360[0]) {
++              viewer_2.scene.images360[0].images.forEach((pano) => {
++                let curPos = new THREE.Vector2().fromArray([
++                  pano.position[0],
++                  pano.position[1],
++                ]);
++                let curDist = curPos.distanceTo(inputPos);
++                if (curDist < nearestImageDist) {
++                  nearestImageDist = curDist;
++                  nearestImage = pano;
++                }
++              });
++              if (nearestImage) {
++                console.log(nearestImage.file);
++                viewer_2.scene.images360[0].focus(nearestImage, false);
++                viewer_2.cur_loaded_image = nearestImage.file.split("/").pop();
++              }
++            }
++          } else if (viewer_1.scene.images360[0]) {
++            viewer_1.scene.images360[0].images.forEach((pano) => {
++              let curPos = new THREE.Vector2().fromArray([
++                pano.position[0],
++                pano.position[1],
++              ]);
++              let curDist = curPos.distanceTo(inputPos);
++              if (curDist < nearestImageDist) {
++                nearestImageDist = curDist;
++                nearestImage = pano;
++              }
++            });
++            if (nearestImage) {
++              console.log(nearestImage.file);
++              viewer_1.scene.images360[0].focus(nearestImage, false);
++              viewer_1.cur_loaded_image = nearestImage.file.split("/").pop();
++            }
++          }
++        }
++      }
++
++      function getNearestImage(viewer, camInfo, mode) {
++        let nearestImage = null;
++        let nearestImageDist = 10000;
++        if (mode == "image") {
++          viewer.scene.orientedImages[0].images.forEach((image) => {
++            let curDist = image.position.distanceTo(camInfo.position);
++            if (curDist < nearestImageDist) {
++              nearestImageDist = curDist;
++              nearestImage = image;
++            }
++          });
++          if (nearestImage) {
++            console.log(nearestImage.id);
++            viewer.scene.orientedImages[0].moveToImage(nearestImage);
++          }
++        } else {
++          let inputPos = new THREE.Vector2().fromArray([
++            camInfo.position.x,
++            camInfo.position.y,
++          ]);
++          viewer.scene.images360[0].images.forEach((pano) => {
++            let curPos = new THREE.Vector2().fromArray([
++              pano.position[0],
++              pano.position[1],
++            ]);
++            let curDist = curPos.distanceTo(inputPos);
++            if (curDist < nearestImageDist) {
++              nearestImageDist = curDist;
++              nearestImage = pano;
++            }
++          });
++          if (nearestImage) {
++            console.log(nearestImage.file);
++            viewer.scene.images360[0].focus(nearestImage, true, camInfo);
++          }
++        }
++      }
++
++      function syncViewers() {
++        if (isCompareMode) {
++          if (viewerMode == "3d") {
++            if (isMouseOnV1) {
++              if (compareType == "potree") {
++                let v1Pos = viewer_1.scene.view.position.toArray();
++                viewer_2.scene.view.position.set(v1Pos[0], v1Pos[1], v1Pos[2]);
++                viewer_2.scene.view.lookAt(viewer_1.scene.view.getPivot());
++                viewer_2.setFOV(viewer_1.fov);
++              } else if (syncPotreeEvent) {
++                // Conditional syncing only for forge
++                viewer_2.navigation.setPosition(
++                  viewer_1.scene.view.position.clone()
++                );
++                viewer_2.navigation.setTarget(viewer_1.scene.view.getPivot());
++                viewer_2.navigation.setVerticalFov(viewer_1.fov, false);
++              }
++            } else {
++              if (compareType == "potree") {
++                let v2Pos = viewer_2.scene.view.position.toArray();
++                viewer_1.scene.view.position.set(v2Pos[0], v2Pos[1], v2Pos[2]);
++                viewer_1.scene.view.lookAt(viewer_2.scene.view.getPivot());
++                viewer_1.setFOV(viewer_2.fov);
++              } else if (syncForgeEvent) {
++                viewer_2.navigation.setCameraUpVector(
++                  new THREE.Vector3().fromArray([0, 0, 1])
++                );
++                const state = viewer_2.getState({ viewport: true }).viewport;
++                viewer_1.scene.view.position.set(
++                  state.eye[0],
++                  state.eye[1],
++                  state.eye[2]
++                );
++                viewer_1.scene.view.lookAt(
++                  new THREE.Vector3().fromArray(state.target)
++                );
++                viewer_1.setFOV(state.fieldOfView);
++                // viewer_2.navigation.setWorldUpVector(new THREE.Vector3().fromArray([0, 0, 1]), false);
++              }
++            }
++          } else if (viewerMode == "panorama" && compareType == "potree") {
++            if (isMouseOnV1) {
++              viewer_2.scene.view.pitch = viewer_1.scene.view.pitch;
++              viewer_2.scene.view.yaw = viewer_1.scene.view.yaw;
++              viewer_2.fov = viewer_1.fov;
++            } else {
++              viewer_1.scene.view.pitch = viewer_2.scene.view.pitch;
++              viewer_1.scene.view.yaw = viewer_2.scene.view.yaw;
++              viewer_1.fov = viewer_2.fov;
++            }
++          } else if (compareType == "forge" && syncPotreeEvent) {
++            // Do nothing if secondary viewer is potree
++            viewer_2.navigation.setPosition(
++              viewer_1.scene.view.position.clone()
++            );
++            viewer_2.navigation.setTarget(viewer_1.scene.view.getPivot());
++            viewer_2.navigation.setVerticalFov(viewer_1.fov, false);
++          }
++          syncPotreeEvent = false;
++          syncForgeEvent = false;
++        }
++      }
++
++      async function loadPointCloud(
++        viewer,
++        projectID,
++        tilesetID,
++        secondary = false,
++        inCamera
++      ) {
++        let pcMatrix = new THREE.Matrix4().set(
++          1,
++          0,
++          0,
++          0,
++          0,
++          1,
++          0,
++          0,
++          0,
++          0,
++          1,
++          0,
++          0,
++          0,
++          0,
++          1
++        );
++        let pcOffset = [0, 0, 0];
++        viewer["globalOffset"] = pcOffset;
++        const tm_json_raw = await fetch(
++          `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${projectID}/snapshots/${tilesetID}/pointcloud/tm.json`
++        );
++        if (tm_json_raw.status == 200) {
++          const tm_json = JSON.parse(await tm_json_raw.text());
++          if (tm_json.tm) {
++            pcMatrix = new THREE.Matrix4().fromArray(tm_json.tm).transpose();
++          }
++          if (tm_json.offset) {
++            pcOffset = tm_json.offset;
++          }
++          viewer["globalOffset"] = pcOffset;
++          if (inCamera) {
++            let pos = inCamera.position;
++            let tar = inCamera.target;
++            let offset = viewer.globalOffset;
++            inCamera.position = new THREE.Vector3(
++              pos[0] - offset[0],
++              pos[1] - offset[1],
++              pos[2] - offset[2]
++            );
++            inCamera.target = new THREE.Vector3(
++              tar[0] - offset[0],
++              tar[1] - offset[1],
++              tar[2] - offset[2]
++            );
++          }
++          console.log("PC TM Loaded", tm_json);
++        }
++
++        Potree.loadPointCloud(
++          `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${projectID}/snapshots/${tilesetID}/pointcloud/cloud.json`,
++          projectID + "_" + tilesetID,
++          (e) => {
++            let scene = viewer.scene;
++            let pointcloud = e.pointcloud;
++
++            let material = pointcloud.material;
++            material.size = 1;
++            material.pointSizeType = Potree.PointSizeType.FIXED;
++            material.shape = Potree.PointShape.SQUARE;
++            pointcloud.applyMatrix(pcMatrix);
++            const assetPosition = pointcloud.position.clone();
++            pointcloud.position.set(
++              assetPosition.x - pcOffset[0],
++              assetPosition.y - pcOffset[1],
++              assetPosition.z - pcOffset[2]
++            );
++            scene.addPointCloud(pointcloud);
++            viewer.fitToScreen();
++            console.log("Point Cloud Loaded");
++
++            let startWithImage = true;
++
++            if (inputTag && !inputTag.image) {
++              let startWithImage = false;
++              viewerMode = "3d";
++              flyToContext(inputTag.camera);
++            }
++
++            if (isExterior) {
++              console.log("Exterior Project");
++              loadDroneImages(
++                viewer,
++                projectID,
++                tilesetID,
++                { tm: pcMatrix, offset: pcOffset },
++                secondary,
++                inCamera,
++                startWithImage
++              );
++              if (viewer.canvasId == "viewer_1") {
++                document.getElementById("cameras_off_1").style.display =
++                  "inline-block";
++              } else {
++                document.getElementById("cameras_off_2").style.display =
++                  "inline-block";
++              }
++            } else {
++              console.log("Interior Project");
++              // loadPanoImages(viewer, projectID, tilesetID, {tm: pcMatrix, offset1: [232067.2387, 1936749.6433, 563], offset: pcOffset}, secondary);
++              loadPanoImages(
++                viewer,
++                projectID,
++                tilesetID,
++                { tm: new THREE.Matrix4(), offset: pcOffset },
++                secondary,
++                inCamera,
++                startWithImage
++              );
++            }
++          }
++        );
++      }
++
++      function loadDroneImages(
++        viewer,
++        projectID,
++        tilesetID,
++        tmatrix,
++        secondary,
++        inCamera,
++        showImage
++      ) {
++        const imageParamsPath = `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${projectID}/snapshots/${tilesetID}/images.json`;
++        const imagesPath = `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${projectID}/snapshots/${tilesetID}/images`;
++        Potree.OrientedImageLoader.load(
++          imageParamsPath,
++          imagesPath,
++          viewer,
++          tmatrix
++        ).then((images) => {
++          viewer.scene.addOrientedImages(images);
++          // setTimeout(() => {
++          if (showImage) {
++            if (secondary && viewerMode == "image") {
++              maintainContext(
++                "viewer_1",
++                viewer_1.scene.orientedImages[0].focused
++              );
++              pointCloudView(true);
++            } else if (!secondary) {
++              // setTimeout(() => {
++              if (inputTag) {
++                flyToTagContext(inputTag);
++              } else if (inCamera) {
++                if (Array.isArray(inCamera.position)) {
++                  inCamera.position = new THREE.Vector3().fromArray(
++                    inCamera.position
++                  );
++                  inCamera.target = new THREE.Vector3().fromArray(
++                    inCamera.target
++                  );
++                }
++                getNearestImage(viewer, inCamera, "image");
++              } else {
++                viewer.scene.orientedImages[0].moveToImage(
++                  viewer.scene.orientedImages[0].images[0]
++                );
++              }
++              // }, 2000);
++            }
++          }
++          // }, 2000);
++        });
++      }
++
++      function loadPanoImages(
++        viewer,
++        projectID,
++        tilesetID,
++        tmatrix,
++        secondary,
++        inCamera,
++        showImage
++      ) {
++        viewerMode = "panorama";
++        const imageParamsPath = `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${projectID}/snapshots/${tilesetID}/images.json`;
++        // const imageParamsPath = `http://localhost:1234/indoor_images_15_17_48_66.json`;
++        // const imagesPath = `https://localhost:1234`
++        const imagesPath = `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${projectID}/snapshots/${tilesetID}/images`;
++        Potree.Images360Loader.load(
++          imageParamsPath,
++          imagesPath,
++          viewer,
++          tmatrix
++        ).then((images) => {
++          viewer.scene.add360Images(images);
++          if (showImage) {
++            if (secondary && viewerMode == "panorama") {
++              maintainContext(
++                "viewer_1",
++                viewer_1.scene.images360[0].focusedImage
++              );
++              // pointCloudView(true);viewer_2.navigation.setCameraUpVector(new THREE.Vector3().fromArray([0, 0, 1]));
++            } else if (!secondary) {
++              if (inputTag) {
++                flyToTagContext(inputTag);
++              } else if (inCamera) {
++                getNearestImage(viewer, inCamera, "panorama");
++              } else {
++                viewer.scene.images360[0].focus(
++                  viewer.scene.images360[0].images[0]
++                );
++              }
++            }
++          }
++        });
++      }
++
++      function compareMode(type) {
++        let pid = inProjectID;
++        let tid = inTilesetID2;
++        if (isCompareMode) {
++          closeCompareMode();
++        }
++        compareType = type;
++        document.getElementById("viewer_1").style.width = "50%";
++        document.getElementById("viewer_2").style.display = "block";
++
++        isCompareMode = true;
++        if (type == "potree") {
++          initSecondPotree(pid, tid);
++        } else {
++          initForge(pid, inTilesetID, "viewer_2");
++          document.getElementById("fpContainer_2").style.display = "none";
++        }
++
++        if (viewer_1.isFloorMap) {
++          updateFPSize(viewer_1.floorMap);
++        }
++      }
++
++      function closeCompareMode() {
++        isCompareMode = false;
++        document.getElementById("viewer_1").style.width = "100%";
++        document.getElementById("viewer_2").style.display = "none";
++        if (compareType == "forge") {
++          viewer_2.finish();
++          viewer_2 = null;
++          Autodesk.Viewing.shutdown();
++        } else {
++          removeAssets(viewer_2);
++          viewer_2 = null;
++        }
++
++        if (viewer_1.isFloorMap) {
++          updateFPSize(viewer_1.floorMap);
++        }
++      }
++
++      function initSecondPotree(pid_2, tid_2) {
++        if (tid_2 == "") {
++          document.getElementById("no_bim_2").style.display = "block";
++          isCompareMode = false;
++        } else {
++          window.viewer_2 = new Potree.Viewer(
++            document.getElementById("viewer_2")
++          );
++          viewer_2.setFOV(60);
++          viewer_2.setPointBudget(1 * 1000 * 1000);
++          document.title = "";
++          viewer_2.setEDLEnabled(false);
++          viewer_2.setBackground("gradient"); // ["skybox", "gradient", "black", "white"];
++          viewer_2.setDescription(``);
++          viewer_2.loadSettingsFromURL();
++          viewer_2.canvasId = "viewer_2";
++          viewer_2.customtype = "potree";
++
++          viewer_2.loadGUI(async () => {
++            viewer_2.setLanguage("en");
++            console.log("Viewer_2 Loaded");
++            isCompareMode = true;
++            viewer_2.fpContainerId = "fpContainer_2";
++            viewer_2.fpCanvasId = "floormap_2";
++            loadSnapshot(viewer_2, pid_2, tid_2, true);
++            viewer_2.tileset = tid_2;
++            toggleVisibility("action_buttons_2", true);
++          });
++        }
++      }
++
++      function removeAssets(viewer) {
++        viewer.scene.scenePointCloud.remove(viewer.scene.pointclouds[0]);
++        viewer.scene.pointclouds = [];
++        if (viewer.scene.orientedImages.length) {
++          viewer.scene.orientedImages[0].release();
++          viewer.scene.orientedImages[0].images.forEach((image) => {
++            viewer.scene.scene.children[0].remove(image.mesh);
++            viewer.scene.scene.children[0].remove(image.line);
++          });
++          viewer.scene.scene.remove(viewer.scene.scene.children[0]);
++          viewer.scene.removeOrientedImages(viewer.scene.orientedImages[0]);
++        }
++
++        if (viewer.scene.images360.length) {
++          viewer.scene.images360[0].unfocus(false);
++          viewer.scene.images360[0].images.forEach((image) => {
++            viewer.scene.scene.children[0].remove(image.mesh);
++          });
++          viewer.scene.scene.children[0].remove(
++            viewer.scene.images360[0].sphere
++          );
++          viewer.scene.scene.remove(viewer.scene.scene.children[0]);
++          viewer.scene.remove360Images(viewer.scene.images360[0]);
++        }
++        if (viewer.isFloorMap) {
++          removeFloorMap(viewer);
++        }
++      }
++
++      function loadSnapshot(
++        viewer,
++        pid,
++        tid,
++        secondary = false,
++        inCamera = null
++      ) {
++        removeAssets(viewer);
++        loadPointCloud(viewer, pid, tid, secondary, inCamera);
++        isFloorMap &&
++          loadFloormap(
++            viewer.fpContainerId,
++            viewer.fpCanvasId,
++            viewer,
++            pid,
++            tid
++          );
++      }
++
++      function getAutodeskToken() {
++        return new Promise((resolve, reject) => {
++          $.ajax({
++            url: "https://developer.api.autodesk.com/authentication/v1/authenticate",
++            method: "POST",
++            headers: {
++              "Content-Type": "application/x-www-form-urlencoded",
++            },
++            data: {
++              client_id: "aJRMrmok5UAbsdsXjckJmSBmoNnYKLzM",
++              // client_id: 'iXWYm3FVGMhLYLssAQAwdMGMq5HsAwNb',
++              client_secret: "mSqemcEE53l4THBJ",
++              // client_Secret: 'hPvkyDrWToKUG8c3',
++              grant_type: "client_credentials",
++              scope: "data:read",
++            },
++            success: (rawData) => {
++              resolve(rawData);
++            },
++            error: (e) => {
++              resolve(null);
++            },
++          });
++        });
++      }
++
++      function pointerToRaycasterForge(domElement, camera, pointer) {
++        const pointerVector = new THREE.Vector3();
++        const pointerDir = new THREE.Vector3();
++        const ray = new THREE.Raycaster();
++        const rect = domElement.getBoundingClientRect();
++        const x = ((pointer.clientX - rect.left) / rect.width) * 2 - 1;
++        const y = -((pointer.clientY - rect.top) / rect.height) * 2 + 1;
++        if (camera.isPerspective) {
++          pointerVector.set(x, y, 0.5);
++          pointerVector.unproject(camera);
++          ray.set(
++            camera.position,
++            pointerVector.sub(camera.position).normalize()
++          );
++        } else {
++          pointerVector.set(x, y, -1);
++          pointerVector.unproject(camera);
++          pointerDir.set(0, 0, -1);
++          ray.set(
++            pointerVector,
++            pointerDir.transformDirection(camera.matrixWorld)
++          );
++        }
++        return ray;
++      }
++
++      function getAllDbIds(viewer) {
++        const { instanceTree } = viewer.model.getData();
++        const { dbIdToIndex } = instanceTree.nodeAccess;
++        return Object.keys(dbIdToIndex).map((dbId) => {
++          return parseInt(dbId);
++        });
++      }
++
++      function initForge(pid, tid, divId, inCamera = null) {
++        var options = {
++          env: "Local",
++          api: "derivativeV2", // for models uploaded to EMEA change this option to 'derivativeV2_EU'
++          getAccessToken: async function (onTokenReady) {
++            const res = await getAutodeskToken();
++            onTokenReady(res.access_token, res.expires_in);
++          },
++        };
++        Autodesk.Viewing.Initializer(options, function () {
++          var htmlDiv = document.getElementById(divId);
++
++          const config3d = {
++            extensions: ["Autodesk.ADN.Viewing.Extension.Color"],
++          };
++
++          if (
++            inProjectID == "161" ||
++            inProjectID == "165" ||
++            inProjectID == "166"
++          ) {
++            config3d["navToolsConfig"] = {
++              dollyScrollScale: 0.005,
++            };
++          } else if (inProjectID == "235") {
++            config3d["navToolsConfig"] = {
++              dollyScrollScale: 0.001,
++            };
++          }
++
++          let viewer = new Autodesk.Viewing.GuiViewer3D(htmlDiv, config3d);
++          window[divId] = viewer;
++          var startedCode = viewer.start();
++          viewer.canvasId = divId;
++          if (startedCode > 0) {
++            console.error("Failed to create a Viewer: WebGL not supported.");
++            return;
++          }
++          console.log("Initialization complete, loading a model next...");
++          // isCompareMode = true;
++
++          viewer.navigation.setWorldUpVector(
++            new THREE.Vector3().fromArray([0, 0, 1]),
++            false
++          );
++
++          viewer.navigation.setReverseZoomDirection(true);
++
++          localStorage.setItem(
++            "Autodesk.Viewing.Private.GuiViewer3D.SavedSettings.viewCube",
++            false
++          );
++          localStorage.setItem(
++            "Autodesk.Viewing.Private.GuiViewer3D.SavedSettings.groundShadow",
++            false
++          );
++
++          viewer.addEventListener(
++            Autodesk.Viewing.CAMERA_CHANGE_EVENT,
++            (event) => {
++              syncForgeEvent = true;
++            }
++          );
++
++          viewer.container.addEventListener("click", function (ev) {
++            const result = viewer.clientToWorld(ev.clientX, ev.clientY);
++            if (result) {
++              console.log("Click Point", result.point);
++            }
++          });
++
++          viewer.addEventListener(
++            Autodesk.Viewing.SELECTION_CHANGED_EVENT,
++            (event) => {
++              var currSelection = viewer.getSelection();
++              console.log("Selection: ");
++
++              if (currSelection.length && bimProgressData[viewer.canvasId]) {
++                let guid =
++                  bimProgressData[viewer.canvasId]["dbtoguid"][
++                    currSelection[0]
++                  ];
++                let progress =
++                  bimProgressData[viewer.canvasId]["progress"][guid];
++
++                console.log(
++                  "dbid: ",
++                  currSelection[0],
++                  "guid: ",
++                  guid,
++                  "progress: ",
++                  progress
++                );
++
++                // let card_container_id = divId == 'viewer_1' ? 'bim_details_card_container_1' : 'bim_details_card_container_2'
++                // let card_id = divId == 'viewer_1' ? 'bim_details_card_1' : 'bim_details_card_2'
++                // let card_container = document.getElementById(card_container_id);
++                // let card = document.getElementById(card_id);
++                // let card_details = '<table>'
++                // card_details += `<tr> <td>    </td> <td>    </td> </tr>`
++                // card_details += `<tr> <td> GUID </td> <td> ${guid} </td> </tr>`
++                // card_details += `<tr> <td> Progress </td> <td> ${progress} </td> </tr>`
++
++                // card_details += '</table>'
++                // card.innerHTML = card_details;
++                // card_container.style.display = 'block';
++                let bim_element_details = { guid: guid, progress: progress };
++                window.top.postMessage(
++                  {
++                    type: "bim-click",
++                    data: JSON.stringify(bim_element_details),
++                  },
++                  "*"
++                );
++                console.log("Sending ", bim_element_details);
++
++                // const pointer = event.pointers ? event.pointers[0] : event;
++                // const rayCaster = pointerToRaycasterForge(viewer.canvas, viewer.navigation.getCamera(), pointer);
++                // const forgeClickObject = viewer.model.rayIntersect(rayCaster, true, this.getAllDbIds(viewer));
++                // console.log('Click point')
++                // console.log(forgeClickObject)
++
++                // const result = viewer.clientToWorld(event.clientX, event.clientY);
++                // if (result) {
++                // 	console.log(result.point);
++                // }
++              } else {
++                window.top.postMessage(
++                  { type: "bim-click", data: JSON.stringify({}) },
++                  "*"
++                );
++                // closeBimDetailsCard(divId);
++              }
++            }
++          );
++
++          viewer.customtype = "forge";
++          loadBIM(viewer, pid, tid, inCamera);
++        });
++      }
++
++      function closeBimDetailsCard(viewer_id) {
++        let container_id =
++          viewer_id == "viewer_1"
++            ? "bim_details_card_container_1"
++            : "bim_details_card_container_2";
++        let card = document.getElementById(container_id);
++        card.style.display = "none";
++        viewer_id == "viewer_1"
++          ? viewer_1.clearSelection()
++          : viewer_2.clearSelection();
++      }
++
++      async function loadBIM(viewer, pid, tid, inCamera) {
++        // let path = `http://localhost:1234/0.svf`;
++        let path = `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${pid}/forge/model/0.svf`;
++        const modelOptions = { applyScaling: "m" };
++        modelOptions.globalOffset = { x: 0, y: 0, z: 0 };
++        let globalOff = [0, 0, 0];
++        viewer["globalOffset"] = globalOff;
++        viewer["properties_child"] = ["GLOBALID", "NAME"];
++        viewer["properties_head"] = ["IFC"];
++
++        const tm_json_raw = await fetch(
++          `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${pid}/forge/tm_forge.json`
++        );
++        if (tm_json_raw.status == 200) {
++          const tm_json = JSON.parse(await tm_json_raw.text());
++          if (tm_json.tm) {
++            modelOptions.placementTransform = new THREE.Matrix4()
++              .fromArray(tm_json.tm)
++              .transpose();
++            // modelOptions.placementTransform = new THREE.Matrix4().fromArray([0.216,1.022,-0.007,367033.477,-1.022,0.216,-0.001,2053135.281,-0.000,0.007,1.045,-57.5,0.000,0.000,0.000,1.000]).transpose()
++            console.log("BIM TM Loaded");
++          }
++
++          if (tm_json.offset) {
++            globalOff = tm_json.offset;
++            modelOptions.globalOffset = {
++              x: globalOff[0],
++              y: globalOff[1],
++              z: globalOff[2],
++            };
++          }
++
++          if (tm_json.properties_child) {
++            viewer["properties_child"] = tm_json.properties_child;
++          }
++
++          if (tm_json.properties_head) {
++            viewer["properties_head"] = tm_json.properties_head;
++          }
++
++          viewer["globalOffset"] = globalOff;
++          if (inCamera) {
++            let pos = inCamera.position;
++            let tar = inCamera.target;
++            let offset = viewer.globalOffset;
++            inCamera.position = new THREE.Vector3(
++              pos[0] - offset[0],
++              pos[1] - offset[1],
++              pos[2] - offset[2]
++            );
++            inCamera.target = new THREE.Vector3(
++              tar[0] - offset[0],
++              tar[1] - offset[1],
++              tar[2] - offset[2]
++            );
++          }
++        }
++
++        viewer.loadModel(
++          path,
++          modelOptions,
++          async (model) => {
++            if (inCamera) {
++              // Only Happens in 'bim' only mode
++              viewer.navigation.setPosition(inCamera.position);
++              viewer.navigation.setTarget(inCamera.target);
++            } else if (viewer.canvasId == "viewer_2") {
++              if (viewerMode != "3d") {
++                function checkFlag() {
++                  if (!viewer.getExtension("Autodesk.BimWalk")) {
++                    console.log("Loading BimWalk Extension ...");
++                    window.setTimeout(checkFlag, 1000);
++                  } else {
++                    setForgeControls(viewerMode);
++                  }
++                }
++                checkFlag();
++              }
++              viewer_2.navigation.setPosition(
++                viewer_1.scene.view.position.clone()
++              );
++              viewer_2.navigation.setTarget(viewer_1.scene.view.getPivot());
++              viewer_2.navigation.setVerticalFov(viewer_1.fov, false);
++            }
++
++            // Set Pivot Point
++
++            let fuzzy_box = viewer.model.getFuzzyBox();
++            let fuzzy_min = fuzzy_box["min"];
++            let fuzzy_max = fuzzy_box["max"];
++            let fuzzy_center = new THREE.Vector3(
++              (fuzzy_min["x"] + fuzzy_max["x"]) / 2,
++              (fuzzy_min["y"] + fuzzy_max["y"]) / 2,
++              (fuzzy_min["z"] + fuzzy_max["z"]) / 2
++            );
++            viewer.navigation.setPivotPoint(fuzzy_center);
++
++            // Generate GUID - DBID Mapping and progress view/
++
++            loadProgressView(viewer, pid, tid);
++          },
++          (e) => {
++            if (viewer.canvasId == "viewer_2") {
++              document.getElementById("no_bim_2").style.display = "block";
++            } else {
++              document.getElementById("no_bim_1").style.display = "block";
++            }
++          }
++        );
++      }
++
++      function loop(timestamp) {
++        syncViewers();
++        requestAnimationFrame(loop);
++        if (viewer_1.isFloorMap) {
++          updateUserLocation(viewer_1);
++        }
++        if (isCompareMode && compareType == "potree" && viewer_2.isFloorMap) {
++          updateUserLocation(viewer_2);
++        }
++      }
++
++      function setForgeControls(type) {
++        if (type == "orbit") {
++          viewer_2.navigation.setIsLocked(false);
++          if (viewer_2.getExtension("Autodesk.BimWalk")) {
++            viewer_2.getExtension("Autodesk.BimWalk").deactivate();
++          }
++        } else {
++          viewer_2.navigation.setLockSettings({
++            orbit: false,
++            pan: false,
++            zoom: false,
++            roll: false,
++            fov: true,
++          });
++          viewer_2.navigation.setIsLocked(true);
++
++          if (viewer_2.getExtension("Autodesk.BimWalk")) {
++            viewer_2.getExtension("Autodesk.BimWalk").activate();
++          }
++        }
++      }
++
++      function setPitch(viewer, delta) {
++        const startPitch = { p: viewer.scene.view.pitch };
++        const endPitch = { p: startPitch.p + delta };
++        let tween = new TWEEN.Tween(startPitch).to(endPitch, 500);
++        tween.easing(TWEEN.Easing.Quartic.Out);
++        tween.onUpdate(() => {
++          viewer.scene.view.pitch = startPitch.p;
++          syncPotreeEvent = true;
++        });
++        tween.onComplete(() => {
++          viewer.scene.view.pitch = endPitch.p;
++          syncPotreeEvent = true;
++        });
++        tween.start();
++      }
++
++      function setYaw(viewer, delta) {
++        const startYaw = { y: viewer.scene.view.yaw };
++        const endYaw = { y: startYaw.y + delta };
++        let tween = new TWEEN.Tween(startYaw).to(endYaw, 500);
++        tween.easing(TWEEN.Easing.Quartic.Out);
++        tween.onUpdate(() => {
++          viewer.scene.view.yaw = startYaw.y;
++          syncPotreeEvent = true;
++        });
++        tween.onComplete(() => {
++          viewer.scene.view.yaw = endYaw.y;
++          syncPotreeEvent = true;
++        });
++        tween.start();
++      }
++
++      function nextPanoImage(viewer) {
++        let cameraInstance = viewer.scene.cameraP;
++        const camDir = new THREE.Vector3();
++        cameraInstance.getWorldDirection(camDir);
++        camDir.normalize();
++        const camPos = cameraInstance.position;
++        const weightages = { angle: 0.5, distance: 0.5 };
++        let totalSum = 10000;
++        let curSum;
++        let selectedPanoImageId;
++        let cameraViewProjectionMatrix;
++        let imgPos;
++        let dist;
++        let angle;
++        let frustum;
++        const camToImgDir = new THREE.Vector3();
++        const maxDist = 10;
++        const panoImgs = viewer.scene.images360[0].images;
++
++        for (let i = 0; i < panoImgs.length; i++) {
++          if (panoImgs[i].file == viewer.scene.images360[0].focusedImage.file) {
++            continue;
++          }
++          imgPos = new THREE.Vector3().fromArray(panoImgs[i].position);
++          frustum = new THREE.Frustum();
++          cameraViewProjectionMatrix = new THREE.Matrix4();
++          cameraInstance.updateMatrixWorld(); // make sure the camera matrix is updated
++          // cameraInstance.matrixWorldInverse.getInverse(cameraInstance.matrixWorld);
++          cameraInstance.matrixWorldInverse
++            .copy(cameraInstance.matrixWorld)
++            .invert();
++          cameraViewProjectionMatrix.multiplyMatrices(
++            cameraInstance.projectionMatrix,
++            cameraInstance.matrixWorldInverse
++          );
++          frustum.setFromMatrix(cameraViewProjectionMatrix);
++
++          // // if (frustum.containsPoint(imgPos)) {
++          dist = imgPos.distanceTo(camPos);
++          if (dist < maxDist) {
++            camToImgDir.subVectors(imgPos, camPos).normalize();
++            angle = Math.abs(camToImgDir.angleTo(camDir));
++            // tslint:disable-next-line: no-string-literal
++            curSum =
++              weightages["angle"] * angle + weightages["distance"] * dist;
++            if (curSum < totalSum) {
++              selectedPanoImageId = i;
++              totalSum = curSum;
++            }
++          }
++          // // }
++
++          // dist = imgPos.distanceTo(camPos);
++          // if (dist < maxDist) {
++          //     camToImgDir.subVectors(imgPos, camPos).normalize();
++          //     angle = Math.abs(camToImgDir.angleTo(camDir));
++          //     // tslint:disable-next-line: no-string-literal
++          //     // curSum = (weightages['angle'] * angle) + (weightages['distance'] * dist);
++          //     if (angle < totalSum) {
++          //         selectedPanoImageId = i;
++          //         totalSum = angle;
++          //     }
++          // }
++        }
++        if (selectedPanoImageId != undefined) {
++          viewer.scene.images360[0].focus(panoImgs[selectedPanoImageId]);
++        } else {
++          console.warn("No Nearest 360 Images");
++        }
++      }
++
++      function loadFloormap(fpContainerId, fpCanvasId, viewer, pid, tid) {
++        let base_image = new Image();
++        base_image.src = `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${pid}/floormap/floormap.png`;
++        // return new Promise((resolve, reject) => {
++        let fpCanvas = document.getElementById(fpCanvasId);
++        let fpContainer = document.getElementById(fpContainerId);
++        let viewerDiv = document.getElementById(viewer.canvasId);
++        fpContainer.style.display = viewerMode == "3d" ? "none" : "block";
++
++        viewer.floorMap = {};
++        viewer.floorMap.canvas = fpCanvas;
++        viewer.floorMap.container = fpContainer;
++        viewer.floorMap.div = viewerDiv;
++        viewer.floorMap.coverage = mode.includes("compare") ? 0.25 : 0.15;
++
++        base_image.onload = async () => {
++          viewer.floorMap.image = base_image;
++          updateFPSize(viewer.floorMap);
++
++          let fpMarix = new THREE.Matrix4().set(
++            1,
++            0,
++            0,
++            0,
++            0,
++            1,
++            0,
++            0,
++            0,
++            0,
++            1,
++            0,
++            0,
++            0,
++            0,
++            1
++          );
++          let fpOffset = [0, 0, 0];
++          const tm_json_raw = await fetch(
++            `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${pid}/floormap/tm.json`
++          );
++          if (tm_json_raw.status == 200) {
++            const tm_json = JSON.parse(await tm_json_raw.text());
++            if (tm_json.tm) {
++              fpMarix = new THREE.Matrix4().fromArray(tm_json.tm).transpose();
++              console.log("FP TM Loaded");
++            }
++            viewer.floorMap.tm = fpMarix;
++
++            if (tm_json.offset) {
++              fpOffset = tm_json.offset;
++            }
++            viewer.floorMap.offset = fpOffset;
++          }
++
++          const indoor_images_raw = await fetch(
++            `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${pid}/snapshots/${tid}/images.json`
++          );
++          // const indoor_images_raw = await fetch(`http://localhost:1234/indoor_images_15_17_48_66.json`);
++          if (indoor_images_raw.status == 200) {
++            const indoor_images = JSON.parse(await indoor_images_raw.text());
++            console.log("Indoor Images Loaded");
++            loadIcons(
++              indoor_images,
++              fpMarix,
++              base_image,
++              fpCanvas,
++              fpContainer,
++              viewer.floorMap,
++              viewer.canvasId
++            );
++            addUserLocation(
++              "https://dtwin-viewers.s3.ap-south-1.amazonaws.com/icons/fp_user.png",
++              viewer
++            ); // Update Required
++            viewer.floorMap.images = indoor_images;
++          }
++          viewer.isFloorMap = true;
++        };
++        fpContainer.addEventListener("click", (e) => {
++          const clickData = JSON.parse(e.target.getAttribute("data"));
++          if (clickData.id == "viewer_1") {
++            viewer_1.scene.images360[0].images.forEach((pano) => {
++              if (pano.file.split("/").pop() == clickData.name) {
++                viewer_1.scene.images360[0].focus(pano);
++              }
++            });
++          } else if (clickData.id == "viewer_2") {
++            viewer_2.scene.images360[0].images.forEach((pano) => {
++              if (pano.file.split("/").pop() == clickData.name) {
++                viewer_2.scene.images360[0].focus(pano);
++              }
++            });
++          }
++          console.log(clickData.name);
++        });
++      }
++
++      function toggleFloorMap(viewer, cond) {
++        viewer.floorMap.container.style.display = cond ? "block" : "none";
++      }
++
++      function loadIcons(
++        inData,
++        tm,
++        fpImage,
++        fpCanvas,
++        fpContainer,
++        fpStoreData,
++        id
++      ) {
++        let iconSize = 0.01;
++        fpStoreData.icons = [];
++        Object.keys(inData).forEach((imageName) => {
++          const cur_image_pos = inData[imageName].position;
++          const pixelCoords = worldToimage(
++            [cur_image_pos[0], cur_image_pos[1], cur_image_pos[2]],
++            tm
++          );
++          const screenCoords = imageToScreen(pixelCoords, fpImage, fpCanvas);
++          let icon = document.createElement("span");
++          icon.setAttribute("class", "panoIcon");
++          icon.setAttribute(
++            "data",
++            JSON.stringify({ name: imageName, id: id })
++          );
++          icon.style.width = fpCanvas.width * iconSize + "px";
++          icon.style.height = fpCanvas.width * iconSize + "px";
++          icon.style.top = screenCoords[1] - 5 + "px";
++          icon.style.left = screenCoords[0] - 5 + "px";
++          fpContainer.appendChild(icon);
++          fpStoreData.icons.push(icon);
++        });
++      }
++
++      function addUserLocation(path, viewer) {
++        let base_image = new Image();
++        base_image.src = path;
++        return new Promise((resolve, reject) => {
++          base_image.onload = () => {
++            base_image.setAttribute("class", "userIcon");
++            viewer.floorMap.userIcon = base_image;
++            viewer.floorMap.container.appendChild(base_image);
++          };
++        });
++      }
++
++      function calAngle(cx, cy, ex, ey) {
++        var dy = ey - cy;
++        var dx = ex - cx;
++        var theta = Math.atan2(dy, dx); // range (-PI, PI]
++        theta *= 180 / Math.PI; // rads to degs, range (-180, 180]
++        if (theta < 0) theta = 360 + theta; // range [0, 360)
++        return theta - 90 + 180;
++        // return 90 - theta;
++      }
++
++      function updateUserLocation(viewer) {
++        let curView = viewer.scene.view;
++        const position = curView.position.toArray();
++        position[0] += viewer.floorMap.offset[0];
++        position[1] += viewer.floorMap.offset[1];
++        position[2] += viewer.floorMap.offset[2];
++        const pixelCoordsOffset = worldToimage(position, viewer.floorMap.tm);
++        const screenCoords = imageToScreen(
++          pixelCoordsOffset,
++          viewer.floorMap.image,
++          viewer.floorMap.canvas
++        );
++        viewer.floorMap.userIcon.style.left =
++          screenCoords[0] - viewer.floorMap.userIcon.width / 2 + 5 + "px";
++        viewer.floorMap.userIcon.style.top =
++          screenCoords[1] - viewer.floorMap.userIcon.height / 2 + 5 + "px";
++        const camTarget = new THREE.Vector3()
++          .addVectors(curView.position, curView.direction.multiplyScalar(1))
++          .toArray();
++        camTarget[0] += viewer.floorMap.offset[0];
++        camTarget[1] += viewer.floorMap.offset[1];
++        camTarget[2] += viewer.floorMap.offset[2];
++        const camTargetPixel = worldToimage(camTarget, viewer.floorMap.tm);
++        const angle = calAngle(
++          pixelCoordsOffset[0],
++          pixelCoordsOffset[1],
++          camTargetPixel[0],
++          camTargetPixel[1]
++        );
++        viewer.floorMap.userIcon.style.transform = "rotate(" + angle + "deg)";
++      }
++
++      function worldToimage(coords, intm) {
++        const a = new THREE.Vector4(coords[0], coords[1], coords[2], 1);
++        a.applyMatrix4(intm);
++        return [Math.ceil(a.x), Math.ceil(a.y)];
++      }
++
++      function imageToScreen(pix, image, canvas) {
++        const pxx = (pix[0] * canvas.width) / image.naturalWidth;
++        const pyy = (pix[1] * canvas.height) / image.naturalHeight;
++        return [pxx, pyy];
++      }
++
++      function resizeFP(image, fpCanvas, v, coverage) {
++        // let coverage = 0.5;
++        // if (isCompareMode) {
++        // coverage = 0.25;
++        // }
++        // let coverage =
++        if (image.naturalWidth > image.naturalHeight) {
++          fpCanvas.width = v.clientWidth * coverage;
++          fpCanvas.height =
++            fpCanvas.width * (image.naturalHeight / image.naturalWidth);
++        } else {
++          fpCanvas.height = coverage * v.clientWidth;
++          fpCanvas.width =
++            fpCanvas.height * (image.naturalWidth / image.naturalHeight);
++        }
++      }
++
++      function updateFPSize(fpData) {
++        resizeFP(fpData.image, fpData.canvas, fpData.div, fpData.coverage);
++        let context = fpData.canvas.getContext("2d");
++        context.drawImage(
++          fpData.image,
++          0,
++          0,
++          fpData.canvas.width,
++          fpData.canvas.height
++        );
++        if (fpData.icons) {
++          updateFpIcons(fpData);
++        }
++      }
++
++      function updateFpIcons(fpInfo) {
++        let iconSize = 0.02;
++        Object.keys(fpInfo.images).forEach((imageName, index) => {
++          const cur_image_pos = fpInfo.images[imageName].position;
++          const pixelCoords = worldToimage(cur_image_pos, fpInfo.tm);
++          const screenCoords = imageToScreen(
++            pixelCoords,
++            fpInfo.image,
++            fpInfo.canvas
++          );
++          let icon = fpInfo.icons[index];
++          icon.style.width = fpInfo.canvas.width * iconSize + "px";
++          icon.style.height = fpInfo.canvas.width * iconSize + "px";
++          icon.style.top = screenCoords[1] - 5 + "px";
++          icon.style.left = screenCoords[0] - 5 + "px";
++        });
++      }
++
++      function removeFloorMap(viewer) {
++        viewer.floorMap.icons.forEach((icon) => {
++          viewer.floorMap.container.removeChild(icon);
++        });
++        viewer.floorMap.icons = [];
++        viewer.floorMap.container.removeChild(viewer.floorMap.userIcon);
++        viewer.floorMap.userIcon = null;
++        viewer.floorMap.images = null;
++        let context = viewer.floorMap.canvas.getContext("2d");
++        context.clearRect(
++          0,
++          0,
++          viewer.floorMap.canvas.width,
++          viewer.floorMap.canvas.height
++        );
++        viewer.floorMap = {};
++        viewer.isFloorMap = false;
++      }
++
++      async function addMeasure(type, id) {
++        let viewer;
++        if (id == "viewer_1") {
++          viewer = viewer_1;
++          document.getElementById("measure_tool_1").style.display = "block";
++          document
++            .getElementById("measure_top_1")
++            .setAttribute("measure_tool", true);
++        } else {
++          viewer = viewer_2;
++          document.getElementById("measure_tool_2").style.display = "block";
++          document
++            .getElementById("measure_top_2")
++            .setAttribute("measure_tool", true);
++        }
++        if (type == "point") {
++          console.log("Adding Point Measure");
++
++          if (viewerMode == "3d") {
++            let measurement = viewer.measuringTool.startInsertion({
++              showDistances: false,
++              showAngles: false,
++              showCoordinates: true,
++              showArea: false,
++              closed: true,
++              maxMarkers: 1,
++              name: "Point",
++            });
++          } else {
++            let clickHandler = (event) => {
++              const raycaster = new THREE.Raycaster();
++              let pickedObject = undefined;
++
++              const rect = viewer.renderArea.getBoundingClientRect();
++              let pos = {
++                x: event.clientX - rect.left,
++                y: event.clientY - rect.top,
++              };
++
++              // const pos = this.getCanvasRelativePosition(event);
++              let pickPosition = { x: 0, y: 0 };
++              pickPosition.x = (pos.x / viewer.renderArea.clientWidth) * 2 - 1;
++              pickPosition.y =
++                (pos.y / viewer.renderArea.clientHeight) * -2 + 1; // note we flip Y
++
++              raycaster.setFromCamera(pickPosition, viewer.scene.cameraP);
++              let objs =
++                viewerMode == "image"
++                  ? viewer.scene.scene.children
++                  : [viewer.scene.scene.children[0].children[0]];
++              const intersectedObjects = raycaster.intersectObjects(objs, true);
++              if (intersectedObjects.length) {
++                let click_point =
++                  viewerMode == "image"
++                    ? intersectedObjects[2].point
++                    : intersectedObjects[0].point;
++                let measure = new Potree.Measure();
++                measure.showDistances = false;
++                measure.showCoordinates = true;
++                measure.maxMarkers = 1;
++                measure.type = "Point";
++                measure.name = "Point";
++                measure.addMarker(click_point);
++                viewer.scene.addMeasurement(measure);
++              }
++              viewer.renderArea.removeEventListener("click", clickHandler);
++            };
++            setTimeout(() => {
++              viewer.renderArea.addEventListener("click", clickHandler);
++            }, 1);
++          }
++        } else if (type == "distance") {
++          console.log("Adding Distance Measure");
++          let measurement = viewer.measuringTool.startInsertion({
++            showDistances: true,
++            showArea: false,
++            closed: false,
++            name: "Distance",
++          });
++        } else if (type == "area") {
++          console.log("Adding Area Measure");
++          let measurement = viewer.measuringTool.startInsertion({
++            showDistances: true,
++            showArea: true,
++            closed: true,
++            name: "Area",
++          });
++        } else if (type == "height") {
++          console.log("Adding Area Measure");
++          let measurement = viewer.measuringTool.startInsertion({
++            showDistances: false,
++            showHeight: true,
++            showArea: false,
++            closed: false,
++            maxMarkers: 2,
++            name: "Height",
++          });
++        } else if (type == "clear") {
++          viewer.scene.removeAllMeasurements();
++        } else if (type == "save") {
++          let date_time = new Date();
++          let screenShotPath = `${mainProjectID}/structures/${inProjectID}/snapshots/${
++            viewer.tileset
++          }/${date_time.getTime()}.png`;
++          let latest_measure = viewer.scene.measurements.slice(-1)[0];
++          let save_obj = {
++            type: latest_measure.name,
++            points: latest_measure.points.map((point) =>
++              point.position.toArray()
++            ),
++            image: viewer.cur_loaded_image,
++            tileset: viewer.tileset,
++            camera: locate(viewer),
++            screenShot: `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${screenShotPath}`,
++          };
++          console.log("Saving Annotation: ", save_obj);
++          window.top.postMessage(
++            { type: "save-tag", data: JSON.stringify(save_obj) },
++            "*"
++          );
++          takeScreenshot(screenShotPath, viewer);
++        }
++      }
++
++      function toggleVisibility(id, cond) {
++        let div = document.getElementById(id);
++        if (cond) {
++          div.style.display = "block";
++        } else {
++          div.style.display = "none";
++        }
++        updateIconsDisplay();
++      }
++
++      function toggleOrientedImages(id, cond) {
++        if (id == "viewer_1") {
++          viewer_1.scene.orientedImages[0].visible = cond;
++          document.getElementById("cameras_on_1").style.display = cond
++            ? "none"
++            : "inline-block";
++          document.getElementById("cameras_off_1").style.display = cond
++            ? "inline-block"
++            : "none";
++        } else {
++          viewer_2.scene.orientedImages[0].visible = cond;
++          document.getElementById("cameras_on_2").style.display = cond
++            ? "none"
++            : "inline-block";
++          document.getElementById("cameras_off_2").style.display = cond
++            ? "inline-block"
++            : "none";
++        }
++      }
++
++      function actionIconClick(icon) {
++        const inData = JSON.parse(event.target.getAttribute("data"));
++        if (inData) {
++          // parent.postMessage(`${inData.type} button clicked`, "*");
++          if (inData.type == "3d") {
++            if (inData.id == "viewer_1") {
++              viewer_1.controls.elExit.click();
++            } else {
++              viewer_2.controls.elExit.click();
++            }
++          } else if (inData.type == "cameras") {
++            if (inData.id == "viewer_1") {
++              inData.condition == "on"
++                ? toggleOrientedImages("viewer_1", true)
++                : toggleOrientedImages("viewer_1", false);
++            } else {
++              inData.condition == "on"
++                ? toggleOrientedImages("viewer_2", true)
++                : toggleOrientedImages("viewer_2", false);
++            }
++          } else if (inData.type == "compare") {
++            let cam = locate(viewer_1);
++            console.log("3D COMPARE");
++            window.location.href =
++              "https://internal.constructn.ai/tour1?project=" +
++              mainProjectID +
++              "&structure=" +
++              structure_id +
++              "&snapshot1=" +
++              inTilesetID +
++              "&snapshot2=" +
++              inTilesetID2 +
++              "&token=" +
++              token +
++              "&mode=compare_3d" +
++              "&camera=" +
++              JSON.stringify(cam);
++          } else if (inData.type == "bim-compare") {
++            let cam = locate(viewer_1);
++            console.log("BIM COMPARE");
++            window.location.href =
++              "https://internal.constructn.ai/tour1?project=" +
++              mainProjectID +
++              "&structure=" +
++              structure_id +
++              "&snapshot1=" +
++              inTilesetID +
++              "&snapshot2=" +
++              inTilesetID2 +
++              "&mode=compare_bim" +
++              "&camera=" +
++              JSON.stringify(cam) +
++              "&token=" +
++              token;
++          } else if (inData.type == "fp_fullscreen") {
++            if (inData.id == "viewer_1") {
++              if (event.target.id == "fp_fullscreen_1") {
++                document.getElementById("fp_fullscreen_1").style.display =
++                  "none";
++                document.getElementById("fp_minimise_1").style.display =
++                  "block";
++                viewer_1.floorMap.coverage = 0.5;
++                updateFPSize(viewer_1.floorMap);
++              } else {
++                document.getElementById("fp_fullscreen_1").style.display =
++                  "block";
++                document.getElementById("fp_minimise_1").style.display = "none";
++                viewer_1.floorMap.coverage = isCompareMode ? 0.25 : 0.15;
++                updateFPSize(viewer_1.floorMap);
++              }
++            } else if (inData.id == "viewer_2") {
++              if (event.target.id == "fp_fullscreen_2") {
++                document.getElementById("fp_fullscreen_2").style.display =
++                  "none";
++                document.getElementById("fp_minimise_2").style.display =
++                  "block";
++                viewer_2.floorMap.coverage = 0.5;
++                updateFPSize(viewer_2.floorMap);
++              } else {
++                document.getElementById("fp_fullscreen_2").style.display =
++                  "block";
++                document.getElementById("fp_minimise_2").style.display = "none";
++                viewer_2.floorMap.coverage = isCompareMode ? 0.25 : 0.15;
++                updateFPSize(viewer_2.floorMap);
++              }
++            }
++          } else if (inData.type == "compare-close") {
++            let cam = locate(viewer_1);
++            window.location.href =
++              "https://internal.constructn.ai/tour1?project=" +
++              mainProjectID +
++              "&structure=" +
++              structure_id +
++              "&snapshot1=" +
++              inTilesetID +
++              "&snapshot2=" +
++              inTilesetID2 +
++              "&mode=3d" +
++              "&camera=" +
++              JSON.stringify(cam) +
++              "&token=" +
++              token;
++          } else if (inData.type == "bim_legend") {
++            let visible = false;
++            if (event.target.style.opacity == 0.5) {
++              visible = true;
++              event.target.style.opacity = 1;
++            } else {
++              event.target.style.opacity = 0.5;
++            }
++
++            if (inData.id == "viewer_1") {
++              bimFilters(viewer_1, "progress", event.target.id, visible);
++            } else {
++              bimFilters(viewer_2, "progress", event.target.id, visible);
++            }
++          } else if (inData.type == "bim_card_close") {
++            // if (inData.id == 'viewer_1') {
++            // 	closeBimDetailsCard('viewer_1');
++            // } else if (inData.id == 'viewer_2') {
++            // 	closeBimDetailsCard('viewer_2');
++            // }
++          } else if (inData.type == "measure") {
++            if (inData.id == "viewer_1") {
++              if (event.target.getAttribute("measure_tool") == null) {
++                event.target.setAttribute("measure_tool", false);
++              }
++              if (event.target.getAttribute("measure_tool") == "true") {
++                document.getElementById("measure_tool_1").style.display =
++                  "none";
++                event.target.setAttribute("measure_tool", false);
++              } else {
++                document.getElementById("measure_tool_1").style.display =
++                  "block";
++                event.target.setAttribute("measure_tool", true);
++              }
++            } else {
++              if (event.target.getAttribute("measure_tool") == "true") {
++                document.getElementById("measure_tool_2").style.display =
++                  "none";
++                event.target.setAttribute("measure_tool", false);
++              } else {
++                document.getElementById("measure_tool_1").style.display =
++                  "block";
++                event.target.setAttribute("measure_tool", true);
++              }
++            }
++          } else {
++            // event.stopPropagation()
++            addMeasure(inData.type, inData.id);
++          }
++        }
++      }
++
++      function getAllLeafComponents(viewer, callback) {
++        var cbCount = 0; // count pending callbacks
++        var components = []; // store the results
++        var tree; // the instance tree
++
++        function getLeafComponentsRec(parent) {
++          cbCount++;
++          if (tree.getChildCount(parent) != 0) {
++            tree.enumNodeChildren(
++              parent,
++              function (children) {
++                getLeafComponentsRec(children);
++              },
++              false
++            );
++          } else {
++            components.push(parent);
++          }
++          if (--cbCount == 0) callback(components);
++        }
++        viewer.getObjectTree(function (objectTree) {
++          tree = objectTree;
++          var allLeafComponents = getLeafComponentsRec(tree.getRootId());
++        });
++      }
++
++      function getRecursiveGUID(viewer, dbIds) {
++        return new Promise((resolve, reject) => {
++          let guidMapping = {};
++          let guidTodbid = {};
++          let parentMapping = {};
++          let guidToName = {};
++          let dbIdToGuid = {};
++          let property_childs = viewer["properties_child"];
++          let property_head = viewer["properties_head"][0];
++
++          function getGUID(ids) {
++            let dbIdsProcessed = [];
++            viewer.model.getBulkProperties(ids, property_childs, (data) => {
++              data.map((elementDetails) => {
++                let id = elementDetails.properties.filter(
++                  (details) =>
++                    details.displayCategory == property_head &&
++                    details.displayName == property_childs[0]
++                )[0]["displayValue"];
++                let name = elementDetails.properties.filter(
++                  (details) =>
++                    details.displayCategory == property_head &&
++                    details.displayName == property_childs[1]
++                )[0]["displayValue"];
++                if (id) {
++                  guidMapping[elementDetails.dbId] = id;
++                  dbIdsProcessed.push(elementDetails.dbId);
++                  guidToName[id] = name;
++                } else {
++                  console.log("No IFC id for ", elementDetails);
++                }
++              });
++              // console.log('Got ' + dbIdsProcessed.length + ' guids ....')
++              // Get GUID from parent for remaining Ids
++              let remainingDbIds = ids.filter(
++                (lid) => !dbIdsProcessed.includes(lid)
++              );
++              if (remainingDbIds.length) {
++                // console.log('Getting Parents for ' + remainingDbIds.length + ' dbids ....')
++                viewer.model.getBulkProperties(
++                  remainingDbIds,
++                  ["parent"],
++                  (data) => {
++                    let parentsForRemaining = data.map((elementDetails) => {
++                      parentMapping[elementDetails.dbId] =
++                        elementDetails.properties[0].displayValue;
++                      return elementDetails.properties[0].displayValue;
++                    });
++                    getGUID(parentsForRemaining);
++                  }
++                );
++              } else {
++                function getGIdFromParent(id) {
++                  if (guidMapping[parentMapping[id]]) {
++                    return guidMapping[parentMapping[id]];
++                  } else {
++                    return getGIdFromParent(parentMapping[id]);
++                  }
++                }
++
++                dbIds.map((dbid) => {
++                  let gid = guidMapping[dbid];
++                  if (gid) {
++                    if (guidTodbid[gid]) {
++                      guidTodbid[gid].push(dbid);
++                    } else {
++                      guidTodbid[gid] = [dbid];
++                    }
++                    dbIdToGuid[dbid] = gid;
++                  } else {
++                    gid = getGIdFromParent(dbid);
++                    if (guidTodbid[gid]) {
++                      guidTodbid[gid].push(dbid);
++                    } else {
++                      guidTodbid[gid] = [dbid];
++                    }
++                    dbIdToGuid[dbid] = gid;
++                  }
++                });
++
++                // console.log(guidTodbid)
++                console.log(guidToName);
++                bimProgressData[viewer.canvasId] = resolve({
++                  guidMapping: guidTodbid,
++                  dbIdToGuid: dbIdToGuid,
++                });
++              }
++            });
++          }
++
++          console.log("Got " + dbIds.length + " input ids");
++          getGUID(dbIds);
++        });
++      }
++
++      function getguidTodbidMapping(viewer) {
++        return new Promise((resolve, reject) => {
++          getAllLeafComponents(viewer, async (leafIds) => {
++            let guidDetails = await getRecursiveGUID(viewer, leafIds);
++            resolve(guidDetails);
++          });
++        });
++      }
++
++      async function bimProgressView(viewer) {
++        if (
++          inProjectID == "161" ||
++          inProjectID == "165" ||
++          inProjectID == "166"
++        ) {
++          viewer.hideAll();
++          viewer.show(bimProgressData[viewer.canvasId]["green"]);
++          viewer.show(bimProgressData[viewer.canvasId]["blue"]);
++        }
++
++        viewer.setColorMaterial(
++          bimProgressData[viewer.canvasId]["red"],
++          [1, 0, 0, 0.5],
++          "red"
++        );
++        viewer.setColorMaterial(
++          bimProgressData[viewer.canvasId]["green"],
++          [0.5, 0.88, 0.22, 0.5],
++          "green"
++        );
++        viewer.setColorMaterial(
++          bimProgressData[viewer.canvasId]["blue"],
++          [0.95, 0.6, 0.22, 0.5],
++          "blue"
++        );
++
++        // viewer.setColorMaterial(bimProgressData[viewer.canvasId]['red'], 0xFF0000, 'red')
++        // viewer.setColorMaterial(bimProgressData[viewer.canvasId]['green'], 0x71E03A, 'green')
++        // viewer.setColorMaterial(bimProgressData[viewer.canvasId]['blue'], 0xF39B3A, 'blue')
++
++        // viewer.setLightPreset(4)
++        viewer.setQualityLevel(false, false);
++      }
++
++      function bimFilters(viewer, filterType, filterName, visible) {
++        if (filterType == "progress") {
++          if (filterName == "bim_not_started") {
++            visible
++              ? viewer.show(bimProgressData[viewer.canvasId]["red"])
++              : viewer.hide(bimProgressData[viewer.canvasId]["red"]);
++          } else if (filterName == "bim_complete") {
++            visible
++              ? viewer.show(bimProgressData[viewer.canvasId]["green"])
++              : viewer.hide(bimProgressData[viewer.canvasId]["green"]);
++          } else if (filterName == "bim_in_progress") {
++            visible
++              ? viewer.show(bimProgressData[viewer.canvasId]["blue"])
++              : viewer.hide(bimProgressData[viewer.canvasId]["blue"]);
++          }
++        }
++      }
++
++      function bimDefaultView(viewer) {
++        if (
++          inProjectID == "161" ||
++          inProjectID == "165" ||
++          inProjectID == "166"
++        ) {
++          viewer.showAll();
++        }
++        var instanceTree = viewer.model.getData().instanceTree;
++
++        var allDbIdsStr = Object.keys(instanceTree.nodeAccess.dbIdToIndex);
++
++        let dbIds = allDbIdsStr.map(function (id) {
++          return parseInt(id);
++        });
++        viewer.restoreColorMaterial(dbIds);
++        // viewer.setLightPreset(1)
++        viewer.setQualityLevel(true, true);
++      }
++
++      function addProgressButton(viewer) {
++        let group = new Autodesk.Viewing.UI.ControlGroup("BimProgress");
++        viewer.toolbar.addControl(group);
++
++        // Add a new button to the toolbar group
++        let button = new Autodesk.Viewing.UI.Button("progress");
++        // instead of using bootstrap classes e.g.
++        // button.icon.classList.add("fas", "fa-arrows-alt");
++        // you can do this
++        let iconPath =
++          "https://dtwin-viewers.s3.ap-south-1.amazonaws.com/icons/progress.png";
++        button.icon.style = `background-image: url(${iconPath}); background-size: 24px 24px;`;
++
++        button.setToolTip("Progress View");
++
++        button.onClick = function (e) {
++          toggleBimProgressView(viewer);
++
++          // button.icon.classList.add('adsk-viewing-viewer', 'dark-theme', 'adsk-button.active', 'adsk-button')
++          // button.icon.classList.add("fas", "fa-arrows-alt");
++        };
++
++        group.addControl(button);
++
++        toggleBimProgressView(viewer);
++
++        let elems = document.querySelectorAll("[id=bim_not_started]");
++
++        if (viewer.canvasId == "viewer_1") {
++          elems[0].click();
++        } else {
++          elems[1].click();
++        }
++      }
++
++      function toggleBimProgressView(viewer) {
++        console.log("Go to Progress View");
++        bimProgressMode ? bimDefaultView(viewer) : bimProgressView(viewer);
++        if (viewer.canvasId == "viewer_1") {
++          bimProgressMode
++            ? (document.getElementById("bim_legend_1").style.display = "none")
++            : (document.getElementById("bim_legend_1").style.display = "block");
++        } else {
++          bimProgressMode
++            ? (document.getElementById("bim_legend_2").style.display = "none")
++            : (document.getElementById("bim_legend_2").style.display = "block");
++        }
++        bimProgressMode = !bimProgressMode;
++      }
++
++      async function loadProgressView(viewer, projectID, tilesetID) {
++        const progress_data_raw = await fetch(
++          `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${projectID}/snapshots/${tilesetID}/bim_progress.json`
++        );
++        if (progress_data_raw.status == 200) {
++          let guidDetails = await getguidTodbidMapping(viewer);
++          let guidMapping = guidDetails.guidMapping;
++          let guids = Object.keys(guidDetails.guidMapping);
++
++          bimProgressData[viewer.canvasId] = {
++            mapping: guidDetails.guidMapping,
++            dbtoguid: guidDetails.dbIdToGuid,
++            guids: guids,
++          };
++
++          console.log("GUID - DBID mapping done");
++          const progress_data = JSON.parse(await progress_data_raw.text());
++          console.log("BIM progress json loaded");
++
++          bimProgressData[viewer.canvasId]["progress"] = progress_data;
++
++          // let guids = bimProgressData[viewer.canvasId]['guids']
++          // let guidMapping = bimProgressData[viewer.canvasId]['mapping']
++
++          let redArr = guids.filter((key) => progress_data[key] == 0);
++          let greenArr = guids.filter((key) => progress_data[key] == 100);
++          let blueArr = guids.filter(
++            (key) => !redArr.includes(key) && !greenArr.includes(key)
++          );
++          let redDbArr = [];
++          let greenDbArr = [];
++          let blueDbArr = [];
++          if (
++            inProjectID != "161" &&
++            inProjectID != "165" &&
++            inProjectID != "166"
++          ) {
++            redArr.map((id) => (redDbArr = redDbArr.concat(guidMapping[id])));
++          }
++          blueArr.map((id) => (blueDbArr = blueDbArr.concat(guidMapping[id])));
++          greenArr.map(
++            (id) => (greenDbArr = greenDbArr.concat(guidMapping[id]))
++          );
++
++          bimProgressData[viewer.canvasId]["red"] = redDbArr;
++          bimProgressData[viewer.canvasId]["green"] = greenDbArr;
++          bimProgressData[viewer.canvasId]["blue"] = blueDbArr;
++
++          console.log("###############################");
++          console.log(redArr);
++
++          addProgressButton(viewer);
++
++          loadProgressWalk(viewer, projectID, tilesetID);
++        }
++      }
++
++      function select_group_bim(in_guids, viewer, mode, in_field) {
++        let dbArr = [];
++        let guidMapping = bimProgressData[viewer.canvasId]["mapping"];
++        in_guids.map((id) => (dbArr = dbArr.concat(guidMapping[id])));
++
++        if (mode == "material") {
++          bimDefaultView(viewer);
++          viewer.setColorMaterial(dbArr, in_field, "temp_mat");
++        } else if (mode == "visibility") {
++          in_field ? viewer.show(dbArr) : viewer.hide(dbArr);
++        }
++      }
++
++      function remove_group_bim(viewer, mode) {
++        if (mode == "material") {
++          bimDefaultView(viewer);
++        } else if (mode == "visibility") {
++          viewer.showAll();
++        }
++      }
++
++      function locate(viewer) {
++        let camObject;
++        if (viewer.customtype == "potree") {
++          let pos = viewer.scene.view.position.toArray();
++          let tar = viewer.scene.view.getPivot().toArray();
++          let offset = viewer.globalOffset;
++          camObject = {
++            position: [
++              pos[0] + offset[0],
++              pos[1] + offset[1],
++              pos[2] + offset[2],
++            ],
++            target: [
++              tar[0] + offset[0],
++              tar[1] + offset[1],
++              tar[2] + offset[2],
++            ],
++            pitch: viewer.scene.view.pitch,
++            yaw: viewer.scene.view.yaw,
++          };
++        } else if (viewer.customtype == "forge") {
++          const state = viewer.getState({ viewport: true }).viewport;
++          let offset = viewer.globalOffset;
++          camObject = {
++            position: [
++              state.eye[0] + offset[0],
++              state.eye[1] + offset[1],
++              state.eye[2] + offset[2],
++            ],
++            target: [
++              state.target[0] + offset[0],
++              state.target[1] + offset[1],
++              state.target[2] + offset[2],
++            ],
++          };
++        }
++        console.log("Camera : ", camObject);
++        return camObject;
++      }
++
++      function getInverse(org_mat) {
++        var m4 = new THREE.Matrix4();
++        m4.getInverse(org_mat);
++        m4.transpose();
++        return m4.toArray();
++      }
++
++      function flyToContext(info) {
++        let viewer = viewer_1;
++        let offset = viewer.globalOffset;
++        let inCamera_withOffset = {
++          position: new THREE.Vector3().fromArray([
++            info.position[0] - offset[0],
++            info.position[1] - offset[1],
++            info.position[2] - offset[2],
++          ]),
++          target: new THREE.Vector3().fromArray([
++            info.target[0] - offset[0],
++            info.target[1] - offset[1],
++            info.target[2] - offset[2],
++          ]),
++          pitch: info.pitch ? info.pitch : null,
++          yaw: info.yaw ? info.yaw : null,
++        };
++        let inCamera = {
++          position: new THREE.Vector3().fromArray([
++            info.position[0],
++            info.position[1],
++            info.position[2],
++          ]),
++          target: new THREE.Vector3().fromArray([
++            info.target[0],
++            info.target[1],
++            info.target[2],
++          ]),
++        };
++        if (viewerMode == "image") {
++          getNearestImage(viewer, inCamera_withOffset, "image");
++        } else if (viewerMode == "panorama") {
++          getNearestImage(viewer, inCamera_withOffset, "panorama");
++        } else {
++          if (viewer.customtype == "potree") {
++            viewer.scene.view.setView(
++              inCamera_withOffset.position,
++              inCamera_withOffset.target
++            );
++          } else {
++            viewer.navigation.setPosition(inCamera_withOffset.position);
++            viewer.navigation.setTarget(inCamera_withOffset.target);
++          }
++          if (isCompareMode) {
++            isMouseOnV1 = true;
++            syncViewers();
++          }
++        }
++      }
++
++      function flyToImage(viewer, imageName, inCamera) {
++        if (viewerMode == "panorama") {
++          viewer.scene.images360[0].images.forEach((image) => {
++            if (image.file.split("/").pop() == imageName) {
++              viewer.scene.images360[0].focus(image, true, inCamera);
++            }
++          });
++        } else {
++          viewer.scene.orientedImages[0].images.forEach((image) => {
++            if (image.id == imageName) {
++              viewer.scene.orientedImages[0].moveToImage(image);
++            }
++          });
++        }
++      }
++
++      function flyToTagContext(info) {
++        let offset = viewer_1.globalOffset;
++        let inCamera_withOffset = {
++          position: new THREE.Vector3().fromArray([
++            info.camera.position[0] - offset[0],
++            info.camera.position[1] - offset[1],
++            info.camera.position[2] - offset[2],
++          ]),
++          target: new THREE.Vector3().fromArray([
++            info.camera.target[0] - offset[0],
++            info.camera.target[1] - offset[1],
++            info.camera.target[2] - offset[2],
++          ]),
++          pitch: info.camera.pitch ? info.camera.pitch : null,
++          yaw: info.camera.yaw ? info.camera.yaw : null,
++        };
++
++        // if (info.image) {
++        // 	flyToImage_AddTag(viewer_1, info.image, inCamera_withOffset, info)
++        // 	if (isCompareMode) {
++        // 		flyToImage_AddTag(viewer_2, info.image, inCamera_withOffset, info)
++        // 	}
++        // } else {
++        // 	console.log('No Tag Support in 3d')
++        // }
++        if (info.image) {
++          if (viewer_1.tileset == info.tileset) {
++            isMouseOnV1 = true;
++
++            tagToAddOnImageLoad = {
++              info: info,
++              viewer: viewer_1,
++            };
++
++            flyToImage(viewer_1, info.image, inCamera_withOffset);
++            // addTag(info, viewer_1)
++            isMouseOnV1 = true;
++          } else if (isCompareMode && viewer_2.tileset == info.tileset) {
++            isMouseOnV1 = false;
++            // addTag(info, viewer_2)
++            tagToAddOnImageLoad = {
++              info: info,
++              viewer: viewer_2,
++            };
++            flyToImage(viewer_2, info.image, inCamera_withOffset);
++            isMouseOnV1 = false;
++          } else {
++            window.location.href =
++              "https://internal.constructn.ai/tour1?project=" +
++              mainProjectID +
++              "&structure=" +
++              structure_id +
++              "&snapshot1=" +
++              info.tileset +
++              "&snapshot2=" +
++              inTilesetID2 +
++              "&mode=" +
++              mode +
++              "&tag=" +
++              JSON.stringify(info) +
++              "&token=" +
++              token;
++          }
++        } else if (isExterior) {
++          console.log("Load 3d tags");
++          // viewer_1.controls.elExit.click();
++          if (viewer_1.cur_loaded_image) {
++            viewer_1.controls.elExit.click();
++          }
++          // if (isCompareMode) {
++          // 	viewer_2.scene.orientedImages[0].release()
++          // }
++
++          setTimeout(() => {
++            if (viewer_1.tileset == info.tileset) {
++              isMouseOnV1 = true;
++              flyToContext(info.camera);
++              addTag(info, viewer_1);
++              isMouseOnV1 = true;
++            } else if (isCompareMode && viewer_2.tileset == info.tileset) {
++              isMouseOnV1 = false;
++              flyToContext(info.camera);
++              addTag(info, viewer_2);
++              isMouseOnV1 = false;
++            } else {
++              window.location.href =
++                "https://internal.constructn.ai/tour1?project=" +
++                mainProjectID +
++                "&structure=" +
++                structure_id +
++                "&snapshot1=" +
++                info.tileset +
++                "&snapshot2=" +
++                inTilesetID2 +
++                "&mode=" +
++                mode +
++                "&tag=" +
++                JSON.stringify(info) +
++                "&token=" +
++                token;
++            }
++          }, 1000);
++        }
++
++        // if (viewerMode == 'image') {
++        // 	getNearestImage(viewer_1,inCamera_withOffset, 'image')
++        // } else if (viewerMode == 'panorama') {
++        // 	getNearestImage(viewer_1,inCamera_withOffset, 'panorama')
++        // } else {
++        // 	if (viewer_1.customtype == 'potree') {
++        // 		viewer.scene.view.setView(inCamera_withOffset.position, inCamera_withOffset.target)
++        // 	} else {
++        // 		viewer_1.navigation.setPosition(inCamera_withOffset.position);
++        // 		viewer_1.navigation.setTarget(inCamera_withOffset.target);
++        // 	}
++        // 	if (isCompareMode) {
++        // 		isMouseOnV1 = true
++        // 		syncViewers();
++        // 	}
++        // }
++      }
++
++      function addTag(inData, viewer) {
++        if (inData.type == "Point") {
++          let measure = new Potree.Measure();
++          measure.showDistances = false;
++          measure.showCoordinates = true;
++          measure.maxMarkers = 1;
++          measure.addMarker(new THREE.Vector3().fromArray(inData.points[0]));
++          viewer.scene.addMeasurement(measure);
++        } else if (inData.type == "Distance") {
++          let measure = new Potree.Measure();
++          measure.closed = false;
++          inData.points.forEach((point) => {
++            measure.addMarker(new THREE.Vector3().fromArray(point));
++          });
++          viewer.scene.addMeasurement(measure);
++        } else if (inData.type == "Area") {
++          let measure = new Potree.Measure();
++          measure.name = "Area";
++          measure.closed = true;
++          measure.showArea = true;
++          inData.points.forEach((point) => {
++            measure.addMarker(new THREE.Vector3().fromArray(point));
++          });
++          viewer.scene.addMeasurement(measure);
++        } else if (inData.type == "Height") {
++          let measure = new Potree.Measure();
++          measure.name = "Tree Height";
++          measure.closed = false;
++          measure.showDistances = false;
++          measure.showHeight = true;
++          inData.points.forEach((point) => {
++            measure.addMarker(new THREE.Vector3().fromArray(point));
++          });
++          viewer.scene.addMeasurement(measure);
++        }
++      }
++
++      requestAnimationFrame(loop);
++
++      var datesIdMapRight = {};
++      var datesIdMapLeft = {};
++      getDate("#datepickerLeft", datesIdMapLeft, 0, 1);
++      getDate("#datepickerRight", datesIdMapRight, 1, 2);
++
++      function getDate(dateObject, datesMap, defaultValue, snapshotNo) {
++        return new Promise((resolve, reject) => {
++          $.ajax({
++            url: `https://api.dev.constructn.ai/api/v1/snapshots?structure=${structure_id}`,
++            method: "GET",
++            headers: {
++              "Content-Type": "application/json",
++              Authorization: `Bearer ${token}`,
++            },
++            success: (rawData) => {
++              console.log(rawData);
++              if (rawData.result[defaultValue]) {
++                updateDateObject(
++                  rawData,
++                  dateObject,
++                  datesMap,
++                  defaultValue,
++                  snapshotNo
++                );
++              } else if (
++                defaultValue === 1 &&
++                rawData.records[defaultValue - 1]
++              ) {
++                updateDateObject(
++                  rawData,
++                  dateObject,
++                  datesMap,
++                  defaultValue - 1,
++                  snapshotNo
++                );
++              } else {
++                console.log("No records found for Snapshot " + defaultValue);
++              }
++            },
++            error: (e) => {
++              resolve(null);
++            },
++          });
++        });
++      }
++
++      function updateDateObject(
++        rawData,
++        dateObject,
++        datesMap,
++        defaultValue,
++        snapshotNo
++      ) {
++        rawData.result.forEach((record) => {
++          const date = new Date(record["date"]).toISOString().split("T")[0];
++          datesMap[date] = record._id;
++        });
++        console.log(window.location.host);
++        const snapshot = snapshotNo === 1 ? inTilesetID : inTilesetID2;
++        const defaultDate = getValue(datesMap, snapshot)
++          ? getValue(datesMap, snapshot)
++          : new Date(rawData.result[defaultValue]["date"])
++              .toISOString()
++              .split("T")[0];
++        $(dateObject)
++          .datepicker({
++            showOn: "button",
++            buttonImage:
++              "https://dtwin-viewers.s3.ap-south-1.amazonaws.com/icons/calendar.svg",
++            buttonImageOnly: true,
++            buttonText: "Select date",
++            dateFormat: "yy-mm-dd",
++            changeMonth: true,
++            changeYear: true,
++            beforeShowDay: function (date) {
++              var string = jQuery.datepicker.formatDate("yy-mm-dd", date);
++              return [Object.keys(datesMap).indexOf(string) > -1];
++            },
++            onSelect: function (dateText, inst) {
++              let cam = locate(viewer_1);
++              if (snapshotNo === 1) {
++                window.location.href =
++                  "https://internal.constructn.ai/tour1?project=" +
++                  mainProjectID +
++                  "&structure=" +
++                  structure_id +
++                  "&snapshot1=" +
++                  datesMap[dateText] +
++                  "&snapshot2=" +
++                  inTilesetID2 +
++                  "&mode=" +
++                  mode +
++                  "&camera=" +
++                  JSON.stringify(cam) +
++                  "&token=" +
++                  token;
++              } else {
++                window.location.href =
++                  "https://internal.constructn.ai/tour1?project=" +
++                  mainProjectID +
++                  "&structure=" +
++                  structure_id +
++                  "&snapshot1=" +
++                  inTilesetID +
++                  "&snapshot2=" +
++                  datesMap[dateText] +
++                  "&mode=" +
++                  mode +
++                  "&camera=" +
++                  JSON.stringify(cam) +
++                  "&token=" +
++                  token;
++              }
++              // window.location.href = 'https://'+ window.location.host + '/tour?project=' + inProjectID + '&snapshot1=' + datesMap[dateText] + '&snapshot2=' + inTilesetID2 + '&isExterior=0&isFM=1&mode=3d'
++            },
++          })
++          .datepicker("setDate", new Date(defaultDate));
++      }
++
++      function updateIconsDisplay() {
++        Array.from(
++          document.getElementsByClassName("actionButtonsTest")
++        ).forEach((ele) => {
++          $(ele).show();
++          if ($(ele).children(":visible").length === 0) {
++            $(ele).hide();
++          }
++        });
++      }
++
++      function getValue(datesMap, value) {
++        for (let key of Object.keys(datesMap)) {
++          if (datesMap[key] === value) return key;
++        }
++      }
++
++      function takeScreenshot(uploadPath, viewer) {
++        return new Promise((resolve, reject) => {
++          viewer.renderer.domElement.toBlob(function (blob) {
++            // saveAs(blob, "wholePage.png");
++            let file = new File([blob], "task.png");
++            let bodyData = {
++              paths: [uploadPath],
++            };
++
++            $.ajax({
++              url: `https://internal.constructn.ai/api/v1/aws/put-signed-url?bucket=${s3_bucket}`,
++              method: "POST",
++              crossDomain: true,
++              data: JSON.stringify(bodyData),
++              processData: false,
++              contentType: "application/json",
++              success: (reqUrl) => {
++                console.log(reqUrl);
++                $.ajax({
++                  url: reqUrl[0],
++                  method: "PUT",
++                  processData: false,
++                  contentType: false,
++                  data: blob,
++                  success: (reqUrl) => {
++                    console.log("Uploaded Screenshot to S3");
++                    resolve(
++                      `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${uploadPath}`
++                    );
++                  },
++                  error: (e) => {
++                    console.log(e);
++                  },
++                });
++              },
++              error: (e) => {
++                console.log(e);
++              },
++            });
++          });
++          // let div =
++          //     document.getElementById('fpContainer_1');
++
++          // 	return new Promise(resolve => {
++
++          // 		html2canvas(div, {
++          // 			dpi: 200,
++          // 			onrendered: function (canvas) {
++          // 				canvas.toBlob(function(blob) {
++          // 					// saveAs(blob, "wholePage.png");
++          // 					let file = new File([blob], 'task.png')
++        });
++      }
++
++      function fly_progress_walk(in_guid, viewer) {
++        console.log("Progress Walk : Flying to ", in_guid);
++        let db_ids = bimProgressData[viewer.canvasId]["mapping"][in_guid];
++        console.log("DB ID : ", db_ids);
++        viewer.isolate(db_ids);
++        viewer.fitToView(db_ids);
++      }
++
++      function exit_progress_walk(viewer) {
++        viewer.showAll();
++        viewer.fitToView();
++        progress_walk_index = 0;
++      }
++
++      function update_progress_walk(viewer, direction) {
++        if (direction == "next") {
++          progress_walk_index += 1;
++        } else if (direction == "prev") {
++          progress_walk_index -= 1;
++        }
++
++        if (progress_walk_index < 0) {
++          progress_walk_index =
++            bimProgressData[viewer.canvasId]["progress_delta"].length - 1;
++        } else if (
++          progress_walk_index >=
++          bimProgressData[viewer.canvasId]["progress_delta"].length
++        ) {
++          progress_walk_index = 0;
++        }
++
++        fly_progress_walk(
++          bimProgressData[viewer.canvasId]["progress_delta"][
++            progress_walk_index
++          ],
++          viewer
++        );
++      }
++
++      function addProgressWalkButtons(viewer) {
++        // let group = new Autodesk.Viewing.UI.ControlGroup('BimProgress');
++        // viewer.toolbar.addControl(group);
++
++        let group = viewer.toolbar.getControl("BimProgress");
++
++        // Add a new button to the toolbar group
++        let button_walk = new Autodesk.Viewing.UI.Button("progress_walk");
++        let icon_walk =
++          "https://dtwin-viewers.s3.ap-south-1.amazonaws.com/icons/progress_walk.png";
++        button_walk.icon.style = `background-image: url(${icon_walk}); background-size: 24px 24px;`;
++        button_walk.setToolTip("Progress Walk");
++        button_walk.onClick = function (e) {
++          if (progress_walk_mode) {
++            exit_progress_walk(viewer);
++          } else {
++            update_progress_walk(viewer);
++          }
++          progress_walk_mode = !progress_walk_mode;
++        };
++
++        group.addControl(button_walk);
++
++        let button_next = new Autodesk.Viewing.UI.Button("progress_next");
++        let icon_next =
++          "https://dtwin-viewers.s3.ap-south-1.amazonaws.com/icons/progress_walk_next.png";
++        button_next.icon.style = `background-image: url(${icon_next}); background-size: 24px 24px;`;
++        button_next.setToolTip("Next");
++        button_next.onClick = function (e) {
++          if (progress_walk_mode) {
++            update_progress_walk(viewer, "next");
++          }
++        };
++
++        group.addControl(button_next);
++
++        let button_prev = new Autodesk.Viewing.UI.Button("progress_prev");
++        let icon_prev =
++          "https://dtwin-viewers.s3.ap-south-1.amazonaws.com/icons/progress_walk_prev.png";
++        button_prev.icon.style = `background-image: url(${icon_prev}); background-size: 24px 24px;`;
++        button_prev.setToolTip("Prev");
++        button_prev.onClick = function (e) {
++          if (progress_walk_mode) {
++            update_progress_walk(viewer, "prev");
++          }
++        };
++
++        group.addControl(button_prev);
++      }
++
++      async function start_progress_delta_walk(viewer) {
++        // const progress_delta_raw = await fetch(`http://localhost:4200/progress_delta.json`);
++        // if (progress_delta_raw.status == 200) {
++        // const progress_delta = JSON.parse(await progress_delta_raw.text())['delta_elements'];
++        // console.log(progress_delta);
++        // bimProgressData[viewer.canvasId]['progress_delta'] = progress_delta;
++        // fly_progress_walk(bimProgressData[viewer.canvasId]['progress_delta'][progress_walk_index], viewer)
++        // }
++      }
++
++      async function loadProgressWalk(viewer, projectID, tilesetID) {
++        // const progress_delta_raw = await fetch(`http://localhost:4200/progress_delta.json`);
++        const progress_delta_raw = await fetch(
++          `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${projectID}/snapshots/${tilesetID}/bim_progress_delta.json`
++        );
++        if (progress_delta_raw.status == 200) {
++          const progress_delta = JSON.parse(await progress_delta_raw.text())[
++            "delta_elements"
++          ];
++          bimProgressData[viewer.canvasId]["progress_delta"] = progress_delta;
++          addProgressWalkButtons(viewer);
++          console.log("Progress Walk Loaded");
++        }
++      }
++    </script>
++  </body>
++</html>
+diff --git a/examples/lion_las.html b/examples/lion_las.html
+index 1907e7d8..fe233423 100644
+--- a/examples/lion_las.html
++++ b/examples/lion_las.html
+@@ -1,77 +1,376 @@
+ <!DOCTYPE html>
+ <html lang="en">
+-<head>
+-	<meta charset="utf-8">
+-	<meta name="description" content="">
+-	<meta name="author" content="">
+-	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
+-	<title>Potree Viewer</title>
+-
+-	<link rel="stylesheet" type="text/css" href="../build/potree/potree.css">
+-	<link rel="stylesheet" type="text/css" href="../libs/jquery-ui/jquery-ui.min.css">
+-	<link rel="stylesheet" type="text/css" href="../libs/openlayers3/ol.css">
+-	<link rel="stylesheet" type="text/css" href="../libs/spectrum/spectrum.css">
+-	<link rel="stylesheet" type="text/css" href="../libs/jstree/themes/mixed/style.css">
+-</head>
+-
+-<body>
+-	<script src="../libs/jquery/jquery-3.1.1.min.js"></script>
+-	<script src="../libs/spectrum/spectrum.js"></script>
+-	<script src="../libs/jquery-ui/jquery-ui.min.js"></script>
+-	<script src="../libs/other/BinaryHeap.js"></script>
+-	<script src="../libs/tween/tween.min.js"></script>
+-	<script src="../libs/d3/d3.js"></script>
+-	<script src="../libs/proj4/proj4.js"></script>
+-	<script src="../libs/openlayers3/ol.js"></script>
+-	<script src="../libs/i18next/i18next.js"></script>
+-	<script src="../libs/jstree/jstree.js"></script>
+-	<script src="../build/potree/potree.js"></script>
+-	<script src="../libs/plasio/js/laslaz.js"></script>
+-	
+-	<!-- INCLUDE ADDITIONAL DEPENDENCIES HERE -->
+-	<!-- INCLUDE SETTINGS HERE -->
+-	
+-	<div class="potree_container" style="position: absolute; width: 100%; height: 100%; left: 0px; top: 0px; ">
+-		<div id="potree_render_area" style="background-image: url('../build/potree/resources/images/background.jpg');"></div>
+-		<div id="potree_sidebar_container"> </div>
+-	</div>
+-	
+-	<script type="module">
+-
+-	import * as THREE from "../libs/three.js/build/three.module.js";
+-	
+-		window.viewer = new Potree.Viewer(document.getElementById("potree_render_area"));
+-		
+-		viewer.setEDLEnabled(true);
+-		viewer.setFOV(60);
+-		viewer.setPointBudget(1_000_000);
+-		viewer.loadSettingsFromURL();
+-		
+-		viewer.setDescription("Loading Octree of LAS files");
+-		
+-		viewer.loadGUI(() => {
+-			viewer.setLanguage('en');
+-			$("#menu_appearance").next().show();
+-			//viewer.toggleSidebar();
+-		});
+-		
+-		// Sigeom
+-		Potree.loadPointCloud("../pointclouds/lion_takanawa_las/cloud.js", "lion", function(e){
+-			viewer.scene.addPointCloud(e.pointcloud);
+-			
+-			let material = e.pointcloud.material;
+-			material.size = 1;
+-			material.pointSizeType = Potree.PointSizeType.ADAPTIVE;
+-			
+-			e.pointcloud.position.x += 3;
+-			e.pointcloud.position.y -= 3;
+-			e.pointcloud.position.z += 4;
+-			
+-			viewer.fitToScreen();
+-		});
+-		
+-	</script>
+-	
+-	
++  <head>
++    <meta charset="utf-8" />
++    <meta name="description" content="" />
++    <meta name="author" content="" />
++    <meta
++      name="viewport"
++      content="width=device-width, initial-scale=1.0, user-scalable=no"
++    />
++    <title>Potree Viewer</title>
++
++    <link rel="stylesheet" type="text/css" href="../build/potree/potree.css" />
++    <link
++      rel="stylesheet"
++      type="text/css"
++      href="../libs/jquery-ui/jquery-ui.min.css"
++    />
++    <link rel="stylesheet" type="text/css" href="../libs/openlayers3/ol.css" />
++    <link
++      rel="stylesheet"
++      type="text/css"
++      href="../libs/spectrum/spectrum.css"
++    />
++    <link
++      rel="stylesheet"
++      type="text/css"
++      href="../libs/jstree/themes/mixed/style.css"
++    />
++  </head>
++
++  <body>
++    <script src="../libs/jquery/jquery-3.1.1.min.js"></script>
++    <script src="../libs/spectrum/spectrum.js"></script>
++    <script src="../libs/jquery-ui/jquery-ui.min.js"></script>
++    <script src="../libs/other/BinaryHeap.js"></script>
++    <script src="../libs/tween/tween.min.js"></script>
++    <script src="../libs/d3/d3.js"></script>
++    <script src="../libs/proj4/proj4.js"></script>
++    <script src="../libs/openlayers3/ol.js"></script>
++    <script src="../libs/i18next/i18next.js"></script>
++    <script src="../libs/jstree/jstree.js"></script>
++    <script src="../build/potree/potree.js"></script>
++    <script src="../libs/plasio/js/laslaz.js"></script>
++
++    <!-- INCLUDE ADDITIONAL DEPENDENCIES HERE -->
++    <!-- INCLUDE SETTINGS HERE -->
++
++    <div
++      class="potree_container"
++      style="position: absolute; width: 100%; height: 100%; left: 0px; top: 0px"
++    >
++      <div
++        id="potree_render_area"
++        style="
++          background-image: url('../build/potree/resources/images/background.jpg');
++        "
++      ></div>
++      <div id="potree_sidebar_container"></div>
++    </div>
++
++    <script type="module">
++      import * as THREE from "../libs/three.js/build/three.module.js";
++      let i = 0;
++      window.viewer = new Potree.Viewer(
++        document.getElementById("potree_render_area")
++      );
++      //viewer.setDescription(`<button id="myButton">Next Image</button> `);
++      viewer.setEDLEnabled(true);
++      viewer.setFOV(60);
++      viewer.setPointBudget(1_000_000);
++      viewer.loadSettingsFromURL();
++      viewer.loadGUI(() => {
++        viewer.setLanguage("en");
++        $("#menu_appearance").next().show();
++      });
++
++      function isMobileDevice() {
++        // Check for a specific mobile user agent string or screen size
++        // Modify this condition based on your requirements
++        console.log("fduihsdfju8iyshdfgyusifdhkjsdfhyuik", navigator.userAgent);
++        return (
++          /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
++            navigator.userAgent
++          ) || window.innerWidth <= 768
++        );
++      }
++
++      // Execute code only for the mobile version
++      if (isMobileDevice()) {
++        // Your mobile-specific code here
++        console.log("Running on a mobile device");
++        viewer.setDescription(`<button id="myButton">Next Image</button> `);
++        var button = document.getElementById("myButton");
++        button.addEventListener("click", function () {
++          i++;
++          console.log("sdujksdn", i);
++          //   viewer.scene.orientedImages[0].moveToImage(
++          //     viewer.scene.orientedImages[0].images[i]
++          //   );
++          viewer.scene.images360[0].focus(viewer.scene.images360[0].images[i]);
++          //removeAssets(viewer);
++        });
++      } else {
++        // Your web-specific code here
++        console.log("Running on the web", navigator.userAgent);
++      }
++      // Add a click event listener to the button
++      //   button.addEventListener("click", function () {
++      //     i++;
++      //     nextPanoImage(viewer);
++      //     // viewer.scene.orientedImages[0].moveToImage(
++      //     //   viewer.scene.orientedImages[0].images[i]
++      //     // );
++      //     //viewer.scene.images360[0].focus(viewer.scene.images360[0].images[i]);
++      //     //removeAssets(viewer);
++      //   });
++      let viewerMode = "image";
++      // Sigeom
++      Potree.loadPointCloud(
++        "https://constructn-projects-us.s3.us-west-2.amazonaws.com/PRJ957090/structures/STR527991/snapshots/SNP153355/reality/RLT166449/pointcloud/cloud.js",
++        "lion",
++        function (e) {
++          viewer.scene.addPointCloud(e.pointcloud);
++
++          let scene = viewer.scene;
++          let pointcloud = e.pointcloud;
++
++          let material = pointcloud.material;
++          material.size = 0.5;
++          material.minSize = 2.0;
++          material.pointSizeType = Potree.PointSizeType.ADAPTIVE;
++          material.shape = Potree.PointShape.SQUARE;
++          material.activeAttributeName = "rgba";
++          let pcMatrix = new THREE.Matrix4().set(
++            1,
++            0,
++            0,
++            0,
++            0,
++            1,
++            0,
++            0,
++            0,
++            0,
++            1,
++            0,
++            0,
++            0,
++            0,
++            1
++          );
++          let pcOffset = [0, 0, 0];
++          pcMatrix = new THREE.Matrix4()
++            .fromArray([
++              1.000465, 0.003179, 0.000021, -10232.804688, -0.003179, 1.000465,
++              0.000031, -231.655838, -0.000021, -0.000031, 1.00047, -1272.54834,
++              0.0, 0.0, 0.0, 1.0,
++            ])
++            .transpose();
++          pointcloud.applyMatrix(pcMatrix);
++          const assetPosition = pointcloud.position.clone();
++          pointcloud.position.set(
++            assetPosition.x - pcOffset[0],
++            assetPosition.y - pcOffset[1],
++            assetPosition.z - pcOffset[2]
++          );
++          scene.addPointCloud(pointcloud);
++          viewer.fitToScreen();
++          run();
++        }
++      );
++      //   async function run() {
++      //     viewerMode = "image";
++      //     let pcOffset = [0, 0, 0];
++      //     Potree.OrientedImageLoader.load(
++      //       "https://constructn-projects.s3.ap-south-1.amazonaws.com/PRJ156801/structures/STR238477/snapshots/SNP076949/images.json",
++      //       "https://constructn-projects.s3.ap-south-1.amazonaws.com/PRJ156801/structures/STR238477/snapshots/SNP076949/images",
++      //       viewer,
++      //       { tm: new THREE.Matrix4(), offset: pcOffset }
++      //     ).then((images) => {
++      //       console.log("images", images);
++      //       viewer.scene.addOrientedImages(images);
++      //       viewer.scene.orientedImages[0].moveToImage(
++      //         viewer.scene.orientedImages[0].images[i]
++      //       );
++      //     });
++
++      //viewer.mapView.showSources(false);
++      //}
++      //360 images loading
++      async function run() {
++        let pcOffset = [0, 0, 0];
++        Potree.Images360Loader.load(
++          "https://constructn-projects-us.s3.us-west-2.amazonaws.com/PRJ957090/structures/STR527991/snapshots/SNP153355/reality/RLT166449/images.json",
++          "https://constructn-projects-us.s3.us-west-2.amazonaws.com/PRJ957090/structures/STR527991/snapshots/SNP153355/reality/RLT166449/images",
++          viewer,
++          { tm: new THREE.Matrix4(), offset: pcOffset }
++        ).then((images) => {
++          viewer.scene.add360Images(images);
++          viewer.scene.images360[0].focus(viewer.scene.images360[0].images[i]);
++        });
++
++        //viewer.mapView.showSources(false);
++      }
++
++      //   function removeAssets(viewer) {
++      //     viewer.scene.scenePointCloud.remove(viewer.scene.pointclouds[0]);
++      //     viewer.scene.pointclouds = [];
++      //     if (viewer.scene.orientedImages.length) {
++      //       viewer.scene.orientedImages[0].release();
++      //       viewer.scene.orientedImages[0].images.forEach((image) => {
++      //         viewer.scene.scene.children[0].remove(image.mesh);
++      //         viewer.scene.scene.children[0].remove(image.line);
++      //       });
++      //       viewer.scene.scene.remove(viewer.scene.scene.children[0]);
++      //       viewer.scene.removeOrientedImages(viewer.scene.orientedImages[0]);
++      //     }
++
++      //     if (viewer.scene.images360.length) {
++      //       viewer.scene.images360[0].unfocus(false);
++      //       viewer.scene.images360[0].images.forEach((image) => {
++      //         viewer.scene.scene.children[0].remove(image.mesh);
++      //       });
++      //       viewer.scene.scene.children[0].remove(
++      //         viewer.scene.images360[0].sphere
++      //       );
++      //       viewer.scene.scene.remove(viewer.scene.scene.children[0]);
++      //       viewer.scene.remove360Images(viewer.scene.images360[0]);
++      //     }
++      //     if (viewer.isFloorMap) {
++      //       removeFloorMap(viewer);
++      //     }
++      //   }
++      document.addEventListener("keydown", (event) => {
++        if (event.key === "Escape") {
++          // Exit in viewer 2 is already handled in contex maintanance
++          if (viewerMode == "image") {
++            viewer.controls.elExit.click();
++          }
++          // else if (viewerMode == 'panorama') {
++          //     viewer.scene.images360[0].unfocus();
++          // }
++        } else if (event.key === "ArrowUp") {
++          // up arrow
++          if (viewerMode == "image") {
++            viewer.controls.elUp.click();
++            // if (isCompareMode && compareType == "potree") {
++            //   viewer_2.controls.elUp.click();
++            // }
++          } else if (viewerMode == "panorama") {
++            if (event.ctrlKey) {
++              setPitch(viewer, 0.5);
++              //   if (isCompareMode && compareType == "potree") {
++              //     setPitch(viewer_2, 0.5);
++              //   }
++            } else {
++              nextPanoImage(viewer);
++            }
++          }
++        } else if (event.key === "ArrowDown") {
++          // down arrow
++          if (viewerMode == "image") {
++            viewer.controls.elDown.click();
++            if (isCompareMode && compareType == "potree") {
++              viewer_2.controls.elDown.click();
++            }
++          } else if (viewerMode == "panorama") {
++            if (event.ctrlKey) {
++              setPitch(viewer, -0.5);
++              if (isCompareMode && compareType == "potree") {
++                setPitch(viewer_2, -0.5);
++              }
++            }
++          }
++        } else if (event.key === "ArrowLeft") {
++          // left arrow
++          if (viewerMode == "image") {
++            viewer.controls.elLeft.click();
++            if (isCompareMode && compareType == "potree") {
++              viewer_2.controls.elLeft.click();
++            }
++          } else if (viewerMode == "panorama") {
++            setYaw(viewer, 0.5);
++            if (isCompareMode && compareType == "potree") {
++              setYaw(viewer_2, 0.5);
++            }
++          }
++        } else if (event.key === "ArrowRight") {
++          // right arrow
++          if (viewerMode == "image") {
++            viewer.controls.elRight.click();
++            if (isCompareMode && compareType == "potree") {
++              viewer_2.controls.elRight.click();
++            }
++          } else if (viewerMode == "panorama") {
++            setYaw(viewer, -0.5);
++            if (isCompareMode && compareType == "potree") {
++              setYaw(viewer_2, -0.5);
++            }
++          }
++        }
++      });
++      //   function nextPanoImage(viewer) {
++      //     let cameraInstance = viewer.scene.cameraP;
++      //     const camDir = new THREE.Vector3();
++      //     cameraInstance.getWorldDirection(camDir);
++      //     camDir.normalize();
++      //     const camPos = cameraInstance.position;
++      //     const weightages = { angle: 0.5, distance: 0.5 };
++      //     let totalSum = 10000;
++      //     let curSum;
++      //     let selectedPanoImageId;
++      //     let cameraViewProjectionMatrix;
++      //     let imgPos;
++      //     let dist;
++      //     let angle;
++      //     let frustum;
++      //     const camToImgDir = new THREE.Vector3();
++      //     const maxDist = 10;
++      //     const panoImgs = viewer.scene.images360[0].images;
++
++      //     for (let i = 0; i < panoImgs.length; i++) {
++      //       if (panoImgs[i].file == viewer.scene.images360[0].focusedImage.file) {
++      //         continue;
++      //       }
++      //       imgPos = new THREE.Vector3().fromArray(panoImgs[i].position);
++      //       frustum = new THREE.Frustum();
++      //       cameraViewProjectionMatrix = new THREE.Matrix4();
++      //       cameraInstance.updateMatrixWorld(); // make sure the camera matrix is updated
++      //       // cameraInstance.matrixWorldInverse.getInverse(cameraInstance.matrixWorld);
++      //       cameraInstance.matrixWorldInverse
++      //         .copy(cameraInstance.matrixWorld)
++      //         .invert();
++      //       cameraViewProjectionMatrix.multiplyMatrices(
++      //         cameraInstance.projectionMatrix,
++      //         cameraInstance.matrixWorldInverse
++      //       );
++      //       frustum.setFromMatrix(cameraViewProjectionMatrix);
++
++      //       // // if (frustum.containsPoint(imgPos)) {
++      //       dist = imgPos.distanceTo(camPos);
++      //       if (dist < maxDist) {
++      //         camToImgDir.subVectors(imgPos, camPos).normalize();
++      //         angle = Math.abs(camToImgDir.angleTo(camDir));
++      //         // tslint:disable-next-line: no-string-literal
++      //         curSum =
++      //           weightages["angle"] * angle + weightages["distance"] * dist;
++      //         if (curSum < totalSum) {
++      //           selectedPanoImageId = i;
++      //           totalSum = curSum;
++      //         }
++      //       }
++      //       // // }
++
++      //       // dist = imgPos.distanceTo(camPos);
++      //       // if (dist < maxDist) {
++      //       //     camToImgDir.subVectors(imgPos, camPos).normalize();
++      //       //     angle = Math.abs(camToImgDir.angleTo(camDir));
++      //       //     // tslint:disable-next-line: no-string-literal
++      //       //     // curSum = (weightages['angle'] * angle) + (weightages['distance'] * dist);
++      //       //     if (angle < totalSum) {
++      //       //         selectedPanoImageId = i;
++      //       //         totalSum = angle;
++      //       //     }
++      //       // }
++      //     }
++      //     if (selectedPanoImageId != undefined) {
++      //       viewer.scene.images360[0].focus(panoImgs[selectedPanoImageId]);
++      //     } else {
++      //       console.warn("No Nearest 360 Images");
++      //     }
++      //   }
++    </script>
+   </body>
+ </html>
+diff --git a/src/modules/Images360/Images360.js b/src/modules/Images360/Images360.js
+index 02026fd0..669de80b 100644
+--- a/src/modules/Images360/Images360.js
++++ b/src/modules/Images360/Images360.js
+@@ -1,344 +1,305 @@
+-
+ import * as THREE from "../../../libs/three.js/build/three.module.js";
+ import { EventDispatcher } from "../../EventDispatcher.js";
+-import {TextSprite} from "../../TextSprite.js";
+-
+-let sg = new THREE.SphereGeometry(1, 8, 8);
+-let sgHigh = new THREE.SphereGeometry(1, 128, 128);
+-
+-let sm = new THREE.MeshBasicMaterial({side: THREE.BackSide});
+-let smHovered = new THREE.MeshBasicMaterial({side: THREE.BackSide, color: 0xff0000});
+-
+-let raycaster = new THREE.Raycaster();
+-let currentlyHovered = null;
+-
+-let previousView = {
+-	controls: null,
+-	position: null,
+-	target: null,
+-};
+-
+-class Image360{
+-
+-	constructor(file, time, longitude, latitude, altitude, course, pitch, roll){
+-		this.file = file;
+-		this.time = time;
+-		this.longitude = longitude;
+-		this.latitude = latitude;
+-		this.altitude = altitude;
+-		this.course = course;
+-		this.pitch = pitch;
+-		this.roll = roll;
+-		this.mesh = null;
+-	}
+-};
+-
+-export class Images360 extends EventDispatcher{
+-
+-	constructor(viewer){
+-		super();
+-
+-		this.viewer = viewer;
+-
+-		this.selectingEnabled = true;
+-
+-		this.images = [];
+-		this.node = new THREE.Object3D();
+-
+-		this.sphere = new THREE.Mesh(sgHigh, sm);
+-		this.sphere.visible = false;
+-		this.sphere.scale.set(1000, 1000, 1000);
+-		this.node.add(this.sphere);
+-		this._visible = true;
+-		// this.node.add(label);
+-
+-		this.focusedImage = null;
+-
+-		let elUnfocus = document.createElement("input");
+-		elUnfocus.type = "button";
+-		elUnfocus.value = "unfocus";
+-		elUnfocus.style.position = "absolute";
+-		elUnfocus.style.right = "10px";
+-		elUnfocus.style.bottom = "10px";
+-		elUnfocus.style.zIndex = "10000";
+-		elUnfocus.style.fontSize = "2em";
+-		elUnfocus.addEventListener("click", () => this.unfocus());
+-		this.elUnfocus = elUnfocus;
+-
+-		this.domRoot = viewer.renderer.domElement.parentElement;
+-		this.domRoot.appendChild(elUnfocus);
+-		this.elUnfocus.style.display = "none";
+-
+-		viewer.addEventListener("update", () => {
+-			this.update(viewer);
+-		});
+-		viewer.inputHandler.addInputListener(this);
+-
+-		this.addEventListener("mousedown", () => {
+-			if(currentlyHovered && currentlyHovered.image360){
+-				this.focus(currentlyHovered.image360);
+-			}
+-		});
+-		
+-	};
+-
+-	set visible(visible){
+-		if(this._visible === visible){
+-			return;
+-		}
+-
+-
+-		for(const image of this.images){
+-			image.mesh.visible = visible && (this.focusedImage == null);
+-		}
+-
+-		this.sphere.visible = visible && (this.focusedImage != null);
+-		this._visible = visible;
+-		this.dispatchEvent({
+-			type: "visibility_changed",
+-			images: this,
+-		});
+-	}
+-
+-	get visible(){
+-		return this._visible;
+-	}
+-
+-	focus(image360){
+-		if(this.focusedImage !== null){
+-			this.unfocus();
+-		}
+-
+-		previousView = {
+-			controls: this.viewer.controls,
+-			position: this.viewer.scene.view.position.clone(),
+-			target: viewer.scene.view.getPivot(),
+-		};
+-
+-		this.viewer.setControls(this.viewer.orbitControls);
+-		this.viewer.orbitControls.doubleClockZoomEnabled = false;
+-
+-		for(let image of this.images){
+-			image.mesh.visible = false;
+-		}
+-
+-		this.selectingEnabled = false;
+-
+-		this.sphere.visible = false;
+-
+-		this.load(image360).then( () => {
+-			this.sphere.visible = true;
+-			this.sphere.material.map = image360.texture;
+-			this.sphere.material.needsUpdate = true;
+-		});
+-
+-		{ // orientation
+-			let {course, pitch, roll} = image360;
+-			this.sphere.rotation.set(
+-				THREE.Math.degToRad(+roll + 90),
+-				THREE.Math.degToRad(-pitch),
+-				THREE.Math.degToRad(-course + 90),
+-				"ZYX"
+-			);
+-		}
+-
+-		this.sphere.position.set(...image360.position);
+-
+-		let target = new THREE.Vector3(...image360.position);
+-		let dir = target.clone().sub(viewer.scene.view.position).normalize();
+-		let move = dir.multiplyScalar(0.000001);
+-		let newCamPos = target.clone().sub(move);
+-
+-		viewer.scene.view.setView(
+-			newCamPos, 
+-			target,
+-			500
+-		);
+-
+-		this.focusedImage = image360;
+-
+-		this.elUnfocus.style.display = "";
+-	}
+-
+-	unfocus(){
+-		this.selectingEnabled = true;
+-
+-		for(let image of this.images){
+-			image.mesh.visible = true;
+-		}
+-
+-		let image = this.focusedImage;
+-
+-		if(image === null){
+-			return;
+-		}
+-
+-
+-		this.sphere.material.map = null;
+-		this.sphere.material.needsUpdate = true;
+-		this.sphere.visible = false;
+-
+-		let pos = viewer.scene.view.position;
+-		let target = viewer.scene.view.getPivot();
+-		let dir = target.clone().sub(pos).normalize();
+-		let move = dir.multiplyScalar(10);
+-		let newCamPos = target.clone().sub(move);
+-
+-		viewer.orbitControls.doubleClockZoomEnabled = true;
+-		viewer.setControls(previousView.controls);
+-
+-		viewer.scene.view.setView(
+-			previousView.position, 
+-			previousView.target,
+-			500
+-		);
+-
+-
+-		this.focusedImage = null;
+-
+-		this.elUnfocus.style.display = "none";
+-	}
+-
+-	load(image360){
+-
+-		return new Promise(resolve => {
+-			let texture = new THREE.TextureLoader().load(image360.file, resolve);
+-			texture.wrapS = THREE.RepeatWrapping;
+-			texture.repeat.x = -1;
+-
+-			image360.texture = texture;
+-		});
+-
+-	}
+-
+-	handleHovering(){
+-		let mouse = viewer.inputHandler.mouse;
+-		let camera = viewer.scene.getActiveCamera();
+-		let domElement = viewer.renderer.domElement;
+-
+-		let ray = Potree.Utils.mouseToRay(mouse, camera, domElement.clientWidth, domElement.clientHeight);
+-
+-		// let tStart = performance.now();
+-		raycaster.ray.copy(ray);
+-		let intersections = raycaster.intersectObjects(this.node.children);
+-
+-		if(intersections.length === 0){
+-			// label.visible = false;
+-
+-			return;
+-		}
+-
+-		let intersection = intersections[0];
+-		currentlyHovered = intersection.object;
+-		currentlyHovered.material = smHovered;
+-
+-		//label.visible = true;
+-		//label.setText(currentlyHovered.image360.file);
+-		//currentlyHovered.getWorldPosition(label.position);
+-	}
+-
+-	update(){
+-
+-		let {viewer} = this;
+-
+-		if(currentlyHovered){
+-			currentlyHovered.material = sm;
+-			currentlyHovered = null;
+-		}
+-
+-		if(this.selectingEnabled){
+-			this.handleHovering();
+-		}
+-
+-	}
+-
+-};
+-
+-
+-export class Images360Loader{
+-
+-	static async load(url, viewer, params = {}){
+-
+-		if(!params.transform){
+-			params.transform = {
+-				forward: a => a,
+-			};
+-		}
+-		
+-		let response = await fetch(`${url}/coordinates.txt`);
+-		let text = await response.text();
+-
+-		let lines = text.split(/\r?\n/);
+-		let coordinateLines = lines.slice(1);
+-
+-		let images360 = new Images360(viewer);
+-
+-		for(let line of coordinateLines){
+-
+-			if(line.trim().length === 0){
+-				continue;
+-			}
+-
+-			let tokens = line.split(/\t/);
+-
+-			let [filename, time, long, lat, alt, course, pitch, roll] = tokens;
+-			time = parseFloat(time);
+-			long = parseFloat(long);
+-			lat = parseFloat(lat);
+-			alt = parseFloat(alt);
+-			course = parseFloat(course);
+-			pitch = parseFloat(pitch);
+-			roll = parseFloat(roll);
+-
+-			filename = filename.replace(/"/g, "");
+-			let file = `${url}/${filename}`;
+-
+-			let image360 = new Image360(file, time, long, lat, alt, course, pitch, roll);
+-
+-			let xy = params.transform.forward([long, lat]);
+-			let position = [...xy, alt];
+-			image360.position = position;
+-
+-			images360.images.push(image360);
+-		}
+-
+-		Images360Loader.createSceneNodes(images360, params.transform);
+-
+-		return images360;
+-
+-	}
+-
+-	static createSceneNodes(images360, transform){
+-
+-		for(let image360 of images360.images){
+-			let {longitude, latitude, altitude} = image360;
+-			let xy = transform.forward([longitude, latitude]);
+-
+-			let mesh = new THREE.Mesh(sg, sm);
+-			mesh.position.set(...xy, altitude);
+-			mesh.scale.set(1, 1, 1);
+-			mesh.material.transparent = true;
+-			mesh.material.opacity = 0.75;
+-			mesh.image360 = image360;
+-
+-			{ // orientation
+-				var {course, pitch, roll} = image360;
+-				mesh.rotation.set(
+-					THREE.Math.degToRad(+roll + 90),
+-					THREE.Math.degToRad(-pitch),
+-					THREE.Math.degToRad(-course + 90),
+-					"ZYX"
+-				);
+-			}
+-
+-			images360.node.add(mesh);
+-
+-			image360.mesh = mesh;
+-		}
+-	}
+-
+-	
+-
+-};
+-
+ 
++class Image360 {
++  constructor(
++    file,
++    thumbnail,
++    longitude,
++    latitude,
++    altitude,
++    course,
++    pitch,
++    roll
++  ) {
++    this.file = file;
++    this.thumbnail = thumbnail;
++    this.longitude = longitude;
++    this.latitude = latitude;
++    this.altitude = altitude;
++    this.course = course;
++    this.pitch = pitch;
++    this.roll = roll;
++  }
++}
++
++export class Images360 extends EventDispatcher {
++  constructor(viewer) {
++    super();
++
++    this.viewer = viewer;
++
++    this.selectingEnabled = true;
++
++    this.images = [];
++    this.node = new THREE.Object3D();
++
++    this.sphere = new THREE.Mesh(
++      new THREE.SphereGeometry(1, 128, 128),
++      new THREE.MeshBasicMaterial({ side: THREE.BackSide })
++    );
++    this.sphere.visible = false;
++    this.sphere.scale.set(-1000, 1000, 1000);
++
++    this.focus = this.focus.bind(this);
++    this.unfocus = this.unfocus.bind(this);
++    this.node.add(this.sphere);
++    this._visible = true;
++
++    this.focusedImage = null;
++    this.currentlyHovered = null;
++    this.previousView = {
++      controls: null,
++      position: null,
++      target: null,
++    };
++    this.raycaster = new THREE.Raycaster();
++    this.hoverMaterial = new THREE.MeshBasicMaterial({
++      side: THREE.BackSide,
++      color: 0xff0000,
++    });
++    this.sm = new THREE.MeshBasicMaterial({ side: THREE.BackSide });
++
++    // viewer.addEventListener("update", () => {
++    //   this.update(viewer);
++    // });
++    viewer.inputHandler.addInputListener(this);
++
++    this.addEventListener("mousedown", () => {
++      if (this.currentlyHovered && this.currentlyHovered.image360) {
++        this.focus(this.currentlyHovered.image360);
++      }
++    });
++  }
++
++  set visible(visible) {
++    if (this._visible === visible) {
++      return;
++    }
++    this.sphere.visible = visible && this.focusedImage != null;
++    this._visible = visible;
++    this.dispatchEvent({
++      type: "visibility_changed",
++      images: this,
++    });
++  }
++
++  get visible() {
++    return this._visible;
++  }
++
++  focus(image360, sendEvent = true, inTarget = null) {
++    if (this.focusedImage !== null) {
++      this.unfocus();
++    }
++    this.viewer.setEDLOpacity(0);
++    if (sendEvent) {
++      const event = new CustomEvent("panoLoad", {
++        detail: {
++          viewer: this.viewer.canvasId,
++          image: image360,
++        },
++      });
++      document.dispatchEvent(event);
++    }
++
++    this.previousView = {
++      controls: this.viewer.controls,
++      position: this.viewer.scene.view.position.clone(),
++      target: this.viewer.scene.view.getPivot(),
++    };
++
++    this.viewer.setControls(this.viewer.orbitControls);
++    this.viewer.orbitControls.doubleClockZoomEnabled = false;
++
++    this.selectingEnabled = false;
++
++    this.sphere.visible = false;
++
++    this.load(image360).then(() => {
++      this.sphere.visible = true;
++      this.sphere.material.map = image360.texture;
++      this.sphere.material.needsUpdate = true;
++    });
++
++    // orientation
++    let { course, pitch, roll } = image360;
++
++    this.sphere.rotation.set(
++      THREE.Math.degToRad(course),
++      THREE.Math.degToRad(pitch),
++      THREE.Math.degToRad(roll),
++      "XYZ"
++    );
++
++    this.sphere.position.set(...image360.position);
++
++    let target = new THREE.Vector3(...image360.position);
++    let dir = target.clone().sub(this.viewer.scene.view.position).normalize();
++    let move = dir.multiplyScalar(0.000001);
++    let newCamPos = target.clone().sub(move);
++
++    this.viewer.scene.view.setView(newCamPos, target, 500, () => {
++      if (inTarget && inTarget.pitch) {
++        this.viewer.scene.view.pitch = inTarget.pitch;
++        this.viewer.scene.view.yaw = inTarget.yaw;
++      }
++    });
++
++    this.focusedImage = image360;
++  }
++
++  unfocus(sendEvent = true) {
++    this.selectingEnabled = true;
++    this.viewer.setEDLOpacity(1);
++
++    let image = this.focusedImage;
++
++    if (image === null) {
++      return;
++    }
++    delete image.texture;
++    this.sphere.material.map = null;
++    this.sphere.material.needsUpdate = true;
++    this.sphere.visible = false;
++    this.viewer.orbitControls.doubleClockZoomEnabled = true;
++    this.viewer.setControls(this.previousView.controls);
++
++    this.focusedImage = null;
++
++    if (sendEvent) {
++      const event = new CustomEvent("panoUnload", {
++        detail: {
++          viewer: this.viewer.canvasId,
++        },
++      });
++      document.dispatchEvent(event);
++    }
++  }
++
++  load(image360) {
++    let resolved = false;
++    return new Promise((resolve) => {
++      if (image360.texture) {
++        resolve(null);
++      } else {
++        new THREE.TextureLoader().load(
++          image360.thumbnail,
++          (texture) => {
++            image360.texture = texture;
++            resolved = true;
++            resolve(null);
++            loadOrgImage.bind(this)();
++          },
++          undefined,
++          (err) => {
++            loadOrgImage.bind(this)();
++          }
++        );
++        let loadOrgImage = function () {
++          new THREE.TextureLoader().load(image360.file, (texture) => {
++            image360.texture = texture;
++            this.sphere.visible = true;
++            this.sphere.material.map = image360.texture;
++            this.sphere.material.needsUpdate = true;
++            if (!resolved) {
++              resolve(null);
++            }
++            // }
++          });
++        };
++      }
++    });
++  }
++
++  //   handleHovering() {
++  //     let mouse = this.viewer.inputHandler.mouse;
++  //     let camera = this.viewer.scene.getActiveCamera();
++  //     let domElement = this.viewer.renderer.domElement;
++
++  //     let ray = Potree.Utils.mouseToRay(
++  //       mouse,
++  //       camera,
++  //       domElement.clientWidth,
++  //       domElement.clientHeight
++  //     );
++
++  //     this.raycaster.ray.copy(ray);
++  //     let intersections = this.raycaster.intersectObjects(this.node.children);
++
++  //     if (intersections.length === 0) {
++  //       return;
++  //     }
++
++  //     let intersection = intersections[0];
++  //     this.currentlyHovered = intersection.object;
++  //     this.currentlyHovered.material = this.hoverMaterial;
++  //   }
++
++  //   update() {
++  //     let { viewer } = this;
++
++  //     if (this.currentlyHovered) {
++  //       this.currentlyHovered.material = this.sm;
++  //       this.currentlyHovered = null;
++  //     }
++
++  //     if (this.selectingEnabled) {
++  //       // this.handleHovering();
++  //     }
++  //   }
++}
++
++export class Images360Loader {
++  static async load(url, imgsUrl, viewer, tm_data) {
++    let tmatrix, toffset;
++
++    tmatrix = tm_data.tm;
++    toffset = tm_data.offset;
++
++    let response = await fetch(url);
++    let text = await response.text();
++    let imgData = JSON.parse(text);
++
++    let images360 = new Images360(viewer);
++    Object.keys(imgData).forEach((imgName) => {
++      let raw_position = imgData[imgName].position;
++      let rotation = imgData[imgName].rotation;
++
++      const pos = new THREE.Vector4(
++        raw_position[0],
++        raw_position[1],
++        raw_position[2],
++        1
++      );
++      pos.applyMatrix4(tmatrix);
++
++      const long = parseFloat(pos.x - toffset[0]);
++      const lat = parseFloat(pos.y - toffset[1]);
++      const alt = parseFloat(pos.z - toffset[2]);
++      const course = parseFloat(rotation[0]);
++      const pitch = parseFloat(rotation[1]);
++      const roll = parseFloat(rotation[2]);
++
++      let file = `${imgsUrl}/${imgName}`;
++      let thumbnail = `${imgsUrl}/thumbnails/${imgName}`;
++      let image360 = new Image360(
++        file,
++        thumbnail,
++        long,
++        lat,
++        alt,
++        course,
++        pitch,
++        roll
++      );
++
++      let position = [long, lat, alt];
++      image360.position = position;
++
++      images360.images.push(image360);
++    });
++
++    return images360;
++  }
++}
+diff --git a/src/modules/OrientedImages/OrientedImageControls.js b/src/modules/OrientedImages/OrientedImageControls.js
+index 26ac322d..5b43c6ca 100644
+--- a/src/modules/OrientedImages/OrientedImageControls.js
++++ b/src/modules/OrientedImages/OrientedImageControls.js
+@@ -29,15 +29,24 @@ export class OrientedImageControls extends EventDispatcher{
+ 
+ 		this.shear = [0, 0];
+ 
++		this.changeEvent = new CustomEvent("camerachange");
++
++
+ 		// const style = ``;
+-		this.elUp =    $(`<input type="button" value="" style="position: absolute; top: 10px; left: calc(50%); z-index: 1000" />`);
+-		this.elRight = $(`<input type="button" value="" style="position: absolute; top: calc(50%); right: 10px; z-index: 1000" />`);
+-		this.elDown =  $(`<input type="button" value="" style="position: absolute; bottom: 10px; left: calc(50%); z-index: 1000" />`);
+-		this.elLeft =  $(`<input type="button" value="" style="position: absolute; top: calc(50%); left: 10px; z-index: 1000" />`);
+-		this.elExit = $(`<input type="button" value="Back to 3D view" style="position: absolute; bottom: 10px; right: 10px; z-index: 1000" />`);
++		this.elUp =    $(`<input type="button" value="" style="position: absolute; top: 10px; left: calc(50%); z-index: 1000; display: none" />`);
++		this.elRight = $(`<input type="button" value="" style="position: absolute; top: calc(50%); right: 10px; z-index: 1000; display: none" />`);
++		this.elDown =  $(`<input type="button" value="" style="position: absolute; bottom: 10px; left: calc(50%); z-index: 1000; display: none" />`);
++		this.elLeft =  $(`<input type="button" value="" style="position: absolute; top: calc(50%); left: 10px; z-index: 1000; display: none" />`);
++		this.elExit = $(`<input type="button" value="Back to 3D view" style="position: absolute; bottom: 10px; right: 10px; z-index: 1000; display: none" />`);
+ 
+ 		this.elExit.click( () => {
+ 			this.release();
++			const event = new CustomEvent("imageUnload", {
++				detail: {
++					viewer: this.viewer.canvasId
++				}
++			});
++			document.dispatchEvent(event);
+ 		});
+ 
+ 		this.elUp.click(() => {
+@@ -68,7 +77,13 @@ export class OrientedImageControls extends EventDispatcher{
+ 		this.sceneControls = new THREE.Scene();
+ 
+ 		let scroll = (e) => {
+-			this.fovDelta += -e.delta * 1.0;
++			// this.fovDelta += -e.delta * 1.0;
++			this.shear = [0, 0];
++			let fov = this.viewer.getFOV() + (-e.delta * 5);
++			if (fov > 10 && fov < 100) {
++				this.viewer.setFOV(fov);
++				document.dispatchEvent(this.changeEvent)
++			}
+ 		};
+ 
+ 		this.addEventListener('mousewheel', scroll);
+@@ -103,9 +118,13 @@ export class OrientedImageControls extends EventDispatcher{
+ 		elRoot.append(this.elDown);
+ 		elRoot.append(this.elLeft);
+ 		elRoot.append(this.elExit);
++
++		this.viewer.setFOV(30);
++
+ 	}
+ 
+ 	release(){
++
+ 		this.image = null;
+ 
+ 		this.viewer.scene.overrideCamera = null;
+@@ -117,7 +136,13 @@ export class OrientedImageControls extends EventDispatcher{
+ 		this.elExit.detach();
+ 
+ 		this.viewer.setFOV(this.originalFOV);
++		this.viewer.scene.cameraP.fov = this.originalFOV;
+ 		this.viewer.setControls(this.originalControls);
++		this.viewer.controls.enabled = true;
++	}
++
++	stop() {
++		this.release();
+ 	}
+ 
+ 	setScene (scene) {
+diff --git a/src/modules/OrientedImages/OrientedImages.js b/src/modules/OrientedImages/OrientedImages.js
+index ce7a650d..0d95c86e 100644
+--- a/src/modules/OrientedImages/OrientedImages.js
++++ b/src/modules/OrientedImages/OrientedImages.js
+@@ -1,14 +1,9 @@
+-
+ import * as THREE from "../../../libs/three.js/build/three.module.js";
+-import {OrientedImageControls} from "./OrientedImageControls.js";
++import { OrientedImageControls } from "./OrientedImageControls.js";
+ import { EventDispatcher } from "../../EventDispatcher.js";
+ 
+-// https://support.pix4d.com/hc/en-us/articles/205675256-How-are-yaw-pitch-roll-defined
+-// https://support.pix4d.com/hc/en-us/articles/202558969-How-are-omega-phi-kappa-defined
+-
+-function createMaterial(){
+-
+-	let vertexShader = `
++function createMaterial() {
++  let vertexShader = `
+ 	uniform float uNear;
+ 	varying vec2 vUV;
+ 	varying vec4 vDebug;
+@@ -23,7 +18,7 @@ function createMaterial(){
+ 	}
+ 	`;
+ 
+-	let fragmentShader = `
++  let fragmentShader = `
+ 	uniform sampler2D tColor;
+ 	uniform float uOpacity;
+ 	varying vec2 vUV;
+@@ -34,457 +29,460 @@ function createMaterial(){
+ 		gl_FragColor.a = uOpacity;
+ 	}
+ 	`;
+-	const material = new THREE.ShaderMaterial( {
+-		uniforms: {
+-			// time: { value: 1.0 },
+-			// resolution: { value: new THREE.Vector2() }
+-			tColor: {value: new THREE.Texture() },
+-			uNear: {value: 0.0},
+-			uOpacity: {value: 1.0},
+-		},
+-		vertexShader: vertexShader,
+-		fragmentShader: fragmentShader,
+-		side: THREE.DoubleSide,
+-	} );
+-
+-	material.side = THREE.DoubleSide;
+-
+-	return material;
++  const material = new THREE.ShaderMaterial({
++    uniforms: {
++      tColor: { value: new THREE.Texture() },
++      uNear: { value: 0.0 },
++      uOpacity: { value: 1.0 },
++    },
++    vertexShader: vertexShader,
++    fragmentShader: fragmentShader,
++    side: THREE.DoubleSide,
++  });
++
++  material.side = THREE.DoubleSide;
++
++  return material;
+ }
+ 
+ const planeGeometry = new THREE.PlaneGeometry(1, 1);
+ const lineGeometry = new THREE.Geometry();
+ 
+ lineGeometry.vertices.push(
+-	new THREE.Vector3(-0.5, -0.5, 0),
+-	new THREE.Vector3( 0.5, -0.5, 0),
+-	new THREE.Vector3( 0.5,  0.5, 0),
+-	new THREE.Vector3(-0.5,  0.5, 0),
+-	new THREE.Vector3(-0.5, -0.5, 0),
++  new THREE.Vector3(-0.5, -0.5, 0),
++  new THREE.Vector3(0.5, -0.5, 0),
++  new THREE.Vector3(0.5, 0.5, 0),
++  new THREE.Vector3(-0.5, 0.5, 0),
++  new THREE.Vector3(-0.5, -0.5, 0)
+ );
+ 
+-export class OrientedImage{
+-
+-	constructor(id){
+-
+-		this.id = id;
+-		this.fov = 1.0;
+-		this.position = new THREE.Vector3();
+-		this.rotation = new THREE.Vector3();
+-		this.width = 0;
+-		this.height = 0;
+-		this.fov = 1.0;
+-
+-		const material = createMaterial();
+-		const lineMaterial = new THREE.LineBasicMaterial( { color: 0x00ff00 } );
+-		this.mesh = new THREE.Mesh(planeGeometry, material);
+-		this.line = new THREE.Line(lineGeometry, lineMaterial);
+-		this.texture = null;
+-
+-		this.mesh.orientedImage = this;
+-	}
+-
+-	set(position, rotation, dimension, fov){
+-
+-		let radians = rotation.map(THREE.Math.degToRad);
+-
+-		this.position.set(...position);
+-		this.mesh.position.set(...position);
+-
+-		this.rotation.set(...radians);
+-		this.mesh.rotation.set(...radians);
+-
+-		[this.width, this.height] = dimension;
+-		this.mesh.scale.set(this.width / this.height, 1, 1);
+-
+-		this.fov = fov;
+-
+-		this.updateTransform();
+-	}
+-
+-	updateTransform(){
+-		let {mesh, line, fov} = this;
+-
+-		mesh.updateMatrixWorld();
+-		const dir = mesh.getWorldDirection();
+-		const alpha = THREE.Math.degToRad(fov / 2);
+-		const d = -0.5 / Math.tan(alpha);
+-		const move = dir.clone().multiplyScalar(d);
+-		mesh.position.add(move);
+-
+-		line.position.copy(mesh.position);
+-		line.scale.copy(mesh.scale);
+-		line.rotation.copy(mesh.rotation);
+-	}
+-
+-};
+-
+-export class OrientedImages extends EventDispatcher{
+-
+-	constructor(){
+-		super();
+-
+-		this.node = null;
+-		this.cameraParams = null;
+-		this.imageParams = null;
+-		this.images = null;
+-		this._visible = true;
+-	}
+-
+-	set visible(visible){
+-		if(this._visible === visible){
+-			return;
+-		}
+-
+-		for(const image of this.images){
+-			image.mesh.visible = visible;
+-			image.line.visible = visible;
+-		}
+-
+-		this._visible = visible;
+-		this.dispatchEvent({
+-			type: "visibility_changed",
+-			images: this,
+-		});
+-	}
+-
+-	get visible(){
+-		return this._visible;
+-	}
+-
+-
+-};
+-
+-export class OrientedImageLoader{
+-
+-	static async loadCameraParams(path){
+-		const res = await fetch(path);
+-		const text = await res.text();
+-
+-		const parser = new DOMParser();
+-		const doc = parser.parseFromString(text, "application/xml");
+-
+-		const width = parseInt(doc.getElementsByTagName("width")[0].textContent);
+-		const height = parseInt(doc.getElementsByTagName("height")[0].textContent);
+-		const f = parseFloat(doc.getElementsByTagName("f")[0].textContent);
+-
+-		let a = (height / 2)  / f;
+-		let fov = 2 * THREE.Math.radToDeg(Math.atan(a));
+-
+-		const params = {
+-			path: path,
+-			width: width,
+-			height: height,
+-			f: f,
+-			fov: fov,
+-		};
+-
+-		return params;
+-	}
+-
+-	static async loadImageParams(path){
+-
+-		const response = await fetch(path);
+-		if(!response.ok){
+-			console.error(`failed to load ${path}`);
+-			return;
+-		}
+-
+-		const content = await response.text();
+-		const lines = content.split(/\r?\n/);
+-		const imageParams = [];
+-
+-		for(let i = 1; i < lines.length; i++){
+-			const line = lines[i];
+-
+-			if(line.startsWith("#")){
+-				continue;
+-			}
+-
+-			const tokens = line.split(/\s+/);
+-
+-			if(tokens.length < 6){
+-				continue;
+-			}
+-
+-			const params = {
+-				id: tokens[0],
+-				x: Number.parseFloat(tokens[1]),
+-				y: Number.parseFloat(tokens[2]),
+-				z: Number.parseFloat(tokens[3]),
+-				omega: Number.parseFloat(tokens[4]),
+-				phi: Number.parseFloat(tokens[5]),
+-				kappa: Number.parseFloat(tokens[6]),
+-			};
+-
+-			// const whitelist = ["47518.jpg"];
+-			// if(whitelist.includes(params.id)){
+-			// 	imageParams.push(params);
+-			// }
+-			imageParams.push(params);
+-		}
+-
+-		// debug
+-		//return [imageParams[50]];
+-
+-		return imageParams;
+-	}
++export class OrientedImage {
++  constructor(id) {
++    this.id = id;
++    this.fov = 1.0;
++    this.position = new THREE.Vector3();
++    this.rotation = new THREE.Vector3();
++    this.width = 0;
++    this.height = 0;
++    this.fov = 1.0;
++
++    const material = createMaterial();
++    const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
++    this.mesh = new THREE.Mesh(planeGeometry, material);
++    this.line = new THREE.Line(lineGeometry, lineMaterial);
++    this.texture = null;
++
++    this.mesh.orientedImage = this;
++  }
++
++  set(position, rotation, dimension, fov) {
++    let radians = rotation.map(THREE.Math.degToRad);
++
++    this.position.set(...position);
++    this.mesh.position.set(...position);
++
++    this.rotation.set(...radians);
++    this.mesh.rotation.set(...radians);
++
++    [this.width, this.height] = dimension;
++    this.mesh.scale.set(this.width / this.height, 1, 1);
++
++    this.fov = fov;
++
++    this.updateTransform();
++  }
++
++  updateTransform() {
++    let { mesh, line, fov } = this;
++
++    mesh.updateMatrixWorld();
++    var dir = new THREE.Vector3();
++    mesh.getWorldDirection(dir);
++    const alpha = THREE.Math.degToRad(fov / 2);
++    const d = -0.5 / Math.tan(alpha);
++    const move = dir.clone().multiplyScalar(d);
++    mesh.position.add(move);
++
++    line.position.copy(mesh.position);
++    line.scale.copy(mesh.scale);
++    line.rotation.copy(mesh.rotation);
++  }
++}
+ 
+-	static async load(cameraParamsPath, imageParamsPath, viewer){
+-
+-		const tStart = performance.now();
+-
+-		const [cameraParams, imageParams] = await Promise.all([
+-			OrientedImageLoader.loadCameraParams(cameraParamsPath),
+-			OrientedImageLoader.loadImageParams(imageParamsPath),
+-		]);
+-
+-		const orientedImageControls = new OrientedImageControls(viewer);
+-		const raycaster = new THREE.Raycaster();
+-
+-		const tEnd = performance.now();
+-		console.log(tEnd - tStart);
+-
+-		// const sp = new THREE.PlaneGeometry(1, 1);
+-		// const lg = new THREE.Geometry();
+-
+-		// lg.vertices.push(
+-		// 	new THREE.Vector3(-0.5, -0.5, 0),
+-		// 	new THREE.Vector3( 0.5, -0.5, 0),
+-		// 	new THREE.Vector3( 0.5,  0.5, 0),
+-		// 	new THREE.Vector3(-0.5,  0.5, 0),
+-		// 	new THREE.Vector3(-0.5, -0.5, 0),
+-		// );
+-
+-		const {width, height} = cameraParams;
+-		const orientedImages = [];
+-		const sceneNode = new THREE.Object3D();
+-		sceneNode.name = "oriented_images";
+-
+-		for(const params of imageParams){
+-
+-			// const material = createMaterial();
+-			// const lm = new THREE.LineBasicMaterial( { color: 0x00ff00 } );
+-			// const mesh = new THREE.Mesh(sp, material);
+-
+-			const {x, y, z, omega, phi, kappa} = params;
+-			// const [rx, ry, rz] = [omega, phi, kappa]
+-			// 	.map(THREE.Math.degToRad);
+-			
+-			// mesh.position.set(x, y, z);
+-			// mesh.scale.set(width / height, 1, 1);
+-			// mesh.rotation.set(rx, ry, rz);
+-			// {
+-			// 	mesh.updateMatrixWorld();
+-			// 	const dir = mesh.getWorldDirection();
+-			// 	const alpha = THREE.Math.degToRad(cameraParams.fov / 2);
+-			// 	const d = -0.5 / Math.tan(alpha);
+-			// 	const move = dir.clone().multiplyScalar(d);
+-			// 	mesh.position.add(move);
+-			// }
+-			// sceneNode.add(mesh);
+-
+-			// const line = new THREE.Line(lg, lm);
+-			// line.position.copy(mesh.position);
+-			// line.scale.copy(mesh.scale);
+-			// line.rotation.copy(mesh.rotation);
+-			// sceneNode.add(line);
+-
+-			let orientedImage = new OrientedImage(params.id);
+-			// orientedImage.setPosition(x, y, z);
+-			// orientedImage.setRotation(omega, phi, kappa);
+-			// orientedImage.setDimension(width, height);
+-			let position = [x, y, z];
+-			let rotation = [omega, phi, kappa];
+-			let dimension = [width, height];
+-			orientedImage.set(position, rotation, dimension, cameraParams.fov);
+-
+-			sceneNode.add(orientedImage.mesh);
+-			sceneNode.add(orientedImage.line);
+-			
+-			orientedImages.push(orientedImage);
+-		}
+-
+-		let hoveredElement = null;
+-		let clipVolume = null;
+-
+-		const onMouseMove = (evt) => {
+-			const tStart = performance.now();
+-			if(hoveredElement){
+-				hoveredElement.line.material.color.setRGB(0, 1, 0);
+-			}
+-			evt.preventDefault();
+-
+-			//var array = getMousePosition( container, evt.clientX, evt.clientY );
+-			const rect = viewer.renderer.domElement.getBoundingClientRect();
+-			const [x, y] = [evt.clientX, evt.clientY];
+-			const array = [ 
+-				( x - rect.left ) / rect.width, 
+-				( y - rect.top ) / rect.height 
+-			];
+-			const onClickPosition = new THREE.Vector2(...array);
+-			//const intersects = getIntersects(onClickPosition, scene.children);
+-			const camera = viewer.scene.getActiveCamera();
+-			const mouse = new THREE.Vector3(
+-				+ ( onClickPosition.x * 2 ) - 1, 
+-				- ( onClickPosition.y * 2 ) + 1 );
+-			const objects = orientedImages.map(i => i.mesh);
+-			raycaster.setFromCamera( mouse, camera );
+-			const intersects = raycaster.intersectObjects( objects );
+-			let selectionChanged = false;
+-
+-			if ( intersects.length > 0){
+-				//console.log(intersects);
+-				const intersection = intersects[0];
+-				const orientedImage = intersection.object.orientedImage;
+-				orientedImage.line.material.color.setRGB(1, 0, 0);
+-				selectionChanged = hoveredElement !== orientedImage;
+-				hoveredElement = orientedImage;
+-			}else{
+-				hoveredElement = null;
+-			}
+-
+-			let shouldRemoveClipVolume = clipVolume !== null && hoveredElement === null;
+-			let shouldAddClipVolume = clipVolume === null && hoveredElement !== null;
+-
+-			if(clipVolume !== null && (hoveredElement === null || selectionChanged)){
+-				// remove existing
+-				viewer.scene.removePolygonClipVolume(clipVolume);
+-				clipVolume = null;
+-			}
+-			
+-			if(shouldAddClipVolume || selectionChanged){
+-				const img = hoveredElement;
+-				const fov = cameraParams.fov;
+-				const aspect  = cameraParams.width / cameraParams.height;
+-				const near = 1.0;
+-				const far = 1000 * 1000;
+-				const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
+-				camera.rotation.order = viewer.scene.getActiveCamera().rotation.order;
+-				camera.rotation.copy(img.mesh.rotation);
+-				{
+-					const mesh = img.mesh;
+-					const dir = mesh.getWorldDirection();
+-					const pos = mesh.position;
+-					const alpha = THREE.Math.degToRad(fov / 2);
+-					const d = 0.5 / Math.tan(alpha);
+-					const newCamPos = pos.clone().add(dir.clone().multiplyScalar(d));
+-					const newCamDir = pos.clone().sub(newCamPos);
+-					const newCamTarget = new THREE.Vector3().addVectors(
+-						newCamPos,
+-						newCamDir.clone().multiplyScalar(viewer.getMoveSpeed()));
+-					camera.position.copy(newCamPos);
+-				}
+-				let volume = new Potree.PolygonClipVolume(camera);
+-				let m0 = new THREE.Mesh();
+-				let m1 = new THREE.Mesh();
+-				let m2 = new THREE.Mesh();
+-				let m3 = new THREE.Mesh();
+-				m0.position.set(-1, -1, 0);
+-				m1.position.set( 1, -1, 0);
+-				m2.position.set( 1,  1, 0);
+-				m3.position.set(-1,  1, 0);
+-				volume.markers.push(m0, m1, m2, m3);
+-				volume.initialized = true;
+-				
+-				viewer.scene.addPolygonClipVolume(volume);
+-				clipVolume = volume;
+-			}
+-			const tEnd = performance.now();
+-			//console.log(tEnd - tStart);
+-		};
+-
+-		const moveToImage = (image) => {
+-			console.log("move to image " + image.id);
+-
+-			const mesh = image.mesh;
+-			const newCamPos = image.position.clone();
+-			const newCamTarget = mesh.position.clone();
+-
+-			viewer.scene.view.setView(newCamPos, newCamTarget, 500, () => {
+-				orientedImageControls.capture(image);
+-			});
+-
+-			if(image.texture === null){
+-
+-				const target = image;
+-
+-				const tmpImagePath = `${Potree.resourcePath}/images/loading.jpg`;
+-				new THREE.TextureLoader().load(tmpImagePath,
+-					(texture) => {
+-						if(target.texture === null){
+-							target.texture = texture;
+-							target.mesh.material.uniforms.tColor.value = texture;
+-							mesh.material.needsUpdate = true;
+-						}
+-					}
+-				);
+-
+-				const imagePath = `${imageParamsPath}/../${target.id}`;
+-				new THREE.TextureLoader().load(imagePath,
+-					(texture) => {
+-						target.texture = texture;
+-						target.mesh.material.uniforms.tColor.value = texture;
+-						mesh.material.needsUpdate = true;
+-					}
+-				);
+-				
+-
+-			}
+-		};
+-
+-		const onMouseClick = (evt) => {
+-
+-			if(orientedImageControls.hasSomethingCaptured()){
+-				return;
+-			}
+-
+-			if(hoveredElement){
+-				moveToImage(hoveredElement);
+-			}
+-		};
+-		viewer.renderer.domElement.addEventListener( 'mousemove', onMouseMove, false );
+-		viewer.renderer.domElement.addEventListener( 'mousedown', onMouseClick, false );
+-
+-		viewer.addEventListener("update", () => {
+-
+-			for(const image of orientedImages){
+-				const world = image.mesh.matrixWorld;
+-				const {width, height} = image;
+-				const aspect = width / height;
+-
+-				const camera = viewer.scene.getActiveCamera();
+-
+-				const imgPos = image.mesh.getWorldPosition(new THREE.Vector3());
+-				const camPos = camera.position;
+-				const d = camPos.distanceTo(imgPos);
+-
+-				const minSize = 1; // in degrees of fov
+-				const a = THREE.Math.degToRad(minSize);
+-				let r = d * Math.tan(a);
+-				r = Math.max(r, 1);
+-
+-
+-				image.mesh.scale.set(r * aspect, r, 1);
+-				image.line.scale.set(r * aspect, r, 1);
+-
+-				image.mesh.material.uniforms.uNear.value = camera.near;
+-
+-			}
+-
+-		});
+-
+-		const images = new OrientedImages();
+-		images.node = sceneNode;
+-		images.cameraParamsPath = cameraParamsPath;
+-		images.imageParamsPath = imageParamsPath;
+-		images.cameraParams = cameraParams;
+-		images.imageParams = imageParams;
+-		images.images = orientedImages;
+-
+-		Potree.debug.moveToImage = moveToImage;
+-
+-		return images;
+-	}
++export class OrientedImages extends EventDispatcher {
++  constructor() {
++    super();
++
++    this.node = null;
++    this.cameraParams = null;
++    this.imageParams = null;
++    this.images = null;
++    this._visible = true;
++    this.focused = null;
++  }
++
++  set visible(visible) {
++    if (this._visible === visible) {
++      return;
++    }
++
++    for (const image of this.images) {
++      image.mesh.visible = visible;
++      image.line.visible = visible;
++    }
++
++    this._visible = visible;
++    this.dispatchEvent({
++      type: "visibility_changed",
++      images: this,
++    });
++  }
++
++  get visible() {
++    return this._visible;
++  }
+ }
+ 
++export class OrientedImageLoader {
++  static async loadCameraParams(path) {
++    const res = await fetch(path);
++    const text = await res.text();
++
++    const parser = new DOMParser();
++    const doc = parser.parseFromString(text, "application/xml");
++
++    const width = parseInt(doc.getElementsByTagName("width")[0].textContent);
++    const height = parseInt(doc.getElementsByTagName("height")[0].textContent);
++    const f = parseFloat(doc.getElementsByTagName("f")[0].textContent);
++
++    let a = height / 2 / f;
++    let fov = 2 * THREE.Math.radToDeg(Math.atan(a));
++
++    const params = {
++      path: path,
++      width: width,
++      height: height,
++      f: f,
++      fov: fov,
++    };
++
++    return params;
++  }
++
++  static async loadImageParams(path, tm) {
++    const response = await fetch(path);
++    if (!response.ok) {
++      console.error(`failed to load ${path}`);
++      return;
++    }
++
++    const content = await response.text();
++
++    const imageParams = [];
++
++    const imgData = JSON.parse(content);
++
++    imgData.camname.forEach((imgName, index) => {
++      const rawPos = new THREE.Vector4(
++        Number.parseFloat(imgData.camX[index]),
++        Number.parseFloat(imgData.camY[index]),
++        Number.parseFloat(imgData.camZ[index]),
++        1
++      );
++      rawPos.applyMatrix4(tm);
++
++      const params = {
++        id: imgData.camname[index],
++        x: Number.parseFloat(imgData.camX[index]),
++        y: Number.parseFloat(imgData.camY[index]),
++        z: Number.parseFloat(imgData.camZ[index]),
++        x_tm: rawPos.x,
++        y_tm: rawPos.y,
++        z_tm: rawPos.z,
++        omega: Number.parseFloat(imgData.camRoll[index]),
++        phi: Number.parseFloat(imgData.camPitch[index]),
++        kappa: Number.parseFloat(imgData.camYaw[index]),
++      };
++
++      imageParams.push(params);
++    });
++
++    const width = parseInt(imgData.camPix[0]);
++    const height = parseInt(imgData.camPix[1]);
++    const f = parseFloat(imgData.camFocal);
++
++    let a = height / 2 / f;
++    let fov = 2 * THREE.Math.radToDeg(Math.atan(a));
++
++    const params = {
++      path: path,
++      width: width,
++      height: height,
++      f: f,
++      fov: fov,
++    };
++
++    return [params, imageParams];
++  }
++
++  static async load(imageParamsPath, imagesPath, viewer, tm_data) {
++    const tStart = performance.now();
++
++    let tmatrix, toffset;
++
++    tmatrix = tm_data.tm;
++    toffset = tm_data.offset;
++
++    const [cameraParams, imageParams] =
++      await OrientedImageLoader.loadImageParams(imageParamsPath, tmatrix);
++
++    const orientedImageControls = new OrientedImageControls(viewer);
++    const raycaster = new THREE.Raycaster();
++
++    const tEnd = performance.now();
++    console.log(tEnd - tStart);
++
++    const { width, height } = cameraParams;
++    const orientedImages = [];
++    const sceneNode = new THREE.Object3D();
++    sceneNode.name = "oriented_images";
++
++    for (const params of imageParams) {
++      const { x, y, z, x_tm, y_tm, z_tm, omega, phi, kappa } = params;
++      let orientedImage = new OrientedImage(params.id);
++      let position = [x, y, z];
++      let rotation = [omega, phi, kappa];
++      let dimension = [width, height];
++      orientedImage.set(position, rotation, dimension, cameraParams.fov);
++      orientedImage.mesh.applyMatrix4(tmatrix);
++      let curMeshPos = orientedImage.mesh.position.clone();
++      orientedImage.mesh.position.set(
++        curMeshPos.x - toffset[0],
++        curMeshPos.y - toffset[1],
++        curMeshPos.z - toffset[2]
++      );
++      orientedImage.line.applyMatrix4(tmatrix);
++      let curLinePos = orientedImage.line.position.clone();
++      orientedImage.line.position.set(
++        curLinePos.x - toffset[0],
++        curLinePos.y - toffset[1],
++        curLinePos.z - toffset[2]
++      );
++      orientedImage.position.set(
++        x_tm - toffset[0],
++        y_tm - toffset[1],
++        z_tm - toffset[2]
++      );
++      sceneNode.add(orientedImage.mesh);
++      sceneNode.add(orientedImage.line);
++
++      orientedImages.push(orientedImage);
++    }
++
++    let hoveredElement = null;
++    let clipVolume = null;
++
++    const images = new OrientedImages();
++    images.node = sceneNode;
++    images.imageParamsPath = imageParamsPath;
++    images.cameraParams = cameraParams;
++    images.imageParams = imageParams;
++    images.images = orientedImages;
++    images.hovered = hoveredElement;
++
++    const onMouseMove = (evt) => {
++      const tStart = performance.now();
++      if (hoveredElement) {
++        hoveredElement.line.material.color.setRGB(0, 1, 0);
++      }
++      evt.preventDefault();
++      if (images.visible) {
++        const rect = viewer.renderer.domElement.getBoundingClientRect();
++        const [x, y] = [evt.clientX, evt.clientY];
++        const array = [
++          (x - rect.left) / rect.width,
++          (y - rect.top) / rect.height,
++        ];
++        const onClickPosition = new THREE.Vector2(...array);
++        const camera = viewer.scene.getActiveCamera();
++        const mouse = new THREE.Vector3(
++          +(onClickPosition.x * 2) - 1,
++          -(onClickPosition.y * 2) + 1
++        );
++        const objects = orientedImages.map((i) => i.mesh);
++        raycaster.setFromCamera(mouse, camera);
++        const intersects = raycaster.intersectObjects(objects);
++        let selectionChanged = false;
++
++        if (intersects.length > 0) {
++          const intersection = intersects[0];
++          const orientedImage = intersection.object.orientedImage;
++          orientedImage.line.material.color.setRGB(1, 0, 0);
++          selectionChanged = hoveredElement !== orientedImage;
++          hoveredElement = orientedImage;
++        } else {
++          hoveredElement = null;
++        }
++
++        let shouldRemoveClipVolume =
++          clipVolume !== null && hoveredElement === null;
++        let shouldAddClipVolume =
++          clipVolume === null && hoveredElement !== null;
++
++        if (
++          clipVolume !== null &&
++          (hoveredElement === null || selectionChanged)
++        ) {
++          // remove existing
++          viewer.scene.removePolygonClipVolume(clipVolume);
++          clipVolume = null;
++        }
++
++        if (shouldAddClipVolume || selectionChanged) {
++          const img = hoveredElement;
++          const fov = cameraParams.fov;
++          const aspect = cameraParams.width / cameraParams.height;
++          const near = 1.0;
++          const far = 1000 * 1000;
++          const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
++          camera.rotation.order = viewer.scene.getActiveCamera().rotation.order;
++          camera.rotation.copy(img.mesh.rotation);
++          {
++            const mesh = img.mesh;
++            const dir = mesh.getWorldDirection();
++            const pos = mesh.position;
++            const alpha = THREE.Math.degToRad(fov / 2);
++            const d = 0.5 / Math.tan(alpha);
++            const newCamPos = pos.clone().add(dir.clone().multiplyScalar(d));
++            const newCamDir = pos.clone().sub(newCamPos);
++            const newCamTarget = new THREE.Vector3().addVectors(
++              newCamPos,
++              newCamDir.clone().multiplyScalar(viewer.getMoveSpeed())
++            );
++            camera.position.copy(newCamPos);
++          }
++          let volume = new Potree.PolygonClipVolume(camera);
++          let m0 = new THREE.Mesh();
++          let m1 = new THREE.Mesh();
++          let m2 = new THREE.Mesh();
++          let m3 = new THREE.Mesh();
++          m0.position.set(-1, -1, 0);
++          m1.position.set(1, -1, 0);
++          m2.position.set(1, 1, 0);
++          m3.position.set(-1, 1, 0);
++          volume.markers.push(m0, m1, m2, m3);
++          volume.initialized = true;
++
++          viewer.scene.addPolygonClipVolume(volume);
++          clipVolume = volume;
++        }
++        const tEnd = performance.now();
++        //console.log(tEnd - tStart);
++      } else {
++        hoveredElement = null;
++        if (clipVolume) {
++          viewer.scene.removePolygonClipVolume(clipVolume);
++          clipVolume = null;
++        }
++      }
++    };
++
++    const moveToImage = async (image, sendEvent = true) => {
++      viewer.controls.enabled = false;
++
++      if (sendEvent) {
++        const event = new CustomEvent("imageLoad", {
++          detail: {
++            viewer: viewer.canvasId,
++            image,
++          },
++        });
++        document.dispatchEvent(event);
++      }
++
++      const mesh = image.mesh;
++      const target = image;
++
++      const newCamPos = image.position.clone();
++      const newCamTarget = mesh.position.clone();
++
++      viewer.scene.view.setView(newCamPos, newCamTarget);
++
++      function loadImageTexture(path) {
++        return new Promise((resolve, reject) => {
++          new THREE.TextureLoader().load(path, (texture) => {
++            resolve(texture);
++          });
++        });
++      }
++
++      function updateTexture(texture) {
++        target.texture = texture;
++        target.mesh.material.uniforms.tColor.value = texture;
++        mesh.material.needsUpdate = true;
++      }
++
++      viewer.scene.orientedImages[0].focused = image;
++      const tmpImagePath = `${imagesPath}/thumbnails/${target.id}`;
++      let texture = await loadImageTexture(tmpImagePath);
++      updateTexture(texture);
++      setTimeout(() => {
++        orientedImageControls.capture(image);
++      }, 100);
++      const imagePath = `${imagesPath}/${target.id}`;
++      let texture_org = await loadImageTexture(imagePath);
++      updateTexture(texture_org);
++      image.texture = texture_org;
++    };
++
++    const onMouseClick = (evt) => {
++      if (orientedImageControls.hasSomethingCaptured()) {
++        return;
++      }
++
++      if (hoveredElement) {
++        moveToImage(hoveredElement);
++      }
++    };
++    viewer.renderer.domElement.addEventListener(
++      "mousemove",
++      onMouseMove,
++      false
++    );
++    viewer.renderer.domElement.addEventListener(
++      "mousedown",
++      onMouseClick,
++      false
++    );
++
++    viewer.addEventListener("update", () => {
++      for (const image of orientedImages) {
++        const world = image.mesh.matrixWorld;
++        const { width, height } = image;
++        const aspect = width / height;
++
++        const camera = viewer.scene.getActiveCamera();
++
++        const imgPos = image.mesh.getWorldPosition(new THREE.Vector3());
++        const camPos = camera.position;
++        const d = camPos.distanceTo(imgPos);
++
++        const minSize = 1; // in degrees of fov
++        const a = THREE.Math.degToRad(minSize);
++        let r = d * Math.tan(a);
++        r = Math.max(r, 1);
++
++        image.mesh.scale.set(r * aspect, r, 1);
++        image.line.scale.set(r * aspect, r, 1);
++
++        image.mesh.material.uniforms.uNear.value = camera.near;
++      }
++    });
++
++    images.moveToImage = moveToImage;
++    images.release = function () {
++      orientedImageControls.release();
++    };
++    return images;
++  }
++}
+diff --git a/src/navigation/OrbitControls.js b/src/navigation/OrbitControls.js
+index 520a11b3..1d21da93 100644
+--- a/src/navigation/OrbitControls.js
++++ b/src/navigation/OrbitControls.js
+@@ -14,281 +14,317 @@
+  */
+ 
+ import * as THREE from "../../libs/three.js/build/three.module.js";
+-import {MOUSE} from "../defines.js";
+-import {Utils} from "../utils.js";
+-import {EventDispatcher} from "../EventDispatcher.js";
+-
+- 
+-export class OrbitControls extends EventDispatcher{
+-	
+-	constructor(viewer){
+-		super();
+-		
+-		this.viewer = viewer;
+-		this.renderer = viewer.renderer;
++import { MOUSE } from "../defines.js";
++import { Utils } from "../utils.js";
++import { EventDispatcher } from "../EventDispatcher.js";
+ 
+-		this.scene = null;
+-		this.sceneControls = new THREE.Scene();
+-
+-		this.rotationSpeed = 5;
++export class OrbitControls extends EventDispatcher {
++  constructor(viewer) {
++    super();
+ 
+-		this.fadeFactor = 20;
+-		this.yawDelta = 0;
+-		this.pitchDelta = 0;
+-		this.panDelta = new THREE.Vector2(0, 0);
+-		this.radiusDelta = 0;
++    this.viewer = viewer;
++    this.renderer = viewer.renderer;
+ 
+-		this.doubleClockZoomEnabled = true;
++    this.scene = null;
++    this.sceneControls = new THREE.Scene();
+ 
+-		this.tweens = [];
++    this.rotationSpeed = 5;
+ 
+-		let drag = (e) => {
+-			if (e.drag.object !== null) {
+-				return;
+-			}
+-
+-			if (e.drag.startHandled === undefined) {
+-				e.drag.startHandled = true;
+-
+-				this.dispatchEvent({type: 'start'});
+-			}
+-
+-			let ndrag = {
+-				x: e.drag.lastDrag.x / this.renderer.domElement.clientWidth,
+-				y: e.drag.lastDrag.y / this.renderer.domElement.clientHeight
+-			};
+-
+-			if (e.drag.mouse === MOUSE.LEFT) {
+-				this.yawDelta += ndrag.x * this.rotationSpeed;
+-				this.pitchDelta += ndrag.y * this.rotationSpeed;
+-
+-				this.stopTweens();
+-			} else if (e.drag.mouse === MOUSE.RIGHT) {
+-				this.panDelta.x += ndrag.x;
+-				this.panDelta.y += ndrag.y;
+-
+-				this.stopTweens();
+-			}
+-		};
+-
+-		let drop = e => {
+-			this.dispatchEvent({type: 'end'});
+-		};
+-
+-		let scroll = (e) => {
+-			let resolvedRadius = this.scene.view.radius + this.radiusDelta;
+-
+-			this.radiusDelta += -e.delta * resolvedRadius * 0.1;
+-
+-			this.stopTweens();
+-		};
+-
+-		let dblclick = (e) => {
+-			if(this.doubleClockZoomEnabled){
+-				this.zoomToLocation(e.mouse);
+-			}
+-		};
+-
+-		let previousTouch = null;
+-		let touchStart = e => {
+-			previousTouch = e;
+-		};
+-
+-		let touchEnd = e => {
+-			previousTouch = e;
+-		};
+-
+-		let touchMove = e => {
+-			if (e.touches.length === 2 && previousTouch.touches.length === 2){
+-				let prev = previousTouch;
+-				let curr = e;
+-
+-				let prevDX = prev.touches[0].pageX - prev.touches[1].pageX;
+-				let prevDY = prev.touches[0].pageY - prev.touches[1].pageY;
+-				let prevDist = Math.sqrt(prevDX * prevDX + prevDY * prevDY);
+-
+-				let currDX = curr.touches[0].pageX - curr.touches[1].pageX;
+-				let currDY = curr.touches[0].pageY - curr.touches[1].pageY;
+-				let currDist = Math.sqrt(currDX * currDX + currDY * currDY);
+-
+-				let delta = currDist / prevDist;
+-				let resolvedRadius = this.scene.view.radius + this.radiusDelta;
+-				let newRadius = resolvedRadius / delta;
+-				this.radiusDelta = newRadius - resolvedRadius;
+-
+-				this.stopTweens();
+-			}else if(e.touches.length === 3 && previousTouch.touches.length === 3){
+-				let prev = previousTouch;
+-				let curr = e;
+-
+-				let prevMeanX = (prev.touches[0].pageX + prev.touches[1].pageX + prev.touches[2].pageX) / 3;
+-				let prevMeanY = (prev.touches[0].pageY + prev.touches[1].pageY + prev.touches[2].pageY) / 3;
+-
+-				let currMeanX = (curr.touches[0].pageX + curr.touches[1].pageX + curr.touches[2].pageX) / 3;
+-				let currMeanY = (curr.touches[0].pageY + curr.touches[1].pageY + curr.touches[2].pageY) / 3;
+-
+-				let delta = {
+-					x: (currMeanX - prevMeanX) / this.renderer.domElement.clientWidth,
+-					y: (currMeanY - prevMeanY) / this.renderer.domElement.clientHeight
+-				};
+-
+-				this.panDelta.x += delta.x;
+-				this.panDelta.y += delta.y;
+-
+-				this.stopTweens();
+-			}
+-
+-			previousTouch = e;
+-		};
+-
+-		this.addEventListener('touchstart', touchStart);
+-		this.addEventListener('touchend', touchEnd);
+-		this.addEventListener('touchmove', touchMove);
+-		this.addEventListener('drag', drag);
+-		this.addEventListener('drop', drop);
+-		this.addEventListener('mousewheel', scroll);
+-		this.addEventListener('dblclick', dblclick);
+-	}
+-
+-	setScene (scene) {
+-		this.scene = scene;
+-	}
+-
+-	stop(){
+-		this.yawDelta = 0;
+-		this.pitchDelta = 0;
+-		this.radiusDelta = 0;
+-		this.panDelta.set(0, 0);
+-	}
+-	
+-	zoomToLocation(mouse){
+-		let camera = this.scene.getActiveCamera();
+-		
+-		let I = Utils.getMousePointCloudIntersection(
+-			mouse,
+-			camera,
+-			this.viewer,
+-			this.scene.pointclouds,
+-			{pickClipped: true});
+-
+-		if (I === null) {
+-			return;
+-		}
+-
+-		let targetRadius = 0;
+-		{
+-			let minimumJumpDistance = 0.2;
+-
+-			let domElement = this.renderer.domElement;
+-			let ray = Utils.mouseToRay(mouse, camera, domElement.clientWidth, domElement.clientHeight);
+-
+-			let nodes = I.pointcloud.nodesOnRay(I.pointcloud.visibleNodes, ray);
+-			let lastNode = nodes[nodes.length - 1];
+-			let radius = lastNode.getBoundingSphere(new THREE.Sphere()).radius;
+-			targetRadius = Math.min(this.scene.view.radius, radius);
+-			targetRadius = Math.max(minimumJumpDistance, targetRadius);
+-		}
+-
+-		let d = this.scene.view.direction.multiplyScalar(-1);
+-		let cameraTargetPosition = new THREE.Vector3().addVectors(I.location, d.multiplyScalar(targetRadius));
+-		// TODO Unused: let controlsTargetPosition = I.location;
+-
+-		let animationDuration = 600;
+-		let easing = TWEEN.Easing.Quartic.Out;
+-
+-		{ // animate
+-			let value = {x: 0};
+-			let tween = new TWEEN.Tween(value).to({x: 1}, animationDuration);
+-			tween.easing(easing);
+-			this.tweens.push(tween);
+-
+-			let startPos = this.scene.view.position.clone();
+-			let targetPos = cameraTargetPosition.clone();
+-			let startRadius = this.scene.view.radius;
+-			let targetRadius = cameraTargetPosition.distanceTo(I.location);
+-
+-			tween.onUpdate(() => {
+-				let t = value.x;
+-				this.scene.view.position.x = (1 - t) * startPos.x + t * targetPos.x;
+-				this.scene.view.position.y = (1 - t) * startPos.y + t * targetPos.y;
+-				this.scene.view.position.z = (1 - t) * startPos.z + t * targetPos.z;
+-
+-				this.scene.view.radius = (1 - t) * startRadius + t * targetRadius;
+-				this.viewer.setMoveSpeed(this.scene.view.radius);
+-			});
+-
+-			tween.onComplete(() => {
+-				this.tweens = this.tweens.filter(e => e !== tween);
+-			});
+-
+-			tween.start();
+-		}
+-	}
+-
+-	stopTweens () {
+-		this.tweens.forEach(e => e.stop());
+-		this.tweens = [];
+-	}
+-
+-	update (delta) {
+-		let view = this.scene.view;
+-
+-		{ // apply rotation
+-			let progression = Math.min(1, this.fadeFactor * delta);
+-
+-			let yaw = view.yaw;
+-			let pitch = view.pitch;
+-			let pivot = view.getPivot();
+-
+-			yaw -= progression * this.yawDelta;
+-			pitch -= progression * this.pitchDelta;
+-
+-			view.yaw = yaw;
+-			view.pitch = pitch;
+-
+-			let V = this.scene.view.direction.multiplyScalar(-view.radius);
+-			let position = new THREE.Vector3().addVectors(pivot, V);
+-
+-			view.position.copy(position);
+-		}
+-
+-		{ // apply pan
+-			let progression = Math.min(1, this.fadeFactor * delta);
+-			let panDistance = progression * view.radius * 3;
+-
+-			let px = -this.panDelta.x * panDistance;
+-			let py = this.panDelta.y * panDistance;
+-
+-			view.pan(px, py);
+-		}
+-
+-		{ // apply zoom
+-			let progression = Math.min(1, this.fadeFactor * delta);
+-
+-			// let radius = view.radius + progression * this.radiusDelta * view.radius * 0.1;
+-			let radius = view.radius + progression * this.radiusDelta;
+-
+-			let V = view.direction.multiplyScalar(-radius);
+-			let position = new THREE.Vector3().addVectors(view.getPivot(), V);
+-			view.radius = radius;
+-
+-			view.position.copy(position);
+-		}
++    this.fadeFactor = 20;
++    this.yawDelta = 0;
++    this.pitchDelta = 0;
++    this.panDelta = new THREE.Vector2(0, 0);
++    this.radiusDelta = 0;
+ 
+-		{
+-			let speed = view.radius;
+-			this.viewer.setMoveSpeed(speed);
+-		}
+-
+-		{ // decelerate over time
+-			let progression = Math.min(1, this.fadeFactor * delta);
+-			let attenuation = Math.max(0, 1 - this.fadeFactor * delta);
+-
+-			this.yawDelta *= attenuation;
+-			this.pitchDelta *= attenuation;
+-			this.panDelta.multiplyScalar(attenuation);
+-			// this.radiusDelta *= attenuation;
+-			this.radiusDelta -= progression * this.radiusDelta;
+-		}
+-	}
+-};
++    this.doubleClockZoomEnabled = true;
++
++    this.tweens = [];
++
++    this.changeEvent = new CustomEvent("camerachange");
++
++    let drag = (e) => {
++      if (e.drag.object !== null) {
++        return;
++      }
++
++      if (e.drag.startHandled === undefined) {
++        e.drag.startHandled = true;
++
++        this.dispatchEvent({ type: "start" });
++      }
++
++      let ndrag = {
++        x: e.drag.lastDrag.x / this.renderer.domElement.clientWidth,
++        y: e.drag.lastDrag.y / this.renderer.domElement.clientHeight,
++      };
++
++      if (e.drag.mouse === MOUSE.LEFT) {
++        this.yawDelta += ndrag.x * this.rotationSpeed;
++        this.pitchDelta += ndrag.y * this.rotationSpeed;
++
++        this.stopTweens();
++      } else if (e.drag.mouse === MOUSE.RIGHT) {
++        this.panDelta.x += ndrag.x;
++        this.panDelta.y += ndrag.y;
++
++        this.stopTweens();
++      }
++
++      document.dispatchEvent(this.changeEvent);
++    };
++
++    let drop = (e) => {
++      this.dispatchEvent({ type: "end" });
++      document.dispatchEvent(this.changeEvent);
++    };
++
++    let scroll = (e) => {
++      let resolvedRadius = this.scene.view.radius + this.radiusDelta;
++
++      this.radiusDelta += -e.delta * resolvedRadius * 0.1;
++
++      this.stopTweens();
++      document.dispatchEvent(this.changeEvent);
++    };
++
++    let dblclick = (e) => {
++      if (this.doubleClockZoomEnabled) {
++        this.zoomToLocation(e.mouse);
++      }
++    };
++
++    let previousTouch = null;
++    let touchStart = (e) => {
++      previousTouch = e;
++    };
++
++    let touchEnd = (e) => {
++      previousTouch = e;
++    };
++
++    let touchMove = (e) => {
++      if (e.touches.length === 2 && previousTouch.touches.length === 2) {
++        let prev = previousTouch;
++        let curr = e;
++
++        let prevDX = prev.touches[0].pageX - prev.touches[1].pageX;
++        let prevDY = prev.touches[0].pageY - prev.touches[1].pageY;
++        let prevDist = Math.sqrt(prevDX * prevDX + prevDY * prevDY);
++
++        let currDX = curr.touches[0].pageX - curr.touches[1].pageX;
++        let currDY = curr.touches[0].pageY - curr.touches[1].pageY;
++        let currDist = Math.sqrt(currDX * currDX + currDY * currDY);
++
++        let delta = currDist / prevDist;
++        let resolvedRadius = this.scene.view.radius + this.radiusDelta;
++        let newRadius = resolvedRadius / delta;
++        this.radiusDelta = newRadius - resolvedRadius;
++
++        this.stopTweens();
++      } else if (e.touches.length === 3 && previousTouch.touches.length === 3) {
++        let prev = previousTouch;
++        let curr = e;
++
++        let prevMeanX =
++          (prev.touches[0].pageX +
++            prev.touches[1].pageX +
++            prev.touches[2].pageX) /
++          3;
++        let prevMeanY =
++          (prev.touches[0].pageY +
++            prev.touches[1].pageY +
++            prev.touches[2].pageY) /
++          3;
++
++        let currMeanX =
++          (curr.touches[0].pageX +
++            curr.touches[1].pageX +
++            curr.touches[2].pageX) /
++          3;
++        let currMeanY =
++          (curr.touches[0].pageY +
++            curr.touches[1].pageY +
++            curr.touches[2].pageY) /
++          3;
++
++        let delta = {
++          x: (currMeanX - prevMeanX) / this.renderer.domElement.clientWidth,
++          y: (currMeanY - prevMeanY) / this.renderer.domElement.clientHeight,
++        };
++
++        this.panDelta.x += delta.x;
++        this.panDelta.y += delta.y;
++
++        this.stopTweens();
++      }
++
++      previousTouch = e;
++    };
++
++    this.addEventListener("touchstart", touchStart);
++    this.addEventListener("touchend", touchEnd);
++    this.addEventListener("touchmove", touchMove);
++    this.addEventListener("drag", drag);
++    this.addEventListener("drop", drop);
++    this.addEventListener("mousewheel", scroll);
++    this.addEventListener("dblclick", dblclick);
++  }
++
++  setScene(scene) {
++    this.scene = scene;
++  }
++
++  stop() {
++    this.yawDelta = 0;
++    this.pitchDelta = 0;
++    this.radiusDelta = 0;
++    this.panDelta.set(0, 0);
++  }
++
++  zoomToLocation(mouse) {
++    let camera = this.scene.getActiveCamera();
++
++    let I = Utils.getMousePointCloudIntersection(
++      mouse,
++      camera,
++      this.viewer,
++      this.scene.pointclouds,
++      { pickClipped: true }
++    );
++
++    if (I === null) {
++      return;
++    }
++
++    let targetRadius = 0;
++    {
++      let minimumJumpDistance = 0.2;
++
++      let domElement = this.renderer.domElement;
++      let ray = Utils.mouseToRay(
++        mouse,
++        camera,
++        domElement.clientWidth,
++        domElement.clientHeight
++      );
++
++      let nodes = I.pointcloud.nodesOnRay(I.pointcloud.visibleNodes, ray);
++      let lastNode = nodes[nodes.length - 1];
++      let radius = lastNode.getBoundingSphere(new THREE.Sphere()).radius;
++      targetRadius = Math.min(this.scene.view.radius, radius);
++      targetRadius = Math.max(minimumJumpDistance, targetRadius);
++    }
++
++    let d = this.scene.view.direction.multiplyScalar(-1);
++    let cameraTargetPosition = new THREE.Vector3().addVectors(
++      I.location,
++      d.multiplyScalar(targetRadius)
++    );
++    // TODO Unused: let controlsTargetPosition = I.location;
++
++    let animationDuration = 600;
++    let easing = TWEEN.Easing.Quartic.Out;
++
++    {
++      // animate
++      let value = { x: 0 };
++      let tween = new TWEEN.Tween(value).to({ x: 1 }, animationDuration);
++      tween.easing(easing);
++      this.tweens.push(tween);
++
++      let startPos = this.scene.view.position.clone();
++      let targetPos = cameraTargetPosition.clone();
++      let startRadius = this.scene.view.radius;
++      let targetRadius = cameraTargetPosition.distanceTo(I.location);
++
++      tween.onUpdate(() => {
++        let t = value.x;
++        this.scene.view.position.x = (1 - t) * startPos.x + t * targetPos.x;
++        this.scene.view.position.y = (1 - t) * startPos.y + t * targetPos.y;
++        this.scene.view.position.z = (1 - t) * startPos.z + t * targetPos.z;
++
++        this.scene.view.radius = (1 - t) * startRadius + t * targetRadius;
++        this.viewer.setMoveSpeed(this.scene.view.radius);
++        document.dispatchEvent(this.changeEvent);
++      });
++
++      tween.onComplete(() => {
++        this.tweens = this.tweens.filter((e) => e !== tween);
++        document.dispatchEvent(this.changeEvent);
++      });
++
++      tween.start();
++    }
++  }
++
++  stopTweens() {
++    this.tweens.forEach((e) => e.stop());
++    this.tweens = [];
++  }
++
++  update(delta) {
++    let view = this.scene.view;
++
++    {
++      // apply rotation
++      let progression = Math.min(1, this.fadeFactor * delta);
++
++      let yaw = view.yaw;
++      let pitch = view.pitch;
++      let pivot = view.getPivot();
++
++      yaw -= progression * this.yawDelta;
++      pitch -= progression * this.pitchDelta;
++
++      view.yaw = yaw;
++      view.pitch = pitch;
++
++      let V = this.scene.view.direction.multiplyScalar(-view.radius);
++      let position = new THREE.Vector3().addVectors(pivot, V);
++
++      view.position.copy(position);
++    }
++
++    {
++      // apply pan
++      let progression = Math.min(1, this.fadeFactor * delta);
++      let panDistance = progression * view.radius * 3;
++
++      let px = -this.panDelta.x * panDistance;
++      let py = this.panDelta.y * panDistance;
++
++      view.pan(px, py);
++    }
++
++    {
++      // apply zoom
++      let progression = Math.min(1, this.fadeFactor * delta);
++
++      // let radius = view.radius + progression * this.radiusDelta * view.radius * 0.1;
++      let radius = view.radius + progression * this.radiusDelta;
++
++      let V = view.direction.multiplyScalar(-radius);
++      let position = new THREE.Vector3().addVectors(view.getPivot(), V);
++      view.radius = radius;
++
++      view.position.copy(position);
++    }
++
++    {
++      let speed = view.radius;
++      this.viewer.setMoveSpeed(speed);
++    }
++
++    {
++      // decelerate over time
++      let progression = Math.min(1, this.fadeFactor * delta);
++      let attenuation = Math.max(0, 1 - this.fadeFactor * delta);
++
++      this.yawDelta *= attenuation;
++      this.pitchDelta *= attenuation;
++      this.panDelta.multiplyScalar(attenuation);
++      // this.radiusDelta *= attenuation;
++      this.radiusDelta -= progression * this.radiusDelta;
++    }
++  }
++}
+diff --git a/src/viewer/Scene.js b/src/viewer/Scene.js
+index d0008ac8..f656bf6a 100644
+--- a/src/viewer/Scene.js
++++ b/src/viewer/Scene.js
+@@ -1,437 +1,450 @@
+-
+ import * as THREE from "../../libs/three.js/build/three.module.js";
+-import {Annotation} from "../Annotation.js";
+-import {CameraMode} from "../defines.js";
+-import {View} from "./View.js";
+-import {Utils} from "../utils.js";
+-import {EventDispatcher} from "../EventDispatcher.js";
+-
+-
+-export class Scene extends EventDispatcher{
+-
+-	constructor(){
+-		super();
+-
+-		this.annotations = new Annotation();
+-		
+-		this.scene = new THREE.Scene();
+-		this.sceneBG = new THREE.Scene();
+-		this.scenePointCloud = new THREE.Scene();
+-
+-		this.cameraP = new THREE.PerspectiveCamera(this.fov, 1, 0.1, 1000*1000);
+-		this.cameraO = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 1000*1000);
+-		this.cameraVR = new THREE.PerspectiveCamera();
+-		this.cameraBG = new THREE.Camera();
+-		this.cameraScreenSpace = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
+-		this.cameraMode = CameraMode.PERSPECTIVE;
+-		this.overrideCamera = null;
+-		this.pointclouds = [];
+-
+-		this.measurements = [];
+-		this.profiles = [];
+-		this.volumes = [];
+-		this.polygonClipVolumes = [];
+-		this.cameraAnimations = [];
+-		this.orientedImages = [];
+-		this.images360 = [];
+-		this.geopackages = [];
+-		
+-		this.fpControls = null;
+-		this.orbitControls = null;
+-		this.earthControls = null;
+-		this.geoControls = null;
+-		this.deviceControls = null;
+-		this.inputHandler = null;
+-
+-		this.view = new View();
+-
+-		this.directionalLight = null;
+-
+-		this.initialize();
+-	}
+-
+-	estimateHeightAt (position) {
+-		let height = null;
+-		let fromSpacing = Infinity;
+-
+-		for (let pointcloud of this.pointclouds) {
+-			if (pointcloud.root.geometryNode === undefined) {
+-				continue;
+-			}
+-
+-			let pHeight = null;
+-			let pFromSpacing = Infinity;
+-
+-			let lpos = position.clone().sub(pointcloud.position);
+-			lpos.z = 0;
+-			let ray = new THREE.Ray(lpos, new THREE.Vector3(0, 0, 1));
+-
+-			let stack = [pointcloud.root];
+-			while (stack.length > 0) {
+-				let node = stack.pop();
+-				let box = node.getBoundingBox();
+-
+-				let inside = ray.intersectBox(box);
+-
+-				if (!inside) {
+-					continue;
+-				}
+-
+-				let h = node.geometryNode.mean.z +
+-					pointcloud.position.z +
+-					node.geometryNode.boundingBox.min.z;
+-
+-				if (node.geometryNode.spacing <= pFromSpacing) {
+-					pHeight = h;
+-					pFromSpacing = node.geometryNode.spacing;
+-				}
+-
+-				for (let index of Object.keys(node.children)) {
+-					let child = node.children[index];
+-					if (child.geometryNode) {
+-						stack.push(node.children[index]);
+-					}
+-				}
+-			}
+-
+-			if (height === null || pFromSpacing < fromSpacing) {
+-				height = pHeight;
+-				fromSpacing = pFromSpacing;
+-			}
+-		}
+-
+-		return height;
+-	}
+-	
+-	getBoundingBox(pointclouds = this.pointclouds){
+-		let box = new THREE.Box3();
+-
+-		this.scenePointCloud.updateMatrixWorld(true);
+-		this.referenceFrame.updateMatrixWorld(true);
+-
+-		for (let pointcloud of pointclouds) {
+-			pointcloud.updateMatrixWorld(true);
+-
+-			let pointcloudBox = pointcloud.pcoGeometry.tightBoundingBox ? pointcloud.pcoGeometry.tightBoundingBox : pointcloud.boundingBox;
+-			let boxWorld = Utils.computeTransformedBoundingBox(pointcloudBox, pointcloud.matrixWorld);
+-			box.union(boxWorld);
+-		}
+-
+-		return box;
+-	}
+-
+-	addPointCloud (pointcloud) {
+-		this.pointclouds.push(pointcloud);
+-		this.scenePointCloud.add(pointcloud);
+-
+-		this.dispatchEvent({
+-			type: 'pointcloud_added',
+-			pointcloud: pointcloud
+-		});
+-	}
+-
+-	addVolume (volume) {
+-		this.volumes.push(volume);
+-		this.dispatchEvent({
+-			'type': 'volume_added',
+-			'scene': this,
+-			'volume': volume
+-		});
+-	}
+-
+-	addOrientedImages(images){
+-		this.orientedImages.push(images);
+-		this.scene.add(images.node);
+-
+-		this.dispatchEvent({
+-			'type': 'oriented_images_added',
+-			'scene': this,
+-			'images': images
+-		});
+-	};
+-
+-	removeOrientedImages(images){
+-		let index = this.orientedImages.indexOf(images);
+-		if (index > -1) {
+-			this.orientedImages.splice(index, 1);
+-
+-			this.dispatchEvent({
+-				'type': 'oriented_images_removed',
+-				'scene': this,
+-				'images': images
+-			});
+-		}
+-	};
+-
+-	add360Images(images){
+-		this.images360.push(images);
+-		this.scene.add(images.node);
+-
+-		this.dispatchEvent({
+-			'type': '360_images_added',
+-			'scene': this,
+-			'images': images
+-		});
+-	}
+-
+-	remove360Images(images){
+-		let index = this.images360.indexOf(images);
+-		if (index > -1) {
+-			this.images360.splice(index, 1);
+-
+-			this.dispatchEvent({
+-				'type': '360_images_removed',
+-				'scene': this,
+-				'images': images
+-			});
+-		}
+-	}
+-
+-	addGeopackage(geopackage){
+-		this.geopackages.push(geopackage);
+-		this.scene.add(geopackage.node);
+-
+-		this.dispatchEvent({
+-			'type': 'geopackage_added',
+-			'scene': this,
+-			'geopackage': geopackage
+-		});
+-	};
+-
+-	removeGeopackage(geopackage){
+-		let index = this.geopackages.indexOf(geopackage);
+-		if (index > -1) {
+-			this.geopackages.splice(index, 1);
+-
+-			this.dispatchEvent({
+-				'type': 'geopackage_removed',
+-				'scene': this,
+-				'geopackage': geopackage
+-			});
+-		}
+-	};
+-
+-	removeVolume (volume) {
+-		let index = this.volumes.indexOf(volume);
+-		if (index > -1) {
+-			this.volumes.splice(index, 1);
+-
+-			this.dispatchEvent({
+-				'type': 'volume_removed',
+-				'scene': this,
+-				'volume': volume
+-			});
+-		}
+-	};
+-
+-	addCameraAnimation(animation) {
+-		this.cameraAnimations.push(animation);
+-		this.dispatchEvent({
+-			'type': 'camera_animation_added',
+-			'scene': this,
+-			'animation': animation
+-		});
+-	};
+-
+-	removeCameraAnimation(animation){
+-		let index = this.cameraAnimations.indexOf(volume);
+-		if (index > -1) {
+-			this.cameraAnimations.splice(index, 1);
+-
+-			this.dispatchEvent({
+-				'type': 'camera_animation_removed',
+-				'scene': this,
+-				'animation': animation
+-			});
+-		}
+-	};
+-
+-	addPolygonClipVolume(volume){
+-		this.polygonClipVolumes.push(volume);
+-		this.dispatchEvent({
+-			"type": "polygon_clip_volume_added",
+-			"scene": this,
+-			"volume": volume
+-		});
+-	};
+-	
+-	removePolygonClipVolume(volume){
+-		let index = this.polygonClipVolumes.indexOf(volume);
+-		if (index > -1) {
+-			this.polygonClipVolumes.splice(index, 1);
+-			this.dispatchEvent({
+-				"type": "polygon_clip_volume_removed",
+-				"scene": this,
+-				"volume": volume
+-			});
+-		}
+-	};
+-	
+-	addMeasurement(measurement){
+-		measurement.lengthUnit = this.lengthUnit;
+-		measurement.lengthUnitDisplay = this.lengthUnitDisplay;
+-		this.measurements.push(measurement);
+-		this.dispatchEvent({
+-			'type': 'measurement_added',
+-			'scene': this,
+-			'measurement': measurement
+-		});
+-	};
+-
+-	removeMeasurement (measurement) {
+-		let index = this.measurements.indexOf(measurement);
+-		if (index > -1) {
+-			this.measurements.splice(index, 1);
+-			this.dispatchEvent({
+-				'type': 'measurement_removed',
+-				'scene': this,
+-				'measurement': measurement
+-			});
+-		}
+-	}
+-
+-	addProfile (profile) {
+-		this.profiles.push(profile);
+-		this.dispatchEvent({
+-			'type': 'profile_added',
+-			'scene': this,
+-			'profile': profile
+-		});
+-	}
+-
+-	removeProfile (profile) {
+-		let index = this.profiles.indexOf(profile);
+-		if (index > -1) {
+-			this.profiles.splice(index, 1);
+-			this.dispatchEvent({
+-				'type': 'profile_removed',
+-				'scene': this,
+-				'profile': profile
+-			});
+-		}
+-	}
+-
+-	removeAllMeasurements () {
+-		while (this.measurements.length > 0) {
+-			this.removeMeasurement(this.measurements[0]);
+-		}
+-
+-		while (this.profiles.length > 0) {
+-			this.removeProfile(this.profiles[0]);
+-		}
+-
+-		while (this.volumes.length > 0) {
+-			this.removeVolume(this.volumes[0]);
+-		}
+-	}
+-
+-	removeAllClipVolumes(){
+-		let clipVolumes = this.volumes.filter(volume => volume.clip === true);
+-		for(let clipVolume of clipVolumes){
+-			this.removeVolume(clipVolume);
+-		}
+-
+-		while(this.polygonClipVolumes.length > 0){
+-			this.removePolygonClipVolume(this.polygonClipVolumes[0]);
+-		}
+-	}
+-
+-	getActiveCamera() {
+-
+-		if(this.overrideCamera){
+-			return this.overrideCamera;
+-		}
+-
+-		if(this.cameraMode === CameraMode.PERSPECTIVE){
+-			return this.cameraP;
+-		}else if(this.cameraMode === CameraMode.ORTHOGRAPHIC){
+-			return this.cameraO;
+-		}else if(this.cameraMode === CameraMode.VR){
+-			return this.cameraVR;
+-		}
+-
+-		return null;
+-	}
+-	
+-	initialize(){
+-		
+-		this.referenceFrame = new THREE.Object3D();
+-		this.referenceFrame.matrixAutoUpdate = false;
+-		this.scenePointCloud.add(this.referenceFrame);
+-
+-		this.cameraP.up.set(0, 0, 1);
+-		this.cameraP.position.set(1000, 1000, 1000);
+-		this.cameraO.up.set(0, 0, 1);
+-		this.cameraO.position.set(1000, 1000, 1000);
+-		//this.camera.rotation.y = -Math.PI / 4;
+-		//this.camera.rotation.x = -Math.PI / 6;
+-		this.cameraScreenSpace.lookAt(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, 1, 0));
+-		
+-		this.directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
+-		this.directionalLight.position.set( 10, 10, 10 );
+-		this.directionalLight.lookAt( new THREE.Vector3(0, 0, 0));
+-		this.scenePointCloud.add( this.directionalLight );
+-		
+-		let light = new THREE.AmbientLight( 0x555555 ); // soft white light
+-		this.scenePointCloud.add( light );
+-
+-		{ // background
+-			let texture = Utils.createBackgroundTexture(512, 512);
+-
+-			texture.minFilter = texture.magFilter = THREE.NearestFilter;
+-			texture.minFilter = texture.magFilter = THREE.LinearFilter;
+-			let bg = new THREE.Mesh(
+-				new THREE.PlaneBufferGeometry(2, 2, 1),
+-				new THREE.MeshBasicMaterial({
+-					map: texture
+-				})
+-			);
+-			bg.material.depthTest = false;
+-			bg.material.depthWrite = false;
+-			this.sceneBG.add(bg);
+-		}
+-
+-		// { // lights
+-		// 	{
+-		// 		let light = new THREE.DirectionalLight(0xffffff);
+-		// 		light.position.set(10, 10, 1);
+-		// 		light.target.position.set(0, 0, 0);
+-		// 		this.scene.add(light);
+-		// 	}
+-
+-		// 	{
+-		// 		let light = new THREE.DirectionalLight(0xffffff);
+-		// 		light.position.set(-10, 10, 1);
+-		// 		light.target.position.set(0, 0, 0);
+-		// 		this.scene.add(light);
+-		// 	}
+-
+-		// 	{
+-		// 		let light = new THREE.DirectionalLight(0xffffff);
+-		// 		light.position.set(0, -10, 20);
+-		// 		light.target.position.set(0, 0, 0);
+-		// 		this.scene.add(light);
+-		// 	}
+-		// }
+-	}
+-	
+-	addAnnotation(position, args = {}){		
+-		if(position instanceof Array){
+-			args.position = new THREE.Vector3().fromArray(position);
+-		} else if (position.x != null) {
+-			args.position = position;
+-		}
+-		let annotation = new Annotation(args);
+-		this.annotations.add(annotation);
+-
+-		return annotation;
+-	}
+-
+-	getAnnotations () {
+-		return this.annotations;
+-	};
+-
+-	removeAnnotation(annotationToRemove) {
+-		this.annotations.remove(annotationToRemove);
+-	}
+-};
++import { Annotation } from "../Annotation.js";
++import { CameraMode } from "../defines.js";
++import { View } from "./View.js";
++import { Utils } from "../utils.js";
++import { EventDispatcher } from "../EventDispatcher.js";
++
++export class Scene extends EventDispatcher {
++  constructor() {
++    super();
++
++    this.annotations = new Annotation();
++
++    this.scene = new THREE.Scene();
++    this.sceneBG = new THREE.Scene();
++    this.scenePointCloud = new THREE.Scene();
++
++    this.cameraP = new THREE.PerspectiveCamera(this.fov, 1, 0.1, 1000 * 1000);
++    this.cameraO = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 1000 * 1000);
++    this.cameraVR = new THREE.PerspectiveCamera();
++    this.cameraBG = new THREE.Camera();
++    this.cameraScreenSpace = new THREE.OrthographicCamera(
++      -1,
++      1,
++      1,
++      -1,
++      0.1,
++      10
++    );
++    this.cameraMode = CameraMode.PERSPECTIVE;
++    this.overrideCamera = null;
++    this.pointclouds = [];
++
++    this.measurements = [];
++    this.profiles = [];
++    this.volumes = [];
++    this.polygonClipVolumes = [];
++    this.cameraAnimations = [];
++    this.orientedImages = [];
++    this.images360 = [];
++    this.geopackages = [];
++
++    this.fpControls = null;
++    this.orbitControls = null;
++    this.earthControls = null;
++    this.geoControls = null;
++    this.deviceControls = null;
++    this.inputHandler = null;
++
++    this.view = new View();
++
++    this.directionalLight = null;
++
++    this.initialize();
++  }
++
++  estimateHeightAt(position) {
++    let height = null;
++    let fromSpacing = Infinity;
++
++    for (let pointcloud of this.pointclouds) {
++      if (pointcloud.root.geometryNode === undefined) {
++        continue;
++      }
++
++      let pHeight = null;
++      let pFromSpacing = Infinity;
++
++      let lpos = position.clone().sub(pointcloud.position);
++      lpos.z = 0;
++      let ray = new THREE.Ray(lpos, new THREE.Vector3(0, 0, 1));
++
++      let stack = [pointcloud.root];
++      while (stack.length > 0) {
++        let node = stack.pop();
++        let box = node.getBoundingBox();
++
++        let inside = ray.intersectBox(box);
++
++        if (!inside) {
++          continue;
++        }
++
++        let h =
++          node.geometryNode.mean.z +
++          pointcloud.position.z +
++          node.geometryNode.boundingBox.min.z;
++
++        if (node.geometryNode.spacing <= pFromSpacing) {
++          pHeight = h;
++          pFromSpacing = node.geometryNode.spacing;
++        }
++
++        for (let index of Object.keys(node.children)) {
++          let child = node.children[index];
++          if (child.geometryNode) {
++            stack.push(node.children[index]);
++          }
++        }
++      }
++
++      if (height === null || pFromSpacing < fromSpacing) {
++        height = pHeight;
++        fromSpacing = pFromSpacing;
++      }
++    }
++
++    return height;
++  }
++
++  getBoundingBox(pointclouds = this.pointclouds) {
++    let box = new THREE.Box3();
++
++    this.scenePointCloud.updateMatrixWorld(true);
++    this.referenceFrame.updateMatrixWorld(true);
++
++    for (let pointcloud of pointclouds) {
++      pointcloud.updateMatrixWorld(true);
++
++      let pointcloudBox = pointcloud.pcoGeometry.tightBoundingBox
++        ? pointcloud.pcoGeometry.tightBoundingBox
++        : pointcloud.boundingBox;
++      let boxWorld = Utils.computeTransformedBoundingBox(
++        pointcloudBox,
++        pointcloud.matrixWorld
++      );
++      box.union(boxWorld);
++    }
++
++    return box;
++  }
++
++  addPointCloud(pointcloud) {
++    this.pointclouds.push(pointcloud);
++    this.scenePointCloud.add(pointcloud);
++
++    this.dispatchEvent({
++      type: "pointcloud_added",
++      pointcloud: pointcloud,
++    });
++  }
++
++  addVolume(volume) {
++    this.volumes.push(volume);
++    this.dispatchEvent({
++      type: "volume_added",
++      scene: this,
++      volume: volume,
++    });
++  }
++
++  addOrientedImages(images) {
++    this.orientedImages.push(images);
++    this.scene.add(images.node);
++
++    this.dispatchEvent({
++      type: "oriented_images_added",
++      scene: this,
++      images: images,
++    });
++  }
++
++  removeOrientedImages(images) {
++    let index = this.orientedImages.indexOf(images);
++    if (index > -1) {
++      this.orientedImages.splice(index, 1);
++
++      this.dispatchEvent({
++        type: "oriented_images_removed",
++        scene: this,
++        images: images,
++      });
++    }
++  }
++
++  add360Images(images) {
++    this.images360.push(images);
++    this.scene.add(images.node);
++
++    this.dispatchEvent({
++      type: "360_images_added",
++      scene: this,
++      images: images,
++    });
++  }
++
++  remove360Images(images) {
++    let index = this.images360.indexOf(images);
++    if (index > -1) {
++      this.images360.splice(index, 1);
++
++      this.dispatchEvent({
++        type: "360_images_removed",
++        scene: this,
++        images: images,
++      });
++    }
++  }
++
++  addGeopackage(geopackage) {
++    this.geopackages.push(geopackage);
++    this.scene.add(geopackage.node);
++
++    this.dispatchEvent({
++      type: "geopackage_added",
++      scene: this,
++      geopackage: geopackage,
++    });
++  }
++
++  removeGeopackage(geopackage) {
++    let index = this.geopackages.indexOf(geopackage);
++    if (index > -1) {
++      this.geopackages.splice(index, 1);
++
++      this.dispatchEvent({
++        type: "geopackage_removed",
++        scene: this,
++        geopackage: geopackage,
++      });
++    }
++  }
++
++  removeVolume(volume) {
++    let index = this.volumes.indexOf(volume);
++    if (index > -1) {
++      this.volumes.splice(index, 1);
++
++      this.dispatchEvent({
++        type: "volume_removed",
++        scene: this,
++        volume: volume,
++      });
++    }
++  }
++
++  addCameraAnimation(animation) {
++    this.cameraAnimations.push(animation);
++    this.dispatchEvent({
++      type: "camera_animation_added",
++      scene: this,
++      animation: animation,
++    });
++  }
++
++  removeCameraAnimation(animation) {
++    let index = this.cameraAnimations.indexOf(volume);
++    if (index > -1) {
++      this.cameraAnimations.splice(index, 1);
++
++      this.dispatchEvent({
++        type: "camera_animation_removed",
++        scene: this,
++        animation: animation,
++      });
++    }
++  }
++
++  addPolygonClipVolume(volume) {
++    this.polygonClipVolumes.push(volume);
++    this.dispatchEvent({
++      type: "polygon_clip_volume_added",
++      scene: this,
++      volume: volume,
++    });
++  }
++
++  removePolygonClipVolume(volume) {
++    let index = this.polygonClipVolumes.indexOf(volume);
++    if (index > -1) {
++      this.polygonClipVolumes.splice(index, 1);
++      this.dispatchEvent({
++        type: "polygon_clip_volume_removed",
++        scene: this,
++        volume: volume,
++      });
++    }
++  }
++
++  addMeasurement(measurement) {
++    measurement.lengthUnit = this.lengthUnit;
++    measurement.lengthUnitDisplay = this.lengthUnitDisplay;
++    this.measurements.push(measurement);
++    this.dispatchEvent({
++      type: "measurement_added",
++      scene: this,
++      measurement: measurement,
++    });
++  }
++
++  removeMeasurement(measurement) {
++    let index = this.measurements.indexOf(measurement);
++    if (index > -1) {
++      this.measurements.splice(index, 1);
++      this.dispatchEvent({
++        type: "measurement_removed",
++        scene: this,
++        measurement: measurement,
++      });
++    }
++  }
++
++  addProfile(profile) {
++    this.profiles.push(profile);
++    this.dispatchEvent({
++      type: "profile_added",
++      scene: this,
++      profile: profile,
++    });
++  }
++
++  removeProfile(profile) {
++    let index = this.profiles.indexOf(profile);
++    if (index > -1) {
++      this.profiles.splice(index, 1);
++      this.dispatchEvent({
++        type: "profile_removed",
++        scene: this,
++        profile: profile,
++      });
++    }
++  }
++
++  removeAllMeasurements() {
++    while (this.measurements.length > 0) {
++      this.removeMeasurement(this.measurements[0]);
++    }
++
++    while (this.profiles.length > 0) {
++      this.removeProfile(this.profiles[0]);
++    }
++
++    while (this.volumes.length > 0) {
++      this.removeVolume(this.volumes[0]);
++    }
++  }
++
++  removeAllClipVolumes() {
++    let clipVolumes = this.volumes.filter((volume) => volume.clip === true);
++    for (let clipVolume of clipVolumes) {
++      this.removeVolume(clipVolume);
++    }
++
++    while (this.polygonClipVolumes.length > 0) {
++      this.removePolygonClipVolume(this.polygonClipVolumes[0]);
++    }
++  }
++
++  getActiveCamera() {
++    if (this.overrideCamera) {
++      return this.overrideCamera;
++    }
++
++    if (this.cameraMode === CameraMode.PERSPECTIVE) {
++      return this.cameraP;
++    } else if (this.cameraMode === CameraMode.ORTHOGRAPHIC) {
++      return this.cameraO;
++    } else if (this.cameraMode === CameraMode.VR) {
++      return this.cameraVR;
++    }
++
++    return null;
++  }
++
++  initialize() {
++    this.referenceFrame = new THREE.Object3D();
++    this.referenceFrame.matrixAutoUpdate = false;
++    this.scenePointCloud.add(this.referenceFrame);
++
++    this.cameraP.up.set(0, 0, 1);
++    this.cameraP.position.set(1000, 1000, 1000);
++    this.cameraO.up.set(0, 0, 1);
++    this.cameraO.position.set(1000, 1000, 1000);
++    //this.camera.rotation.y = -Math.PI / 4;
++    //this.camera.rotation.x = -Math.PI / 6;
++    this.cameraScreenSpace.lookAt(
++      new THREE.Vector3(0, 0, 0),
++      new THREE.Vector3(0, 0, -1),
++      new THREE.Vector3(0, 1, 0)
++    );
++
++    this.directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
++    this.directionalLight.position.set(10, 10, 10);
++    this.directionalLight.lookAt(new THREE.Vector3(0, 0, 0));
++    this.scenePointCloud.add(this.directionalLight);
++
++    let light = new THREE.AmbientLight(0x555555); // soft white light
++    this.scenePointCloud.add(light);
++
++    {
++      // background
++      let texture = Utils.createBackgroundTexture(512, 512);
++
++      texture.minFilter = texture.magFilter = THREE.NearestFilter;
++      texture.minFilter = texture.magFilter = THREE.LinearFilter;
++      let bg = new THREE.Mesh(
++        new THREE.PlaneBufferGeometry(2, 2, 1),
++        new THREE.MeshBasicMaterial({
++          map: texture,
++        })
++      );
++      bg.material.depthTest = false;
++      bg.material.depthWrite = false;
++      this.sceneBG.add(bg);
++    }
++
++    // { // lights
++    // 	{
++    // 		let light = new THREE.DirectionalLight(0xffffff);
++    // 		light.position.set(10, 10, 1);
++    // 		light.target.position.set(0, 0, 0);
++    // 		this.scene.add(light);
++    // 	}
++
++    // 	{
++    // 		let light = new THREE.DirectionalLight(0xffffff);
++    // 		light.position.set(-10, 10, 1);
++    // 		light.target.position.set(0, 0, 0);
++    // 		this.scene.add(light);
++    // 	}
++
++    // 	{
++    // 		let light = new THREE.DirectionalLight(0xffffff);
++    // 		light.position.set(0, -10, 20);
++    // 		light.target.position.set(0, 0, 0);
++    // 		this.scene.add(light);
++    // 	}
++    // }
++  }
++
++  addAnnotation(position, args = {}) {
++    if (position instanceof Array) {
++      args.position = new THREE.Vector3().fromArray(position);
++    } else if (position.x != null) {
++      args.position = position;
++    }
++    let annotation = new Annotation(args);
++    this.annotations.add(annotation);
++
++    return annotation;
++  }
++
++  getAnnotations() {
++    return this.annotations;
++  }
++
++  removeAnnotation(annotationToRemove) {
++    this.annotations.remove(annotationToRemove);
++  }
++}
+diff --git a/src/viewer/map.js b/src/viewer/map.js
+index 0979c607..314ac1e5 100644
+--- a/src/viewer/map.js
++++ b/src/viewer/map.js
+@@ -305,7 +305,7 @@ export class MapView{
+ 		};
+ 
+ 		this.on360ImagesAdded = e => {
+-			this.addImages360(e.images);
++			// this.addImages360(e.images);
+ 		};
+ 
+ 		this.onAnnotationAdded = e => {
+diff --git a/src/viewer/viewer.js b/src/viewer/viewer.js
+index baf1fb1b..bb07592d 100644
+--- a/src/viewer/viewer.js
++++ b/src/viewer/viewer.js
+@@ -788,6 +788,7 @@ export class Viewer extends EventDispatcher{
+ 	};
+ 
+ 	zoomTo(node, factor, animationDuration = 0){
++		let changeEvent = new CustomEvent("camerachange");
+ 		let view = this.scene.view;
+ 
+ 		let camera = this.scene.cameraP.clone();
+@@ -825,6 +826,7 @@ export class Viewer extends EventDispatcher{
+ 
+ 			tween.onUpdate(() => {
+ 				view.position.copy(pos);
++				document.dispatchEvent(changeEvent);
+ 			});
+ 
+ 			tween.start();
+@@ -836,10 +838,12 @@ export class Viewer extends EventDispatcher{
+ 			tween.easing(easing);
+ 			tween.onUpdate(() => {
+ 				view.lookAt(target);
++				document.dispatchEvent(changeEvent);
+ 			});
+ 			tween.onComplete(() => {
+ 				view.lookAt(target);
+ 				this.dispatchEvent({type: 'focusing_finished', target: this});
++				document.dispatchEvent(changeEvent);
+ 			});
+ 
+ 			this.dispatchEvent({type: 'focusing_started', target: this});
+@@ -1205,118 +1209,118 @@ export class Viewer extends EventDispatcher{
+ 		}
+ 
+ 		let viewer = this;
+-		let sidebarContainer = $('#potree_sidebar_container');
+-		sidebarContainer.load(new URL(Potree.scriptPath + '/sidebar.html').href, () => {
+-			sidebarContainer.css('width', '300px');
+-			sidebarContainer.css('height', '100%');
+-
+-			let imgMenuToggle = document.createElement('img');
+-			imgMenuToggle.src = new URL(Potree.resourcePath + '/icons/menu_button.svg').href;
+-			imgMenuToggle.onclick = this.toggleSidebar;
+-			imgMenuToggle.classList.add('potree_menu_toggle');
+-
+-			let imgMapToggle = document.createElement('img');
+-			imgMapToggle.src = new URL(Potree.resourcePath + '/icons/map_icon.png').href;
+-			imgMapToggle.style.display = 'none';
+-			imgMapToggle.onclick = e => { this.toggleMap(); };
+-			imgMapToggle.id = 'potree_map_toggle';
++		// let sidebarContainer = $('#potree_sidebar_container');
++		// sidebarContainer.load(new URL(Potree.scriptPath + '/sidebar.html').href, () => {
++		// 	sidebarContainer.css('width', '300px');
++		// 	sidebarContainer.css('height', '100%');
++
++		// 	let imgMenuToggle = document.createElement('img');
++		// 	imgMenuToggle.src = new URL(Potree.resourcePath + '/icons/menu_button.svg').href;
++		// 	imgMenuToggle.onclick = this.toggleSidebar;
++		// 	imgMenuToggle.classList.add('potree_menu_toggle');
++
++		// 	let imgMapToggle = document.createElement('img');
++		// 	imgMapToggle.src = new URL(Potree.resourcePath + '/icons/map_icon.png').href;
++		// 	imgMapToggle.style.display = 'none';
++		// 	imgMapToggle.onclick = e => { this.toggleMap(); };
++		// 	imgMapToggle.id = 'potree_map_toggle';
+ 
+ 			
+ 
+-			let elButtons = $("#potree_quick_buttons").get(0);
++		// 	let elButtons = $("#potree_quick_buttons").get(0);
+ 
+-			elButtons.append(imgMenuToggle);
+-			elButtons.append(imgMapToggle);
++		// 	elButtons.append(imgMenuToggle);
++		// 	elButtons.append(imgMapToggle);
+ 
+ 
+-			VRButton.createButton(this.renderer).then(vrButton => {
++		// 	VRButton.createButton(this.renderer).then(vrButton => {
+ 
+-				if(vrButton == null){
+-					console.log("VR not supported or active.");
++		// 		if(vrButton == null){
++		// 			console.log("VR not supported or active.");
+ 
+-					return;
+-				}
++		// 			return;
++		// 		}
+ 
+-				this.renderer.xr.enabled = true;
++		// 		this.renderer.xr.enabled = true;
+ 
+-				let element = vrButton.element;
++		// 		let element = vrButton.element;
+ 
+-				element.style.position = "";
+-				element.style.bottom = "";
+-				element.style.left = "";
+-				element.style.margin = "4px";
+-				element.style.fontSize = "100%";
+-				element.style.width = "2.5em";
+-				element.style.height = "2.5em";
+-				element.style.padding = "0";
+-				element.style.textShadow = "black 2px 2px 2px";
+-				element.style.display = "block";
++		// 		element.style.position = "";
++		// 		element.style.bottom = "";
++		// 		element.style.left = "";
++		// 		element.style.margin = "4px";
++		// 		element.style.fontSize = "100%";
++		// 		element.style.width = "2.5em";
++		// 		element.style.height = "2.5em";
++		// 		element.style.padding = "0";
++		// 		element.style.textShadow = "black 2px 2px 2px";
++		// 		element.style.display = "block";
+ 
+-				elButtons.append(element);
++		// 		elButtons.append(element);
+ 
+-				vrButton.onStart(() => {
+-					this.dispatchEvent({type: "vr_start"});
+-				});
++		// 		vrButton.onStart(() => {
++		// 			this.dispatchEvent({type: "vr_start"});
++		// 		});
+ 
+-				vrButton.onEnd(() => {
+-					this.dispatchEvent({type: "vr_end"});
+-				});
+-			});
++		// 		vrButton.onEnd(() => {
++		// 			this.dispatchEvent({type: "vr_end"});
++		// 		});
++		// 	});
+ 
+-			this.mapView = new MapView(this);
+-			this.mapView.init();
+-
+-			i18n.init({
+-				lng: 'en',
+-				resGetPath: Potree.resourcePath + '/lang/__lng__/__ns__.json',
+-				preload: ['en', 'fr', 'de', 'jp', 'se', 'es', 'zh', 'it','ca'],
+-				getAsync: true,
+-				debug: false
+-			}, function (t) {
+-				// Start translation once everything is loaded
+-				$('body').i18n();
+-			});
++		// 	this.mapView = new MapView(this);
++		// 	this.mapView.init();
+ 
+-			$(() => {
+-				//initSidebar(this);
+-				let sidebar = new Sidebar(this);
+-				sidebar.init();
++		// 	i18n.init({
++		// 		lng: 'en',
++		// 		resGetPath: Potree.resourcePath + '/lang/__lng__/__ns__.json',
++		// 		preload: ['en', 'fr', 'de', 'jp', 'se', 'es'],
++		// 		getAsync: true,
++		// 		debug: false
++		// 	}, function (t) {
++		// 		// Start translation once everything is loaded
++		// 		$('body').i18n();
++		// 	});
+ 
+-				this.sidebar = sidebar;
++		// 	$(() => {
++		// 		//initSidebar(this);
++		// 		let sidebar = new Sidebar(this);
++		// 		sidebar.init();
+ 
+-				//if (callback) {
+-				//	$(callback);
+-				//}
++		// 		this.sidebar = sidebar;
+ 
+-				let elProfile = $('<div>').load(new URL(Potree.scriptPath + '/profile.html').href, () => {
+-					$(document.body).append(elProfile.children());
+-					this.profileWindow = new ProfileWindow(this);
+-					this.profileWindowController = new ProfileWindowController(this);
++		// 		//if (callback) {
++		// 		//	$(callback);
++		// 		//}
+ 
+-					$('#profile_window').draggable({
+-						handle: $('#profile_titlebar'),
+-						containment: $(document.body)
+-					});
+-					$('#profile_window').resizable({
+-						containment: $(document.body),
+-						handles: 'n, e, s, w'
+-					});
++		// 		let elProfile = $('<div>').load(new URL(Potree.scriptPath + '/profile.html').href, () => {
++		// 			$(document.body).append(elProfile.children());
++		// 			this.profileWindow = new ProfileWindow(this);
++		// 			this.profileWindowController = new ProfileWindowController(this);
++
++		// 			$('#profile_window').draggable({
++		// 				handle: $('#profile_titlebar'),
++		// 				containment: $(document.body)
++		// 			});
++		// 			$('#profile_window').resizable({
++		// 				containment: $(document.body),
++		// 				handles: 'n, e, s, w'
++		// 			});
+ 
+-					$(() => {
++		// 			$(() => {
+ 						this.guiLoaded = true;
+ 						for(let task of this.guiLoadTasks){
+ 							task();
+ 						}
+ 
+-					});
+-				});
++		// 			});
++		// 		});
+ 
+ 				
+ 
+-			});
++		// 	});
+ 
+ 			
+-		});
++		// });
+ 
+ 		return this.promiseGuiLoaded();
+ 	}
+@@ -1349,14 +1353,14 @@ export class Viewer extends EventDispatcher{
+ 
+ 				const file = item.getAsFile();
+ 
+-				const isJson5 = file.name.toLowerCase().endsWith(".json5");
++				const isJson = file.name.toLowerCase().endsWith(".json");
+ 				const isGeoPackage = file.name.toLowerCase().endsWith(".gpkg");
+ 
+-				if(isJson5){
++				if(isJson){
+ 					try{
+ 
+ 						const text = await file.text();
+-						const json = JSON5.parse(text);
++						const json = JSON.parse(text);
+ 
+ 						if(json.type === "Potree"){
+ 							Potree.loadProject(viewer, json);
+-- 
+2.38.1.windows.1
+
+
+From 08c0fbff3c3ffae93ac75c328506e9ce3465b316 Mon Sep 17 00:00:00 2001
+From: SathyaKrishna Vanama <sathyakrishna.vanama@constructn.ai>
+Date: Wed, 28 Jun 2023 16:40:38 +0530
+Subject: [PATCH 2/9] ring geometry added to the potree and pitch correction
+ also done
+
+---
+ src/modules/Images360/Images360.js           | 672 ++++++++++---------
+ src/modules/OrientedImages/OrientedImages.js |  21 +-
+ src/navigation/OrbitControls.js              |   9 +
+ 3 files changed, 390 insertions(+), 312 deletions(-)
+
+diff --git a/src/modules/Images360/Images360.js b/src/modules/Images360/Images360.js
+index 669de80b..0db1c26d 100644
+--- a/src/modules/Images360/Images360.js
++++ b/src/modules/Images360/Images360.js
+@@ -1,305 +1,373 @@
++
+ import * as THREE from "../../../libs/three.js/build/three.module.js";
+ import { EventDispatcher } from "../../EventDispatcher.js";
++class Image360{
++
++	constructor(file, thumbnail, longitude, latitude, altitude, course, pitch, roll){
++		this.file = file;
++		this.thumbnail = thumbnail;
++		this.longitude = longitude;
++		this.latitude = latitude;
++		this.altitude = altitude;
++		this.course = course;
++		this.pitch = pitch;
++		this.roll = roll;
++		this.mesh = null;
++	}
++};
++
++export class Images360 extends EventDispatcher{
++
++	constructor(viewer){
++		super();
++
++		this.viewer = viewer;
++
++		this.selectingEnabled = true;
++
++		this.images = [];
++		this.node = new THREE.Object3D();
++
++		this.sphere = new THREE.Mesh(new THREE.SphereGeometry(1, 128, 128), new THREE.MeshBasicMaterial({side: THREE.BackSide}));
++		this.sphere.visible = false;
++		this.sphere.scale.set(-1000, 1000, 1000);
++		this.focus = this.focus.bind(this);
++		this.unfocus = this.unfocus.bind(this);
++		this.node.add(this.sphere);
++		this._visible = true;
++		this.focusedImage = null;
++		this.currentlyHovered = null;
++		this.previousView = {
++			controls: null,
++			position: null,
++			target: null,
++		};
++		this.raycaster = new THREE.Raycaster();
++		this.hoverMaterial = new THREE.MeshBasicMaterial({side: THREE.DoubleSide});
++		this.sm = new THREE.MeshBasicMaterial({side: THREE.DoubleSide,color:'#FF843F'});
++		
++		viewer.addEventListener("update", () => {
++			this.update(viewer);
++		});
++		viewer.inputHandler.addInputListener(this);
++
++		this.addEventListener("mousedown", () => {
++			if(this.currentlyHovered && this.currentlyHovered.image360){
++				this.focus(this.currentlyHovered.image360);
++			}
++		});
++		this.addEventListener("touchend", () => {
++			if(this.currentlyHovered && this.currentlyHovered.image360){
++				this.focus(this.currentlyHovered.image360);
++			}
++		});
++	};
++
++	set visible(visible){
++		if(this._visible === visible){
++			return;
++		}
++
++
++		for(const image of this.images){
++			image.mesh.visible = visible && (this.focusedImage == null);
++		}
++
++		this.sphere.visible = visible && (this.focusedImage != null);
++		this._visible = visible;
++		this.dispatchEvent({
++			type: "visibility_changed",
++			images: this,
++		});
++	}
++
++	get visible(){
++		return this._visible;
++	}
++
++	focus(image360, sendEvent = true, inTarget = null){
++		if(this.focusedImage !== null){
++			this.unfocus();
++		}
++		this.viewer.setEDLOpacity(0);
++		if (sendEvent) {
++			const event = new CustomEvent("panoLoad", {
++				detail: {
++					viewer: this.viewer.canvasId,
++					image: image360
++				}
++			});
++			document.dispatchEvent(event);
++		}
++
++		this.previousView = {
++			controls: this.viewer.controls,
++			position: this.viewer.scene.view.position.clone(),
++			target: this.viewer.scene.view.getPivot(),
++		};
++		this.viewer.setControls(this.viewer.orbitControls);
++		this.viewer.orbitControls.doubleClockZoomEnabled = false;
++		let index = this.images.findIndex( element => {
++		if (element.file === image360.file) {
++		return true;
++		}
++		});
++		
++		for(let image of this.images){
++			
++			image.mesh.visible = false;
++		}
++		
++		if(index != 0)
++		{
++
++			let i = index - 1
++			let current = new THREE.Vector3(this.images[index].position[0], this.images[index].position[1], this.images[index].position[2])
++			let next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
++			let dist = current.distanceTo(next)
++			while(dist < 0.5 && i > 0) {
++				i--
++				next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
++				dist = current.distanceTo(next)
++			}
++			this.images[i].mesh.visible = true
++			
++		}
++			let i = index + 1
++			let current = new THREE.Vector3(this.images[index].position[0], this.images[index].position[1], this.images[index].position[2])
++			let next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
++			let dist = current.distanceTo(next)
++			while(dist < 0.5) {
++				i++
++				next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
++				dist = current.distanceTo(next)
++			}
++			this.images[i].mesh.visible = true
++		
++		this.selectingEnabled = true;
++		this.sphere.visible = false;
++		this.load(image360).then( () => {
++			this.sphere.visible = true;
++			this.sphere.material.map = image360.texture;
++			this.sphere.material.needsUpdate = true;
++		});
++			let {course, pitch, roll} = image360;
++			this.sphere.rotation.set(
++			THREE.Math.degToRad(course),
++			THREE.Math.degToRad(pitch),
++			THREE.Math.degToRad(roll),
++			"XYZ"
++		);
++		this.sphere.position.set(...image360.position);
++		let target = new THREE.Vector3(...image360.position);
++		let dir = target.clone().sub(this.viewer.scene.view.position).normalize();
++		let move = dir.multiplyScalar(0.000001);
++		let newCamPos = target.clone().sub(move);
++		this.viewer.scene.view.setView(
++			newCamPos, 
++			target,
++			500,
++			() => {
++				if (inTarget && inTarget.pitch) {
++					this.viewer.scene.view.pitch = inTarget.pitch
++					this.viewer.scene.view.yaw = inTarget.yaw
++				}
++			}
++		);
++
++		this.focusedImage = image360;
++
++	}
++
++	unfocus(sendEvent = true){
++		this.selectingEnabled = true;
++		this.viewer.setEDLOpacity(1);
++		let image = this.focusedImage;
++		if(image === null){
++			return;
++		}
++		this.sphere.material.map = null;
++		this.sphere.material.needsUpdate = true;
++		this.sphere.visible = false;
++		this.sphere.position.set(this.sphere.position - [...this.images[0].position]);
++
++		let pos = this.viewer.scene.view.position;
++		let target = this.viewer.scene.view.getPivot();
++		let dir = target.clone().sub(pos).normalize();
++		let move = dir.multiplyScalar(10);
++		let newCamPos = target.clone().sub(move);
++
++		this.viewer.orbitControls.doubleClockZoomEnabled = true;
++		this.viewer.setControls(this.previousView.controls);
++		this.focusedImage = null;
++		
++		if (sendEvent) {
++			const event = new CustomEvent("panoUnload", {
++				detail: {
++					viewer: this.viewer.canvasId
++				}
++			});
++			document.dispatchEvent(event);
++		}
++
++	}
++
++	load(image360){
++		let resolved = false;
++		return new Promise(resolve => {
++			if (image360.texture) {
++				resolve(null);
++			} else {
++				new THREE.TextureLoader().load(image360.thumbnail,
++					texture => {
++							//var sphereMaterial = new MeshBasicMaterial({ map: texture, side: DoubleSide });
++                            //image360.texture = sphereMaterial;
++							image360.texture = texture;
++							resolved = true;
++							resolve(null);
++							loadOrgImage.bind(this)();
++						},
++					undefined,
++					err => {
++						loadOrgImage.bind(this)();
++					});
++				let loadOrgImage = function () {
++
++					new THREE.TextureLoader().load(image360.file,
++						texture => {
++								//var sphereMaterial = new MeshBasicMaterial({ map: texture, side: DoubleSide });
++                            	//image360.texture = sphereMaterial;
++								image360.texture = texture;
++								this.sphere.visible = true;
++								this.sphere.material.map = image360.texture;
++								this.sphere.material.needsUpdate = true;
++								if (!resolved) {
++									resolve(null);
++								}
++							});
++				}
++
++			}
++		});
++
++	}
++
++	handleHovering(){
++		let mouse = this.viewer.inputHandler.mouse;
++		let camera = this.viewer.scene.getActiveCamera();
++		let domElement = this.viewer.renderer.domElement;
++		let ray = Potree.Utils.mouseToRay(mouse, camera, domElement.clientWidth, domElement.clientHeight);
++		this.raycaster.ray.copy(ray);
++		let intersections = this.raycaster.intersectObjects(this.images.map(image=>{
++			return image.mesh}));
++		if(intersections.length === 0){
++			return;
++		}
++		let intersection = intersections[0];
++		if(intersection.object.image360.mesh.visible===true)
++		{
++		this.currentlyHovered = intersection.object;
++		this.currentlyHovered.material = this.hoverMaterial;
++		}
++		
++	}
++
++	update(){
++
++		let {viewer} = this;
++
++		if(this.currentlyHovered){
++			this.currentlyHovered.material = this.sm;
++			this.currentlyHovered = null;
++		}
++
++		if(this.selectingEnabled){
++			this.handleHovering();
++		}
++
++	}
++};
++
++
++export class Images360Loader{
++
++	static async load(url, imgsUrl, viewer, tm_data, params = {}){
++
++		if(!params.transform){
++			params.transform = {
++				forward: a => a,
++			};
++		}
++
++		let tmatrix, toffset;
++		
++		tmatrix = tm_data.tm;
++		toffset = tm_data.offset;
++		
++		let response = await fetch(url);
++		let text = await response.text();
++		let imgData = JSON.parse(text);
++
++		let images360 = new Images360(viewer);
++
++		Object.keys(imgData).forEach(imgName => {
++			let raw_position = imgData[imgName].position;
++			let rotation = imgData[imgName].rotation;
++			
++			const pos = new THREE.Vector4(raw_position[0], raw_position[1], raw_position[2], 1);
++			pos.applyMatrix4(tmatrix);
++			const long = parseFloat(pos.x - toffset[0]);
++			const lat = parseFloat(pos.y - toffset[1]);
++			const alt = parseFloat((pos.z - toffset[2]));
++			const course = parseFloat(rotation[0]);
++			const pitch = parseFloat(rotation[1]);
++			const roll = parseFloat(rotation[2]);
++
++			let file = `${imgsUrl}/${imgName}`;
++			let thumbnail = `${imgsUrl}/thumbnails/${imgName}`;
++			let image360 = new Image360(file, thumbnail, long, lat, alt, course, pitch, roll);
++
++			let position = [long, lat, alt];
++			image360.position = position;
++
++			images360.images.push(image360);
++		});
++
++		images360.images.sort(function (a, b) {
++			const getFileNumber = (file) => {
++				const numberPattern = /\d+/g;
++				const numbers = file.match(numberPattern);
++				if (numbers) {
++				return numbers.map((num) => num.padStart(10, '0')).join('');
++				}
++				return file;
++			};
++
++			const fileANumber = getFileNumber(a.file);
++			const fileBNumber = getFileNumber(b.file);
++			return fileANumber.localeCompare(fileBNumber);
++		});
++		
++		Images360Loader.createSceneNodes(images360, params.transform);
++
++		return images360;
++
++	}
++
++	static createSceneNodes(images360){
++
++		for(let image360 of images360.images){
++			let {longitude, latitude, altitude} = image360;
++			let mesh = new THREE.Mesh(new THREE.RingGeometry( 0.5, 1, 32 ), new THREE.MeshBasicMaterial({side: THREE.DoubleSide, color:'#FF843F'}));
++			mesh.position.set(longitude, latitude, altitude - 2.0);
++			mesh.scale.set(1, 1, 1);
++			mesh.material.transparent = true;
++			mesh.material.opacity = 0.75;
++			mesh.image360 = image360;
++			images360.node.add(mesh);
++			image360.mesh = mesh;
++		}
++	}
++};
++
+ 
+-class Image360 {
+-  constructor(
+-    file,
+-    thumbnail,
+-    longitude,
+-    latitude,
+-    altitude,
+-    course,
+-    pitch,
+-    roll
+-  ) {
+-    this.file = file;
+-    this.thumbnail = thumbnail;
+-    this.longitude = longitude;
+-    this.latitude = latitude;
+-    this.altitude = altitude;
+-    this.course = course;
+-    this.pitch = pitch;
+-    this.roll = roll;
+-  }
+-}
+-
+-export class Images360 extends EventDispatcher {
+-  constructor(viewer) {
+-    super();
+-
+-    this.viewer = viewer;
+-
+-    this.selectingEnabled = true;
+-
+-    this.images = [];
+-    this.node = new THREE.Object3D();
+-
+-    this.sphere = new THREE.Mesh(
+-      new THREE.SphereGeometry(1, 128, 128),
+-      new THREE.MeshBasicMaterial({ side: THREE.BackSide })
+-    );
+-    this.sphere.visible = false;
+-    this.sphere.scale.set(-1000, 1000, 1000);
+-
+-    this.focus = this.focus.bind(this);
+-    this.unfocus = this.unfocus.bind(this);
+-    this.node.add(this.sphere);
+-    this._visible = true;
+-
+-    this.focusedImage = null;
+-    this.currentlyHovered = null;
+-    this.previousView = {
+-      controls: null,
+-      position: null,
+-      target: null,
+-    };
+-    this.raycaster = new THREE.Raycaster();
+-    this.hoverMaterial = new THREE.MeshBasicMaterial({
+-      side: THREE.BackSide,
+-      color: 0xff0000,
+-    });
+-    this.sm = new THREE.MeshBasicMaterial({ side: THREE.BackSide });
+-
+-    // viewer.addEventListener("update", () => {
+-    //   this.update(viewer);
+-    // });
+-    viewer.inputHandler.addInputListener(this);
+-
+-    this.addEventListener("mousedown", () => {
+-      if (this.currentlyHovered && this.currentlyHovered.image360) {
+-        this.focus(this.currentlyHovered.image360);
+-      }
+-    });
+-  }
+-
+-  set visible(visible) {
+-    if (this._visible === visible) {
+-      return;
+-    }
+-    this.sphere.visible = visible && this.focusedImage != null;
+-    this._visible = visible;
+-    this.dispatchEvent({
+-      type: "visibility_changed",
+-      images: this,
+-    });
+-  }
+-
+-  get visible() {
+-    return this._visible;
+-  }
+-
+-  focus(image360, sendEvent = true, inTarget = null) {
+-    if (this.focusedImage !== null) {
+-      this.unfocus();
+-    }
+-    this.viewer.setEDLOpacity(0);
+-    if (sendEvent) {
+-      const event = new CustomEvent("panoLoad", {
+-        detail: {
+-          viewer: this.viewer.canvasId,
+-          image: image360,
+-        },
+-      });
+-      document.dispatchEvent(event);
+-    }
+-
+-    this.previousView = {
+-      controls: this.viewer.controls,
+-      position: this.viewer.scene.view.position.clone(),
+-      target: this.viewer.scene.view.getPivot(),
+-    };
+-
+-    this.viewer.setControls(this.viewer.orbitControls);
+-    this.viewer.orbitControls.doubleClockZoomEnabled = false;
+-
+-    this.selectingEnabled = false;
+-
+-    this.sphere.visible = false;
+-
+-    this.load(image360).then(() => {
+-      this.sphere.visible = true;
+-      this.sphere.material.map = image360.texture;
+-      this.sphere.material.needsUpdate = true;
+-    });
+-
+-    // orientation
+-    let { course, pitch, roll } = image360;
+-
+-    this.sphere.rotation.set(
+-      THREE.Math.degToRad(course),
+-      THREE.Math.degToRad(pitch),
+-      THREE.Math.degToRad(roll),
+-      "XYZ"
+-    );
+-
+-    this.sphere.position.set(...image360.position);
+-
+-    let target = new THREE.Vector3(...image360.position);
+-    let dir = target.clone().sub(this.viewer.scene.view.position).normalize();
+-    let move = dir.multiplyScalar(0.000001);
+-    let newCamPos = target.clone().sub(move);
+-
+-    this.viewer.scene.view.setView(newCamPos, target, 500, () => {
+-      if (inTarget && inTarget.pitch) {
+-        this.viewer.scene.view.pitch = inTarget.pitch;
+-        this.viewer.scene.view.yaw = inTarget.yaw;
+-      }
+-    });
+-
+-    this.focusedImage = image360;
+-  }
+-
+-  unfocus(sendEvent = true) {
+-    this.selectingEnabled = true;
+-    this.viewer.setEDLOpacity(1);
+-
+-    let image = this.focusedImage;
+-
+-    if (image === null) {
+-      return;
+-    }
+-    delete image.texture;
+-    this.sphere.material.map = null;
+-    this.sphere.material.needsUpdate = true;
+-    this.sphere.visible = false;
+-    this.viewer.orbitControls.doubleClockZoomEnabled = true;
+-    this.viewer.setControls(this.previousView.controls);
+-
+-    this.focusedImage = null;
+-
+-    if (sendEvent) {
+-      const event = new CustomEvent("panoUnload", {
+-        detail: {
+-          viewer: this.viewer.canvasId,
+-        },
+-      });
+-      document.dispatchEvent(event);
+-    }
+-  }
+-
+-  load(image360) {
+-    let resolved = false;
+-    return new Promise((resolve) => {
+-      if (image360.texture) {
+-        resolve(null);
+-      } else {
+-        new THREE.TextureLoader().load(
+-          image360.thumbnail,
+-          (texture) => {
+-            image360.texture = texture;
+-            resolved = true;
+-            resolve(null);
+-            loadOrgImage.bind(this)();
+-          },
+-          undefined,
+-          (err) => {
+-            loadOrgImage.bind(this)();
+-          }
+-        );
+-        let loadOrgImage = function () {
+-          new THREE.TextureLoader().load(image360.file, (texture) => {
+-            image360.texture = texture;
+-            this.sphere.visible = true;
+-            this.sphere.material.map = image360.texture;
+-            this.sphere.material.needsUpdate = true;
+-            if (!resolved) {
+-              resolve(null);
+-            }
+-            // }
+-          });
+-        };
+-      }
+-    });
+-  }
+-
+-  //   handleHovering() {
+-  //     let mouse = this.viewer.inputHandler.mouse;
+-  //     let camera = this.viewer.scene.getActiveCamera();
+-  //     let domElement = this.viewer.renderer.domElement;
+-
+-  //     let ray = Potree.Utils.mouseToRay(
+-  //       mouse,
+-  //       camera,
+-  //       domElement.clientWidth,
+-  //       domElement.clientHeight
+-  //     );
+-
+-  //     this.raycaster.ray.copy(ray);
+-  //     let intersections = this.raycaster.intersectObjects(this.node.children);
+-
+-  //     if (intersections.length === 0) {
+-  //       return;
+-  //     }
+-
+-  //     let intersection = intersections[0];
+-  //     this.currentlyHovered = intersection.object;
+-  //     this.currentlyHovered.material = this.hoverMaterial;
+-  //   }
+-
+-  //   update() {
+-  //     let { viewer } = this;
+-
+-  //     if (this.currentlyHovered) {
+-  //       this.currentlyHovered.material = this.sm;
+-  //       this.currentlyHovered = null;
+-  //     }
+-
+-  //     if (this.selectingEnabled) {
+-  //       // this.handleHovering();
+-  //     }
+-  //   }
+-}
+-
+-export class Images360Loader {
+-  static async load(url, imgsUrl, viewer, tm_data) {
+-    let tmatrix, toffset;
+-
+-    tmatrix = tm_data.tm;
+-    toffset = tm_data.offset;
+-
+-    let response = await fetch(url);
+-    let text = await response.text();
+-    let imgData = JSON.parse(text);
+-
+-    let images360 = new Images360(viewer);
+-    Object.keys(imgData).forEach((imgName) => {
+-      let raw_position = imgData[imgName].position;
+-      let rotation = imgData[imgName].rotation;
+-
+-      const pos = new THREE.Vector4(
+-        raw_position[0],
+-        raw_position[1],
+-        raw_position[2],
+-        1
+-      );
+-      pos.applyMatrix4(tmatrix);
+-
+-      const long = parseFloat(pos.x - toffset[0]);
+-      const lat = parseFloat(pos.y - toffset[1]);
+-      const alt = parseFloat(pos.z - toffset[2]);
+-      const course = parseFloat(rotation[0]);
+-      const pitch = parseFloat(rotation[1]);
+-      const roll = parseFloat(rotation[2]);
+-
+-      let file = `${imgsUrl}/${imgName}`;
+-      let thumbnail = `${imgsUrl}/thumbnails/${imgName}`;
+-      let image360 = new Image360(
+-        file,
+-        thumbnail,
+-        long,
+-        lat,
+-        alt,
+-        course,
+-        pitch,
+-        roll
+-      );
+-
+-      let position = [long, lat, alt];
+-      image360.position = position;
+-
+-      images360.images.push(image360);
+-    });
+-
+-    return images360;
+-  }
+-}
+diff --git a/src/modules/OrientedImages/OrientedImages.js b/src/modules/OrientedImages/OrientedImages.js
+index 0d95c86e..4da9cd47 100644
+--- a/src/modules/OrientedImages/OrientedImages.js
++++ b/src/modules/OrientedImages/OrientedImages.js
+@@ -390,15 +390,7 @@ export class OrientedImageLoader {
+     const moveToImage = async (image, sendEvent = true) => {
+       viewer.controls.enabled = false;
+ 
+-      if (sendEvent) {
+-        const event = new CustomEvent("imageLoad", {
+-          detail: {
+-            viewer: viewer.canvasId,
+-            image,
+-          },
+-        });
+-        document.dispatchEvent(event);
+-      }
++      
+ 
+       const mesh = image.mesh;
+       const target = image;
+@@ -407,7 +399,16 @@ export class OrientedImageLoader {
+       const newCamTarget = mesh.position.clone();
+ 
+       viewer.scene.view.setView(newCamPos, newCamTarget);
+-
++	if (sendEvent) {
++        const event = new CustomEvent("imageLoad", {
++          detail: {
++            viewer: viewer.canvasId,
++            image,
++          },
++        });
++        document.dispatchEvent(event);
++      }
++	  
+       function loadImageTexture(path) {
+         return new Promise((resolve, reject) => {
+           new THREE.TextureLoader().load(path, (texture) => {
+diff --git a/src/navigation/OrbitControls.js b/src/navigation/OrbitControls.js
+index 1d21da93..fed504a3 100644
+--- a/src/navigation/OrbitControls.js
++++ b/src/navigation/OrbitControls.js
+@@ -276,6 +276,15 @@ export class OrbitControls extends EventDispatcher {
+       yaw -= progression * this.yawDelta;
+       pitch -= progression * this.pitchDelta;
+ 
++		if(pitch < -1 * 0.3)
++		{
++			pitch= -1 * 0.3
++		}
++		else if(pitch > 1.3)
++		{
++			pitch = 1.3
++		}
++		
+       view.yaw = yaw;
+       view.pitch = pitch;
+ 
+-- 
+2.38.1.windows.1
+
+
+From a3ca317809eaa9c81648e53b982ff673e8b56fd9 Mon Sep 17 00:00:00 2001
+From: SathyaKrishna Vanama <sathyakrishna.vanama@constructn.ai>
+Date: Wed, 28 Jun 2023 17:41:49 +0530
+Subject: [PATCH 3/9] conditions is added for 360 image   rings visibility
+
+---
+ src/modules/Images360/Images360.js | 24 +++++++++++++++++++++---
+ 1 file changed, 21 insertions(+), 3 deletions(-)
+
+diff --git a/src/modules/Images360/Images360.js b/src/modules/Images360/Images360.js
+index 0db1c26d..c7d5403b 100644
+--- a/src/modules/Images360/Images360.js
++++ b/src/modules/Images360/Images360.js
+@@ -107,7 +107,14 @@ export class Images360 extends EventDispatcher{
+ 		};
+ 		this.viewer.setControls(this.viewer.orbitControls);
+ 		this.viewer.orbitControls.doubleClockZoomEnabled = false;
+-		let index = this.images.findIndex( element => {
++		if (
++        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
++          navigator.userAgent
++        ) ||
++        (window.innerWidth <= 768))
++        {
++          
++        let index = this.images.findIndex( element => {
+ 		if (element.file === image360.file) {
+ 		return true;
+ 		}
+@@ -145,6 +152,11 @@ export class Images360 extends EventDispatcher{
+ 			this.images[i].mesh.visible = true
+ 		
+ 		this.selectingEnabled = true;
++		}
++		else
++		{
++			this.selectingEnabled = false;
++		}
+ 		this.sphere.visible = false;
+ 		this.load(image360).then( () => {
+ 			this.sphere.visible = true;
+@@ -347,9 +359,15 @@ export class Images360Loader{
+ 			const fileBNumber = getFileNumber(b.file);
+ 			return fileANumber.localeCompare(fileBNumber);
+ 		});
+-		
+-		Images360Loader.createSceneNodes(images360, params.transform);
+ 
++		if (
++        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
++          navigator.userAgent
++        ) ||
++        (window.innerWidth <= 768))
++        {
++           Images360Loader.createSceneNodes(images360, params.transform);
++        }
+ 		return images360;
+ 
+ 	}
+-- 
+2.38.1.windows.1
+
+
+From 1356855bfa2406c97415fa9a0a9be68569c2ae14 Mon Sep 17 00:00:00 2001
+From: SathyaKrishna Vanama <sathyakrishna.vanama@constructn.ai>
+Date: Wed, 12 Jul 2023 17:37:28 +0530
+Subject: [PATCH 4/9] code chnages
+
+---
+ src/modules/Images360/Images360.js | 50 ++++++++++++++----------------
+ src/navigation/OrbitControls.js    | 19 +++++-------
+ 2 files changed, 32 insertions(+), 37 deletions(-)
+
+diff --git a/src/modules/Images360/Images360.js b/src/modules/Images360/Images360.js
+index c7d5403b..63e92c3d 100644
+--- a/src/modules/Images360/Images360.js
++++ b/src/modules/Images360/Images360.js
+@@ -54,11 +54,25 @@ export class Images360 extends EventDispatcher{
+ 		this.addEventListener("mousedown", () => {
+ 			if(this.currentlyHovered && this.currentlyHovered.image360){
+ 				this.focus(this.currentlyHovered.image360);
++				const event = new CustomEvent("onRingClick", {
++                    detail: {
++                        viewer: this.viewer.canvasId,
++                        image: this.currentlyHovered.image360
++                    }
++                });
++                document.dispatchEvent(event);
+ 			}
+ 		});
+ 		this.addEventListener("touchend", () => {
+ 			if(this.currentlyHovered && this.currentlyHovered.image360){
+ 				this.focus(this.currentlyHovered.image360);
++				const event = new CustomEvent("onRingClick", {
++                    detail: {
++                        viewer: this.viewer.canvasId,
++                        image: this.currentlyHovered.image360
++                    }
++                });
++                document.dispatchEvent(event);
+ 			}
+ 		});
+ 	};
+@@ -106,15 +120,9 @@ export class Images360 extends EventDispatcher{
+ 			target: this.viewer.scene.view.getPivot(),
+ 		};
+ 		this.viewer.setControls(this.viewer.orbitControls);
++		this.viewer.orbitControls.isInterior = true;
+ 		this.viewer.orbitControls.doubleClockZoomEnabled = false;
+-		if (
+-        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
+-          navigator.userAgent
+-        ) ||
+-        (window.innerWidth <= 768))
+-        {
+-          
+-        let index = this.images.findIndex( element => {
++		let index = this.images.findIndex( element => {
+ 		if (element.file === image360.file) {
+ 		return true;
+ 		}
+@@ -132,31 +140,27 @@ export class Images360 extends EventDispatcher{
+ 			let current = new THREE.Vector3(this.images[index].position[0], this.images[index].position[1], this.images[index].position[2])
+ 			let next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
+ 			let dist = current.distanceTo(next)
+-			while(dist < 0.5 && i > 0) {
++			while(dist < 3 && i > -1) {
+ 				i--
+ 				next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
+ 				dist = current.distanceTo(next)
+ 			}
+-			this.images[i].mesh.visible = true
++			if(i>-1)this.images[i].mesh.visible = true
+ 			
+ 		}
+ 			let i = index + 1
+ 			let current = new THREE.Vector3(this.images[index].position[0], this.images[index].position[1], this.images[index].position[2])
+ 			let next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
+ 			let dist = current.distanceTo(next)
+-			while(dist < 0.5) {
++			while(dist < 3 && i<this.images.length) {
+ 				i++
+ 				next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
+ 				dist = current.distanceTo(next)
+ 			}
+-			this.images[i].mesh.visible = true
++			if(i<this.images.length)this.images[i].mesh.visible = true
+ 		
+ 		this.selectingEnabled = true;
+-		}
+-		else
+-		{
+-			this.selectingEnabled = false;
+-		}
++		
+ 		this.sphere.visible = false;
+ 		this.load(image360).then( () => {
+ 			this.sphere.visible = true;
+@@ -210,6 +214,7 @@ export class Images360 extends EventDispatcher{
+ 		let newCamPos = target.clone().sub(move);
+ 
+ 		this.viewer.orbitControls.doubleClockZoomEnabled = true;
++		this.viewer.orbitControls.isInterior = false;
+ 		this.viewer.setControls(this.previousView.controls);
+ 		this.focusedImage = null;
+ 		
+@@ -360,15 +365,8 @@ export class Images360Loader{
+ 			return fileANumber.localeCompare(fileBNumber);
+ 		});
+ 
+-		if (
+-        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
+-          navigator.userAgent
+-        ) ||
+-        (window.innerWidth <= 768))
+-        {
+-           Images360Loader.createSceneNodes(images360, params.transform);
+-        }
+-		return images360;
++		 Images360Loader.createSceneNodes(images360);
++			return images360;
+ 
+ 	}
+ 
+diff --git a/src/navigation/OrbitControls.js b/src/navigation/OrbitControls.js
+index fed504a3..2ed5150c 100644
+--- a/src/navigation/OrbitControls.js
++++ b/src/navigation/OrbitControls.js
+@@ -37,7 +37,7 @@ export class OrbitControls extends EventDispatcher {
+     this.radiusDelta = 0;
+ 
+     this.doubleClockZoomEnabled = true;
+-
++	this.isInterior=false
+     this.tweens = [];
+ 
+     this.changeEvent = new CustomEvent("camerachange");
+@@ -275,16 +275,13 @@ export class OrbitControls extends EventDispatcher {
+ 
+       yaw -= progression * this.yawDelta;
+       pitch -= progression * this.pitchDelta;
+-
+-		if(pitch < -1 * 0.3)
+-		{
+-			pitch= -1 * 0.3
+-		}
+-		else if(pitch > 1.3)
+-		{
+-			pitch = 1.3
+-		}
+-		
++	if (this.isInterior) {
++      if (pitch < -1 * 0.3) {
++        pitch = -1 * 0.3;
++      } else if (pitch > 1.3) {
++        pitch = 1.3;
++      }
++    }	
+       view.yaw = yaw;
+       view.pitch = pitch;
+ 
+-- 
+2.38.1.windows.1
+
+
+From 0f859e01a5c5d2705aeca7a38887af66248dfe8f Mon Sep 17 00:00:00 2001
+From: SathyaKrishna Vanama <sathyakrishna.vanama@constructn.ai>
+Date: Wed, 12 Jul 2023 17:45:12 +0530
+Subject: [PATCH 5/9] code changes
+
+---
+ examples/lion_las.html | 60 ++++++++++++------------------------------
+ 1 file changed, 17 insertions(+), 43 deletions(-)
+
+diff --git a/examples/lion_las.html b/examples/lion_las.html
+index fe233423..2df2bdb5 100644
+--- a/examples/lion_las.html
++++ b/examples/lion_las.html
+@@ -75,46 +75,7 @@
+         $("#menu_appearance").next().show();
+       });
+ 
+-      function isMobileDevice() {
+-        // Check for a specific mobile user agent string or screen size
+-        // Modify this condition based on your requirements
+-        console.log("fduihsdfju8iyshdfgyusifdhkjsdfhyuik", navigator.userAgent);
+-        return (
+-          /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
+-            navigator.userAgent
+-          ) || window.innerWidth <= 768
+-        );
+-      }
+-
+-      // Execute code only for the mobile version
+-      if (isMobileDevice()) {
+-        // Your mobile-specific code here
+-        console.log("Running on a mobile device");
+-        viewer.setDescription(`<button id="myButton">Next Image</button> `);
+-        var button = document.getElementById("myButton");
+-        button.addEventListener("click", function () {
+-          i++;
+-          console.log("sdujksdn", i);
+-          //   viewer.scene.orientedImages[0].moveToImage(
+-          //     viewer.scene.orientedImages[0].images[i]
+-          //   );
+-          viewer.scene.images360[0].focus(viewer.scene.images360[0].images[i]);
+-          //removeAssets(viewer);
+-        });
+-      } else {
+-        // Your web-specific code here
+-        console.log("Running on the web", navigator.userAgent);
+-      }
+-      // Add a click event listener to the button
+-      //   button.addEventListener("click", function () {
+-      //     i++;
+-      //     nextPanoImage(viewer);
+-      //     // viewer.scene.orientedImages[0].moveToImage(
+-      //     //   viewer.scene.orientedImages[0].images[i]
+-      //     // );
+-      //     //viewer.scene.images360[0].focus(viewer.scene.images360[0].images[i]);
+-      //     //removeAssets(viewer);
+-      //   });
++     
+       let viewerMode = "image";
+       // Sigeom
+       Potree.loadPointCloud(
+@@ -153,9 +114,22 @@
+           let pcOffset = [0, 0, 0];
+           pcMatrix = new THREE.Matrix4()
+             .fromArray([
+-              1.000465, 0.003179, 0.000021, -10232.804688, -0.003179, 1.000465,
+-              0.000031, -231.655838, -0.000021, -0.000031, 1.00047, -1272.54834,
+-              0.0, 0.0, 0.0, 1.0,
++            1,
++            0,
++            0,
++            0,
++            0,
++            1,
++            0,
++            0,
++            0,
++            0,
++            1,
++            0,
++            0,
++            0,
++            0,
++            1
+             ])
+             .transpose();
+           pointcloud.applyMatrix(pcMatrix);
+-- 
+2.38.1.windows.1
+
+
+From abbb15298fad7c727b310c029fa3a8eb74eea7da Mon Sep 17 00:00:00 2001
+From: SathyaKrishna Vanama <sathyakrishna.vanama@constructn.ai>
+Date: Thu, 13 Jul 2023 12:55:30 +0530
+Subject: [PATCH 6/9] Ring geometry modification for clicking all over the
+ circle completed
+
+---
+ src/modules/Images360/Images360.js | 55 +++++++++++++++++++-----------
+ 1 file changed, 36 insertions(+), 19 deletions(-)
+
+diff --git a/src/modules/Images360/Images360.js b/src/modules/Images360/Images360.js
+index 63e92c3d..fcba8200 100644
+--- a/src/modules/Images360/Images360.js
++++ b/src/modules/Images360/Images360.js
+@@ -43,8 +43,7 @@ export class Images360 extends EventDispatcher{
+ 			target: null,
+ 		};
+ 		this.raycaster = new THREE.Raycaster();
+-		this.hoverMaterial = new THREE.MeshBasicMaterial({side: THREE.DoubleSide});
+-		this.sm = new THREE.MeshBasicMaterial({side: THREE.DoubleSide,color:'#FF843F'});
++		this.hoverMaterial = new THREE.MeshBasicMaterial({side: THREE.BackSide});
+ 		
+ 		viewer.addEventListener("update", () => {
+ 			this.update(viewer);
+@@ -84,7 +83,7 @@ export class Images360 extends EventDispatcher{
+ 
+ 
+ 		for(const image of this.images){
+-			image.mesh.visible = visible && (this.focusedImage == null);
++			image.circleMesh.visible = visible && (this.focusedImage == null);
+ 		}
+ 
+ 		this.sphere.visible = visible && (this.focusedImage != null);
+@@ -129,8 +128,9 @@ export class Images360 extends EventDispatcher{
+ 		});
+ 		
+ 		for(let image of this.images){
+-			
+-			image.mesh.visible = false;
++
++			image.circleMesh.visible = false;
++			image.ringMesh.visible=false
+ 		}
+ 		
+ 		if(index != 0)
+@@ -145,7 +145,11 @@ export class Images360 extends EventDispatcher{
+ 				next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
+ 				dist = current.distanceTo(next)
+ 			}
+-			if(i>-1)this.images[i].mesh.visible = true
++			if(i>-1)
++			{
++			this.images[i].circleMesh.visible = true
++			this.images[i].ringMesh.visible = true	
++			}
+ 			
+ 		}
+ 			let i = index + 1
+@@ -157,7 +161,11 @@ export class Images360 extends EventDispatcher{
+ 				next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
+ 				dist = current.distanceTo(next)
+ 			}
+-			if(i<this.images.length)this.images[i].mesh.visible = true
++			if(i<this.images.length)
++			{
++			this.images[i].circleMesh.visible = true
++			this.images[i].ringMesh.visible = true	
++			}
+ 		
+ 		this.selectingEnabled = true;
+ 		
+@@ -276,12 +284,12 @@ export class Images360 extends EventDispatcher{
+ 		let ray = Potree.Utils.mouseToRay(mouse, camera, domElement.clientWidth, domElement.clientHeight);
+ 		this.raycaster.ray.copy(ray);
+ 		let intersections = this.raycaster.intersectObjects(this.images.map(image=>{
+-			return image.mesh}));
++			return image.circleMesh}));
+ 		if(intersections.length === 0){
+ 			return;
+ 		}
+ 		let intersection = intersections[0];
+-		if(intersection.object.image360.mesh.visible===true)
++		if(intersection.object.image360.circleMesh.visible===true)
+ 		{
+ 		this.currentlyHovered = intersection.object;
+ 		this.currentlyHovered.material = this.hoverMaterial;
+@@ -292,9 +300,8 @@ export class Images360 extends EventDispatcher{
+ 	update(){
+ 
+ 		let {viewer} = this;
+-
+ 		if(this.currentlyHovered){
+-			this.currentlyHovered.material = this.sm;
++			this.currentlyHovered.material = this.handleHovering;
+ 			this.currentlyHovered = null;
+ 		}
+ 
+@@ -374,14 +381,24 @@ export class Images360Loader{
+ 
+ 		for(let image360 of images360.images){
+ 			let {longitude, latitude, altitude} = image360;
+-			let mesh = new THREE.Mesh(new THREE.RingGeometry( 0.5, 1, 32 ), new THREE.MeshBasicMaterial({side: THREE.DoubleSide, color:'#FF843F'}));
+-			mesh.position.set(longitude, latitude, altitude - 2.0);
+-			mesh.scale.set(1, 1, 1);
+-			mesh.material.transparent = true;
+-			mesh.material.opacity = 0.75;
+-			mesh.image360 = image360;
+-			images360.node.add(mesh);
+-			image360.mesh = mesh;
++			let ringMesh = new THREE.Mesh(new THREE.RingGeometry( 0.5, 1, 32 ), new THREE.MeshBasicMaterial({side: THREE.DoubleSide, color:'#FF843F'}));
++			ringMesh.position.set(longitude, latitude, altitude - 2.0);
++			ringMesh.scale.set(1, 1, 1);
++			ringMesh.material.transparent = true;
++			ringMesh.material.opacity = 0.75;
++			ringMesh.image360 = image360;
++			let circleMesh = new THREE.Mesh(new THREE.CircleGeometry( 1, 32 ), new THREE.MeshBasicMaterial({side:THREE.DoubleSide}));
++			circleMesh.position.set(longitude, latitude, altitude - 2.0);
++			circleMesh.scale.set(1, 1, 1);
++			circleMesh.material.transparent = true;
++			circleMesh.material.opacity = 0;
++			circleMesh.image360 = image360;
++			const group = new THREE.Group();
++			group.add( ringMesh );
++			group.add( circleMesh );
++			images360.node.add(group);
++			image360.circleMesh = circleMesh;
++			image360.ringMesh = ringMesh;
+ 		}
+ 	}
+ };
+-- 
+2.38.1.windows.1
+
+
+From 530510e78b7f780f4473097d2f0bd5d400278bf7 Mon Sep 17 00:00:00 2001
+From: SathyaKrishna Vanama <sathyakrishna.vanama@constructn.ai>
+Date: Thu, 13 Jul 2023 15:52:58 +0530
+Subject: [PATCH 7/9] ring color changing when hovering
+
+---
+ src/modules/Images360/Images360.js | 8 ++++----
+ 1 file changed, 4 insertions(+), 4 deletions(-)
+
+diff --git a/src/modules/Images360/Images360.js b/src/modules/Images360/Images360.js
+index fcba8200..a427a79c 100644
+--- a/src/modules/Images360/Images360.js
++++ b/src/modules/Images360/Images360.js
+@@ -43,8 +43,8 @@ export class Images360 extends EventDispatcher{
+ 			target: null,
+ 		};
+ 		this.raycaster = new THREE.Raycaster();
+-		this.hoverMaterial = new THREE.MeshBasicMaterial({side: THREE.BackSide});
+-		
++		this.hoverMaterial = new THREE.MeshBasicMaterial({side: THREE.DoubleSide,color:''});
++		this.sm = new THREE.MeshBasicMaterial({side: THREE.DoubleSide,color:'#FF843F'});
+ 		viewer.addEventListener("update", () => {
+ 			this.update(viewer);
+ 		});
+@@ -291,7 +291,7 @@ export class Images360 extends EventDispatcher{
+ 		let intersection = intersections[0];
+ 		if(intersection.object.image360.circleMesh.visible===true)
+ 		{
+-		this.currentlyHovered = intersection.object;
++		this.currentlyHovered = intersection.object.parent.children[0];
+ 		this.currentlyHovered.material = this.hoverMaterial;
+ 		}
+ 		
+@@ -301,7 +301,7 @@ export class Images360 extends EventDispatcher{
+ 
+ 		let {viewer} = this;
+ 		if(this.currentlyHovered){
+-			this.currentlyHovered.material = this.handleHovering;
++			this.currentlyHovered.material = this.sm;
+ 			this.currentlyHovered = null;
+ 		}
+ 
+-- 
+2.38.1.windows.1
+
+
+From 93e974b0c17287945e48e0deac6a08334b8f066a Mon Sep 17 00:00:00 2001
+From: SathyaKrishna Vanama <sathyakrishna.vanama@constructn.ai>
+Date: Thu, 13 Jul 2023 17:13:25 +0530
+Subject: [PATCH 8/9] ring geometry nameing convention changes
+
+---
+ src/modules/Images360/Images360.js | 42 ++++++++++++++----------------
+ 1 file changed, 20 insertions(+), 22 deletions(-)
+
+diff --git a/src/modules/Images360/Images360.js b/src/modules/Images360/Images360.js
+index a427a79c..9eca6a46 100644
+--- a/src/modules/Images360/Images360.js
++++ b/src/modules/Images360/Images360.js
+@@ -12,7 +12,8 @@ class Image360{
+ 		this.course = course;
+ 		this.pitch = pitch;
+ 		this.roll = roll;
+-		this.mesh = null;
++		this.ringGroup=null
++		this.visibleRings=[]
+ 	}
+ };
+ 
+@@ -27,7 +28,7 @@ export class Images360 extends EventDispatcher{
+ 
+ 		this.images = [];
+ 		this.node = new THREE.Object3D();
+-
++		this.visibleRings=[]		
+ 		this.sphere = new THREE.Mesh(new THREE.SphereGeometry(1, 128, 128), new THREE.MeshBasicMaterial({side: THREE.BackSide}));
+ 		this.sphere.visible = false;
+ 		this.sphere.scale.set(-1000, 1000, 1000);
+@@ -83,7 +84,7 @@ export class Images360 extends EventDispatcher{
+ 
+ 
+ 		for(const image of this.images){
+-			image.circleMesh.visible = visible && (this.focusedImage == null);
++			image.ringGroup.visible = visible && (this.focusedImage == null);
+ 		}
+ 
+ 		this.sphere.visible = visible && (this.focusedImage != null);
+@@ -128,9 +129,7 @@ export class Images360 extends EventDispatcher{
+ 		});
+ 		
+ 		for(let image of this.images){
+-
+-			image.circleMesh.visible = false;
+-			image.ringMesh.visible=false
++			image.ringGroup.visible=false
+ 		}
+ 		
+ 		if(index != 0)
+@@ -140,15 +139,15 @@ export class Images360 extends EventDispatcher{
+ 			let current = new THREE.Vector3(this.images[index].position[0], this.images[index].position[1], this.images[index].position[2])
+ 			let next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
+ 			let dist = current.distanceTo(next)
+-			while(dist < 3 && i > -1) {
++			while(dist < 3 && i > 0) {
+ 				i--
+ 				next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
+ 				dist = current.distanceTo(next)
+ 			}
+ 			if(i>-1)
+ 			{
+-			this.images[i].circleMesh.visible = true
+-			this.images[i].ringMesh.visible = true	
++			this.images[i].ringGroup.visible = true
++			this.visibleRings.push(this.images[i])
+ 			}
+ 			
+ 		}
+@@ -163,8 +162,8 @@ export class Images360 extends EventDispatcher{
+ 			}
+ 			if(i<this.images.length)
+ 			{
+-			this.images[i].circleMesh.visible = true
+-			this.images[i].ringMesh.visible = true	
++			this.images[i].ringGroup.visible = true
++			this.visibleRings.push(this.images[i])	
+ 			}
+ 		
+ 		this.selectingEnabled = true;
+@@ -283,13 +282,13 @@ export class Images360 extends EventDispatcher{
+ 		let domElement = this.viewer.renderer.domElement;
+ 		let ray = Potree.Utils.mouseToRay(mouse, camera, domElement.clientWidth, domElement.clientHeight);
+ 		this.raycaster.ray.copy(ray);
+-		let intersections = this.raycaster.intersectObjects(this.images.map(image=>{
+-			return image.circleMesh}));
++		let intersections = this.raycaster.intersectObjects(this.visibleRings.map(image=>{
++			return image.ringGroup.children[1]}));
+ 		if(intersections.length === 0){
+ 			return;
+ 		}
+ 		let intersection = intersections[0];
+-		if(intersection.object.image360.circleMesh.visible===true)
++		if(intersection.object.parent.visible===true)
+ 		{
+ 		this.currentlyHovered = intersection.object.parent.children[0];
+ 		this.currentlyHovered.material = this.hoverMaterial;
+@@ -381,24 +380,23 @@ export class Images360Loader{
+ 
+ 		for(let image360 of images360.images){
+ 			let {longitude, latitude, altitude} = image360;
+-			let ringMesh = new THREE.Mesh(new THREE.RingGeometry( 0.5, 1, 32 ), new THREE.MeshBasicMaterial({side: THREE.DoubleSide, color:'#FF843F'}));
++			let ringMesh = new THREE.Mesh(new THREE.RingGeometry( 0.35, .5, 32 ), new THREE.MeshBasicMaterial({side: THREE.DoubleSide, color:'#FF843F'}));
+ 			ringMesh.position.set(longitude, latitude, altitude - 2.0);
+ 			ringMesh.scale.set(1, 1, 1);
+ 			ringMesh.material.transparent = true;
+ 			ringMesh.material.opacity = 0.75;
+ 			ringMesh.image360 = image360;
+-			let circleMesh = new THREE.Mesh(new THREE.CircleGeometry( 1, 32 ), new THREE.MeshBasicMaterial({side:THREE.DoubleSide}));
++			let circleMesh = new THREE.Mesh(new THREE.CircleGeometry( .5, 32 ), new THREE.MeshBasicMaterial({side:THREE.DoubleSide}));
+ 			circleMesh.position.set(longitude, latitude, altitude - 2.0);
+ 			circleMesh.scale.set(1, 1, 1);
+ 			circleMesh.material.transparent = true;
+ 			circleMesh.material.opacity = 0;
+ 			circleMesh.image360 = image360;
+-			const group = new THREE.Group();
+-			group.add( ringMesh );
+-			group.add( circleMesh );
+-			images360.node.add(group);
+-			image360.circleMesh = circleMesh;
+-			image360.ringMesh = ringMesh;
++			const ringGroup = new THREE.Group();
++			ringGroup.add( ringMesh );
++			ringGroup.add( circleMesh );
++			images360.node.add(ringGroup);
++			image360.ringGroup=ringGroup
+ 		}
+ 	}
+ };
+-- 
+2.38.1.windows.1
+
+
+From 0b71001c620095327cfea5b86ed76513bdd95f16 Mon Sep 17 00:00:00 2001
+From: SathyaKrishna Vanama <sathyakrishna.vanama@constructn.ai>
+Date: Thu, 13 Jul 2023 18:56:11 +0530
+Subject: [PATCH 9/9] ring displaying condition changed
+
+---
+ src/modules/Images360/Images360.js | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/src/modules/Images360/Images360.js b/src/modules/Images360/Images360.js
+index 9eca6a46..189fe367 100644
+--- a/src/modules/Images360/Images360.js
++++ b/src/modules/Images360/Images360.js
+@@ -155,7 +155,7 @@ export class Images360 extends EventDispatcher{
+ 			let current = new THREE.Vector3(this.images[index].position[0], this.images[index].position[1], this.images[index].position[2])
+ 			let next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
+ 			let dist = current.distanceTo(next)
+-			while(dist < 3 && i<this.images.length) {
++			while(dist < 3 && i<this.images.length-1) {
+ 				i++
+ 				next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
+ 				dist = current.distanceTo(next)
+-- 
+2.38.1.windows.1
+
diff --git a/src/modules/Images360/Images360.js b/src/modules/Images360/Images360.js
index 02026fd0..189fe367 100644
--- a/src/modules/Images360/Images360.js
+++ b/src/modules/Images360/Images360.js
@@ -1,35 +1,19 @@
 
 import * as THREE from "../../../libs/three.js/build/three.module.js";
 import { EventDispatcher } from "../../EventDispatcher.js";
-import {TextSprite} from "../../TextSprite.js";
-
-let sg = new THREE.SphereGeometry(1, 8, 8);
-let sgHigh = new THREE.SphereGeometry(1, 128, 128);
-
-let sm = new THREE.MeshBasicMaterial({side: THREE.BackSide});
-let smHovered = new THREE.MeshBasicMaterial({side: THREE.BackSide, color: 0xff0000});
-
-let raycaster = new THREE.Raycaster();
-let currentlyHovered = null;
-
-let previousView = {
-	controls: null,
-	position: null,
-	target: null,
-};
-
 class Image360{
 
-	constructor(file, time, longitude, latitude, altitude, course, pitch, roll){
+	constructor(file, thumbnail, longitude, latitude, altitude, course, pitch, roll){
 		this.file = file;
-		this.time = time;
+		this.thumbnail = thumbnail;
 		this.longitude = longitude;
 		this.latitude = latitude;
 		this.altitude = altitude;
 		this.course = course;
 		this.pitch = pitch;
 		this.roll = roll;
-		this.mesh = null;
+		this.ringGroup=null
+		this.visibleRings=[]
 	}
 };
 
@@ -44,42 +28,53 @@ export class Images360 extends EventDispatcher{
 
 		this.images = [];
 		this.node = new THREE.Object3D();
-
-		this.sphere = new THREE.Mesh(sgHigh, sm);
+		this.visibleRings=[]		
+		this.sphere = new THREE.Mesh(new THREE.SphereGeometry(1, 128, 128), new THREE.MeshBasicMaterial({side: THREE.BackSide}));
 		this.sphere.visible = false;
-		this.sphere.scale.set(1000, 1000, 1000);
+		this.sphere.scale.set(-1000, 1000, 1000);
+		this.focus = this.focus.bind(this);
+		this.unfocus = this.unfocus.bind(this);
 		this.node.add(this.sphere);
 		this._visible = true;
-		// this.node.add(label);
-
 		this.focusedImage = null;
-
-		let elUnfocus = document.createElement("input");
-		elUnfocus.type = "button";
-		elUnfocus.value = "unfocus";
-		elUnfocus.style.position = "absolute";
-		elUnfocus.style.right = "10px";
-		elUnfocus.style.bottom = "10px";
-		elUnfocus.style.zIndex = "10000";
-		elUnfocus.style.fontSize = "2em";
-		elUnfocus.addEventListener("click", () => this.unfocus());
-		this.elUnfocus = elUnfocus;
-
-		this.domRoot = viewer.renderer.domElement.parentElement;
-		this.domRoot.appendChild(elUnfocus);
-		this.elUnfocus.style.display = "none";
-
+		this.currentlyHovered = null;
+		this.previousView = {
+			controls: null,
+			position: null,
+			target: null,
+		};
+		this.raycaster = new THREE.Raycaster();
+		this.hoverMaterial = new THREE.MeshBasicMaterial({side: THREE.DoubleSide,color:''});
+		this.sm = new THREE.MeshBasicMaterial({side: THREE.DoubleSide,color:'#FF843F'});
 		viewer.addEventListener("update", () => {
 			this.update(viewer);
 		});
 		viewer.inputHandler.addInputListener(this);
 
 		this.addEventListener("mousedown", () => {
-			if(currentlyHovered && currentlyHovered.image360){
-				this.focus(currentlyHovered.image360);
+			if(this.currentlyHovered && this.currentlyHovered.image360){
+				this.focus(this.currentlyHovered.image360);
+				const event = new CustomEvent("onRingClick", {
+                    detail: {
+                        viewer: this.viewer.canvasId,
+                        image: this.currentlyHovered.image360
+                    }
+                });
+                document.dispatchEvent(event);
+			}
+		});
+		this.addEventListener("touchend", () => {
+			if(this.currentlyHovered && this.currentlyHovered.image360){
+				this.focus(this.currentlyHovered.image360);
+				const event = new CustomEvent("onRingClick", {
+                    detail: {
+                        viewer: this.viewer.canvasId,
+                        image: this.currentlyHovered.image360
+                    }
+                });
+                document.dispatchEvent(event);
 			}
 		});
-		
 	};
 
 	set visible(visible){
@@ -89,7 +84,7 @@ export class Images360 extends EventDispatcher{
 
 
 		for(const image of this.images){
-			image.mesh.visible = visible && (this.focusedImage == null);
+			image.ringGroup.visible = visible && (this.focusedImage == null);
 		}
 
 		this.sphere.visible = visible && (this.focusedImage != null);
@@ -104,146 +99,209 @@ export class Images360 extends EventDispatcher{
 		return this._visible;
 	}
 
-	focus(image360){
+	focus(image360, sendEvent = true, inTarget = null){
 		if(this.focusedImage !== null){
 			this.unfocus();
 		}
+		this.viewer.setEDLOpacity(0);
+		if (sendEvent) {
+			const event = new CustomEvent("panoLoad", {
+				detail: {
+					viewer: this.viewer.canvasId,
+					image: image360
+				}
+			});
+			document.dispatchEvent(event);
+		}
 
-		previousView = {
+		this.previousView = {
 			controls: this.viewer.controls,
 			position: this.viewer.scene.view.position.clone(),
-			target: viewer.scene.view.getPivot(),
+			target: this.viewer.scene.view.getPivot(),
 		};
-
 		this.viewer.setControls(this.viewer.orbitControls);
+		this.viewer.orbitControls.isInterior = true;
 		this.viewer.orbitControls.doubleClockZoomEnabled = false;
-
+		let index = this.images.findIndex( element => {
+		if (element.file === image360.file) {
+		return true;
+		}
+		});
+		
 		for(let image of this.images){
-			image.mesh.visible = false;
+			image.ringGroup.visible=false
 		}
-
-		this.selectingEnabled = false;
-
+		
+		if(index != 0)
+		{
+
+			let i = index - 1
+			let current = new THREE.Vector3(this.images[index].position[0], this.images[index].position[1], this.images[index].position[2])
+			let next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
+			let dist = current.distanceTo(next)
+			while(dist < 3 && i > 0) {
+				i--
+				next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
+				dist = current.distanceTo(next)
+			}
+			if(i>-1)
+			{
+			this.images[i].ringGroup.visible = true
+			this.visibleRings.push(this.images[i])
+			}
+			
+		}
+			let i = index + 1
+			let current = new THREE.Vector3(this.images[index].position[0], this.images[index].position[1], this.images[index].position[2])
+			let next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
+			let dist = current.distanceTo(next)
+			while(dist < 3 && i<this.images.length-1) {
+				i++
+				next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
+				dist = current.distanceTo(next)
+			}
+			if(i<this.images.length)
+			{
+			this.images[i].ringGroup.visible = true
+			this.visibleRings.push(this.images[i])	
+			}
+		
+		this.selectingEnabled = true;
+		
 		this.sphere.visible = false;
-
 		this.load(image360).then( () => {
 			this.sphere.visible = true;
 			this.sphere.material.map = image360.texture;
 			this.sphere.material.needsUpdate = true;
 		});
-
-		{ // orientation
 			let {course, pitch, roll} = image360;
 			this.sphere.rotation.set(
-				THREE.Math.degToRad(+roll + 90),
-				THREE.Math.degToRad(-pitch),
-				THREE.Math.degToRad(-course + 90),
-				"ZYX"
-			);
-		}
-
+			THREE.Math.degToRad(course),
+			THREE.Math.degToRad(pitch),
+			THREE.Math.degToRad(roll),
+			"XYZ"
+		);
 		this.sphere.position.set(...image360.position);
-
 		let target = new THREE.Vector3(...image360.position);
-		let dir = target.clone().sub(viewer.scene.view.position).normalize();
+		let dir = target.clone().sub(this.viewer.scene.view.position).normalize();
 		let move = dir.multiplyScalar(0.000001);
 		let newCamPos = target.clone().sub(move);
-
-		viewer.scene.view.setView(
+		this.viewer.scene.view.setView(
 			newCamPos, 
 			target,
-			500
+			500,
+			() => {
+				if (inTarget && inTarget.pitch) {
+					this.viewer.scene.view.pitch = inTarget.pitch
+					this.viewer.scene.view.yaw = inTarget.yaw
+				}
+			}
 		);
 
 		this.focusedImage = image360;
 
-		this.elUnfocus.style.display = "";
 	}
 
-	unfocus(){
+	unfocus(sendEvent = true){
 		this.selectingEnabled = true;
-
-		for(let image of this.images){
-			image.mesh.visible = true;
-		}
-
+		this.viewer.setEDLOpacity(1);
 		let image = this.focusedImage;
-
 		if(image === null){
 			return;
 		}
-
-
 		this.sphere.material.map = null;
 		this.sphere.material.needsUpdate = true;
 		this.sphere.visible = false;
+		this.sphere.position.set(this.sphere.position - [...this.images[0].position]);
 
-		let pos = viewer.scene.view.position;
-		let target = viewer.scene.view.getPivot();
+		let pos = this.viewer.scene.view.position;
+		let target = this.viewer.scene.view.getPivot();
 		let dir = target.clone().sub(pos).normalize();
 		let move = dir.multiplyScalar(10);
 		let newCamPos = target.clone().sub(move);
 
-		viewer.orbitControls.doubleClockZoomEnabled = true;
-		viewer.setControls(previousView.controls);
-
-		viewer.scene.view.setView(
-			previousView.position, 
-			previousView.target,
-			500
-		);
-
-
+		this.viewer.orbitControls.doubleClockZoomEnabled = true;
+		this.viewer.orbitControls.isInterior = false;
+		this.viewer.setControls(this.previousView.controls);
 		this.focusedImage = null;
+		
+		if (sendEvent) {
+			const event = new CustomEvent("panoUnload", {
+				detail: {
+					viewer: this.viewer.canvasId
+				}
+			});
+			document.dispatchEvent(event);
+		}
 
-		this.elUnfocus.style.display = "none";
 	}
 
 	load(image360){
-
+		let resolved = false;
 		return new Promise(resolve => {
-			let texture = new THREE.TextureLoader().load(image360.file, resolve);
-			texture.wrapS = THREE.RepeatWrapping;
-			texture.repeat.x = -1;
+			if (image360.texture) {
+				resolve(null);
+			} else {
+				new THREE.TextureLoader().load(image360.thumbnail,
+					texture => {
+							//var sphereMaterial = new MeshBasicMaterial({ map: texture, side: DoubleSide });
+                            //image360.texture = sphereMaterial;
+							image360.texture = texture;
+							resolved = true;
+							resolve(null);
+							loadOrgImage.bind(this)();
+						},
+					undefined,
+					err => {
+						loadOrgImage.bind(this)();
+					});
+				let loadOrgImage = function () {
+
+					new THREE.TextureLoader().load(image360.file,
+						texture => {
+								//var sphereMaterial = new MeshBasicMaterial({ map: texture, side: DoubleSide });
+                            	//image360.texture = sphereMaterial;
+								image360.texture = texture;
+								this.sphere.visible = true;
+								this.sphere.material.map = image360.texture;
+								this.sphere.material.needsUpdate = true;
+								if (!resolved) {
+									resolve(null);
+								}
+							});
+				}
 
-			image360.texture = texture;
+			}
 		});
 
 	}
 
 	handleHovering(){
-		let mouse = viewer.inputHandler.mouse;
-		let camera = viewer.scene.getActiveCamera();
-		let domElement = viewer.renderer.domElement;
-
+		let mouse = this.viewer.inputHandler.mouse;
+		let camera = this.viewer.scene.getActiveCamera();
+		let domElement = this.viewer.renderer.domElement;
 		let ray = Potree.Utils.mouseToRay(mouse, camera, domElement.clientWidth, domElement.clientHeight);
-
-		// let tStart = performance.now();
-		raycaster.ray.copy(ray);
-		let intersections = raycaster.intersectObjects(this.node.children);
-
+		this.raycaster.ray.copy(ray);
+		let intersections = this.raycaster.intersectObjects(this.visibleRings.map(image=>{
+			return image.ringGroup.children[1]}));
 		if(intersections.length === 0){
-			// label.visible = false;
-
 			return;
 		}
-
 		let intersection = intersections[0];
-		currentlyHovered = intersection.object;
-		currentlyHovered.material = smHovered;
-
-		//label.visible = true;
-		//label.setText(currentlyHovered.image360.file);
-		//currentlyHovered.getWorldPosition(label.position);
+		if(intersection.object.parent.visible===true)
+		{
+		this.currentlyHovered = intersection.object.parent.children[0];
+		this.currentlyHovered.material = this.hoverMaterial;
+		}
+		
 	}
 
 	update(){
 
 		let {viewer} = this;
-
-		if(currentlyHovered){
-			currentlyHovered.material = sm;
-			currentlyHovered = null;
+		if(this.currentlyHovered){
+			this.currentlyHovered.material = this.sm;
+			this.currentlyHovered = null;
 		}
 
 		if(this.selectingEnabled){
@@ -251,94 +309,96 @@ export class Images360 extends EventDispatcher{
 		}
 
 	}
-
 };
 
 
 export class Images360Loader{
 
-	static async load(url, viewer, params = {}){
+	static async load(url, imgsUrl, viewer, tm_data, params = {}){
 
 		if(!params.transform){
 			params.transform = {
 				forward: a => a,
 			};
 		}
+
+		let tmatrix, toffset;
+		
+		tmatrix = tm_data.tm;
+		toffset = tm_data.offset;
 		
-		let response = await fetch(`${url}/coordinates.txt`);
+		let response = await fetch(url);
 		let text = await response.text();
-
-		let lines = text.split(/\r?\n/);
-		let coordinateLines = lines.slice(1);
+		let imgData = JSON.parse(text);
 
 		let images360 = new Images360(viewer);
 
-		for(let line of coordinateLines){
-
-			if(line.trim().length === 0){
-				continue;
-			}
-
-			let tokens = line.split(/\t/);
-
-			let [filename, time, long, lat, alt, course, pitch, roll] = tokens;
-			time = parseFloat(time);
-			long = parseFloat(long);
-			lat = parseFloat(lat);
-			alt = parseFloat(alt);
-			course = parseFloat(course);
-			pitch = parseFloat(pitch);
-			roll = parseFloat(roll);
-
-			filename = filename.replace(/"/g, "");
-			let file = `${url}/${filename}`;
-
-			let image360 = new Image360(file, time, long, lat, alt, course, pitch, roll);
-
-			let xy = params.transform.forward([long, lat]);
-			let position = [...xy, alt];
+		Object.keys(imgData).forEach(imgName => {
+			let raw_position = imgData[imgName].position;
+			let rotation = imgData[imgName].rotation;
+			
+			const pos = new THREE.Vector4(raw_position[0], raw_position[1], raw_position[2], 1);
+			pos.applyMatrix4(tmatrix);
+			const long = parseFloat(pos.x - toffset[0]);
+			const lat = parseFloat(pos.y - toffset[1]);
+			const alt = parseFloat((pos.z - toffset[2]));
+			const course = parseFloat(rotation[0]);
+			const pitch = parseFloat(rotation[1]);
+			const roll = parseFloat(rotation[2]);
+
+			let file = `${imgsUrl}/${imgName}`;
+			let thumbnail = `${imgsUrl}/thumbnails/${imgName}`;
+			let image360 = new Image360(file, thumbnail, long, lat, alt, course, pitch, roll);
+
+			let position = [long, lat, alt];
 			image360.position = position;
 
 			images360.images.push(image360);
-		}
+		});
 
-		Images360Loader.createSceneNodes(images360, params.transform);
+		images360.images.sort(function (a, b) {
+			const getFileNumber = (file) => {
+				const numberPattern = /\d+/g;
+				const numbers = file.match(numberPattern);
+				if (numbers) {
+				return numbers.map((num) => num.padStart(10, '0')).join('');
+				}
+				return file;
+			};
+
+			const fileANumber = getFileNumber(a.file);
+			const fileBNumber = getFileNumber(b.file);
+			return fileANumber.localeCompare(fileBNumber);
+		});
 
-		return images360;
+		 Images360Loader.createSceneNodes(images360);
+			return images360;
 
 	}
 
-	static createSceneNodes(images360, transform){
+	static createSceneNodes(images360){
 
 		for(let image360 of images360.images){
 			let {longitude, latitude, altitude} = image360;
-			let xy = transform.forward([longitude, latitude]);
-
-			let mesh = new THREE.Mesh(sg, sm);
-			mesh.position.set(...xy, altitude);
-			mesh.scale.set(1, 1, 1);
-			mesh.material.transparent = true;
-			mesh.material.opacity = 0.75;
-			mesh.image360 = image360;
-
-			{ // orientation
-				var {course, pitch, roll} = image360;
-				mesh.rotation.set(
-					THREE.Math.degToRad(+roll + 90),
-					THREE.Math.degToRad(-pitch),
-					THREE.Math.degToRad(-course + 90),
-					"ZYX"
-				);
-			}
-
-			images360.node.add(mesh);
-
-			image360.mesh = mesh;
+			let ringMesh = new THREE.Mesh(new THREE.RingGeometry( 0.35, .5, 32 ), new THREE.MeshBasicMaterial({side: THREE.DoubleSide, color:'#FF843F'}));
+			ringMesh.position.set(longitude, latitude, altitude - 2.0);
+			ringMesh.scale.set(1, 1, 1);
+			ringMesh.material.transparent = true;
+			ringMesh.material.opacity = 0.75;
+			ringMesh.image360 = image360;
+			let circleMesh = new THREE.Mesh(new THREE.CircleGeometry( .5, 32 ), new THREE.MeshBasicMaterial({side:THREE.DoubleSide}));
+			circleMesh.position.set(longitude, latitude, altitude - 2.0);
+			circleMesh.scale.set(1, 1, 1);
+			circleMesh.material.transparent = true;
+			circleMesh.material.opacity = 0;
+			circleMesh.image360 = image360;
+			const ringGroup = new THREE.Group();
+			ringGroup.add( ringMesh );
+			ringGroup.add( circleMesh );
+			images360.node.add(ringGroup);
+			image360.ringGroup=ringGroup
 		}
 	}
-
-	
-
 };
 
 
diff --git a/src/modules/OrientedImages/OrientedImageControls.js b/src/modules/OrientedImages/OrientedImageControls.js
index 26ac322d..5b43c6ca 100644
--- a/src/modules/OrientedImages/OrientedImageControls.js
+++ b/src/modules/OrientedImages/OrientedImageControls.js
@@ -29,15 +29,24 @@ export class OrientedImageControls extends EventDispatcher{
 
 		this.shear = [0, 0];
 
+		this.changeEvent = new CustomEvent("camerachange");
+
+
 		// const style = ``;
-		this.elUp =    $(`<input type="button" value="" style="position: absolute; top: 10px; left: calc(50%); z-index: 1000" />`);
-		this.elRight = $(`<input type="button" value="" style="position: absolute; top: calc(50%); right: 10px; z-index: 1000" />`);
-		this.elDown =  $(`<input type="button" value="" style="position: absolute; bottom: 10px; left: calc(50%); z-index: 1000" />`);
-		this.elLeft =  $(`<input type="button" value="" style="position: absolute; top: calc(50%); left: 10px; z-index: 1000" />`);
-		this.elExit = $(`<input type="button" value="Back to 3D view" style="position: absolute; bottom: 10px; right: 10px; z-index: 1000" />`);
+		this.elUp =    $(`<input type="button" value="" style="position: absolute; top: 10px; left: calc(50%); z-index: 1000; display: none" />`);
+		this.elRight = $(`<input type="button" value="" style="position: absolute; top: calc(50%); right: 10px; z-index: 1000; display: none" />`);
+		this.elDown =  $(`<input type="button" value="" style="position: absolute; bottom: 10px; left: calc(50%); z-index: 1000; display: none" />`);
+		this.elLeft =  $(`<input type="button" value="" style="position: absolute; top: calc(50%); left: 10px; z-index: 1000; display: none" />`);
+		this.elExit = $(`<input type="button" value="Back to 3D view" style="position: absolute; bottom: 10px; right: 10px; z-index: 1000; display: none" />`);
 
 		this.elExit.click( () => {
 			this.release();
+			const event = new CustomEvent("imageUnload", {
+				detail: {
+					viewer: this.viewer.canvasId
+				}
+			});
+			document.dispatchEvent(event);
 		});
 
 		this.elUp.click(() => {
@@ -68,7 +77,13 @@ export class OrientedImageControls extends EventDispatcher{
 		this.sceneControls = new THREE.Scene();
 
 		let scroll = (e) => {
-			this.fovDelta += -e.delta * 1.0;
+			// this.fovDelta += -e.delta * 1.0;
+			this.shear = [0, 0];
+			let fov = this.viewer.getFOV() + (-e.delta * 5);
+			if (fov > 10 && fov < 100) {
+				this.viewer.setFOV(fov);
+				document.dispatchEvent(this.changeEvent)
+			}
 		};
 
 		this.addEventListener('mousewheel', scroll);
@@ -103,9 +118,13 @@ export class OrientedImageControls extends EventDispatcher{
 		elRoot.append(this.elDown);
 		elRoot.append(this.elLeft);
 		elRoot.append(this.elExit);
+
+		this.viewer.setFOV(30);
+
 	}
 
 	release(){
+
 		this.image = null;
 
 		this.viewer.scene.overrideCamera = null;
@@ -117,7 +136,13 @@ export class OrientedImageControls extends EventDispatcher{
 		this.elExit.detach();
 
 		this.viewer.setFOV(this.originalFOV);
+		this.viewer.scene.cameraP.fov = this.originalFOV;
 		this.viewer.setControls(this.originalControls);
+		this.viewer.controls.enabled = true;
+	}
+
+	stop() {
+		this.release();
 	}
 
 	setScene (scene) {
diff --git a/src/modules/OrientedImages/OrientedImages.js b/src/modules/OrientedImages/OrientedImages.js
index ce7a650d..4da9cd47 100644
--- a/src/modules/OrientedImages/OrientedImages.js
+++ b/src/modules/OrientedImages/OrientedImages.js
@@ -1,14 +1,9 @@
-
 import * as THREE from "../../../libs/three.js/build/three.module.js";
-import {OrientedImageControls} from "./OrientedImageControls.js";
+import { OrientedImageControls } from "./OrientedImageControls.js";
 import { EventDispatcher } from "../../EventDispatcher.js";
 
-// https://support.pix4d.com/hc/en-us/articles/205675256-How-are-yaw-pitch-roll-defined
-// https://support.pix4d.com/hc/en-us/articles/202558969-How-are-omega-phi-kappa-defined
-
-function createMaterial(){
-
-	let vertexShader = `
+function createMaterial() {
+  let vertexShader = `
 	uniform float uNear;
 	varying vec2 vUV;
 	varying vec4 vDebug;
@@ -23,7 +18,7 @@ function createMaterial(){
 	}
 	`;
 
-	let fragmentShader = `
+  let fragmentShader = `
 	uniform sampler2D tColor;
 	uniform float uOpacity;
 	varying vec2 vUV;
@@ -34,457 +29,461 @@ function createMaterial(){
 		gl_FragColor.a = uOpacity;
 	}
 	`;
-	const material = new THREE.ShaderMaterial( {
-		uniforms: {
-			// time: { value: 1.0 },
-			// resolution: { value: new THREE.Vector2() }
-			tColor: {value: new THREE.Texture() },
-			uNear: {value: 0.0},
-			uOpacity: {value: 1.0},
-		},
-		vertexShader: vertexShader,
-		fragmentShader: fragmentShader,
-		side: THREE.DoubleSide,
-	} );
-
-	material.side = THREE.DoubleSide;
-
-	return material;
+  const material = new THREE.ShaderMaterial({
+    uniforms: {
+      tColor: { value: new THREE.Texture() },
+      uNear: { value: 0.0 },
+      uOpacity: { value: 1.0 },
+    },
+    vertexShader: vertexShader,
+    fragmentShader: fragmentShader,
+    side: THREE.DoubleSide,
+  });
+
+  material.side = THREE.DoubleSide;
+
+  return material;
 }
 
 const planeGeometry = new THREE.PlaneGeometry(1, 1);
 const lineGeometry = new THREE.Geometry();
 
 lineGeometry.vertices.push(
-	new THREE.Vector3(-0.5, -0.5, 0),
-	new THREE.Vector3( 0.5, -0.5, 0),
-	new THREE.Vector3( 0.5,  0.5, 0),
-	new THREE.Vector3(-0.5,  0.5, 0),
-	new THREE.Vector3(-0.5, -0.5, 0),
+  new THREE.Vector3(-0.5, -0.5, 0),
+  new THREE.Vector3(0.5, -0.5, 0),
+  new THREE.Vector3(0.5, 0.5, 0),
+  new THREE.Vector3(-0.5, 0.5, 0),
+  new THREE.Vector3(-0.5, -0.5, 0)
 );
 
-export class OrientedImage{
-
-	constructor(id){
-
-		this.id = id;
-		this.fov = 1.0;
-		this.position = new THREE.Vector3();
-		this.rotation = new THREE.Vector3();
-		this.width = 0;
-		this.height = 0;
-		this.fov = 1.0;
-
-		const material = createMaterial();
-		const lineMaterial = new THREE.LineBasicMaterial( { color: 0x00ff00 } );
-		this.mesh = new THREE.Mesh(planeGeometry, material);
-		this.line = new THREE.Line(lineGeometry, lineMaterial);
-		this.texture = null;
-
-		this.mesh.orientedImage = this;
-	}
-
-	set(position, rotation, dimension, fov){
-
-		let radians = rotation.map(THREE.Math.degToRad);
-
-		this.position.set(...position);
-		this.mesh.position.set(...position);
-
-		this.rotation.set(...radians);
-		this.mesh.rotation.set(...radians);
-
-		[this.width, this.height] = dimension;
-		this.mesh.scale.set(this.width / this.height, 1, 1);
-
-		this.fov = fov;
-
-		this.updateTransform();
-	}
-
-	updateTransform(){
-		let {mesh, line, fov} = this;
-
-		mesh.updateMatrixWorld();
-		const dir = mesh.getWorldDirection();
-		const alpha = THREE.Math.degToRad(fov / 2);
-		const d = -0.5 / Math.tan(alpha);
-		const move = dir.clone().multiplyScalar(d);
-		mesh.position.add(move);
-
-		line.position.copy(mesh.position);
-		line.scale.copy(mesh.scale);
-		line.rotation.copy(mesh.rotation);
-	}
-
-};
-
-export class OrientedImages extends EventDispatcher{
-
-	constructor(){
-		super();
-
-		this.node = null;
-		this.cameraParams = null;
-		this.imageParams = null;
-		this.images = null;
-		this._visible = true;
-	}
-
-	set visible(visible){
-		if(this._visible === visible){
-			return;
-		}
-
-		for(const image of this.images){
-			image.mesh.visible = visible;
-			image.line.visible = visible;
-		}
-
-		this._visible = visible;
-		this.dispatchEvent({
-			type: "visibility_changed",
-			images: this,
-		});
-	}
-
-	get visible(){
-		return this._visible;
-	}
-
-
-};
-
-export class OrientedImageLoader{
-
-	static async loadCameraParams(path){
-		const res = await fetch(path);
-		const text = await res.text();
-
-		const parser = new DOMParser();
-		const doc = parser.parseFromString(text, "application/xml");
-
-		const width = parseInt(doc.getElementsByTagName("width")[0].textContent);
-		const height = parseInt(doc.getElementsByTagName("height")[0].textContent);
-		const f = parseFloat(doc.getElementsByTagName("f")[0].textContent);
-
-		let a = (height / 2)  / f;
-		let fov = 2 * THREE.Math.radToDeg(Math.atan(a));
-
-		const params = {
-			path: path,
-			width: width,
-			height: height,
-			f: f,
-			fov: fov,
-		};
-
-		return params;
-	}
-
-	static async loadImageParams(path){
-
-		const response = await fetch(path);
-		if(!response.ok){
-			console.error(`failed to load ${path}`);
-			return;
-		}
-
-		const content = await response.text();
-		const lines = content.split(/\r?\n/);
-		const imageParams = [];
-
-		for(let i = 1; i < lines.length; i++){
-			const line = lines[i];
-
-			if(line.startsWith("#")){
-				continue;
-			}
-
-			const tokens = line.split(/\s+/);
-
-			if(tokens.length < 6){
-				continue;
-			}
-
-			const params = {
-				id: tokens[0],
-				x: Number.parseFloat(tokens[1]),
-				y: Number.parseFloat(tokens[2]),
-				z: Number.parseFloat(tokens[3]),
-				omega: Number.parseFloat(tokens[4]),
-				phi: Number.parseFloat(tokens[5]),
-				kappa: Number.parseFloat(tokens[6]),
-			};
-
-			// const whitelist = ["47518.jpg"];
-			// if(whitelist.includes(params.id)){
-			// 	imageParams.push(params);
-			// }
-			imageParams.push(params);
-		}
-
-		// debug
-		//return [imageParams[50]];
-
-		return imageParams;
-	}
+export class OrientedImage {
+  constructor(id) {
+    this.id = id;
+    this.fov = 1.0;
+    this.position = new THREE.Vector3();
+    this.rotation = new THREE.Vector3();
+    this.width = 0;
+    this.height = 0;
+    this.fov = 1.0;
+
+    const material = createMaterial();
+    const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
+    this.mesh = new THREE.Mesh(planeGeometry, material);
+    this.line = new THREE.Line(lineGeometry, lineMaterial);
+    this.texture = null;
+
+    this.mesh.orientedImage = this;
+  }
+
+  set(position, rotation, dimension, fov) {
+    let radians = rotation.map(THREE.Math.degToRad);
+
+    this.position.set(...position);
+    this.mesh.position.set(...position);
+
+    this.rotation.set(...radians);
+    this.mesh.rotation.set(...radians);
+
+    [this.width, this.height] = dimension;
+    this.mesh.scale.set(this.width / this.height, 1, 1);
+
+    this.fov = fov;
+
+    this.updateTransform();
+  }
+
+  updateTransform() {
+    let { mesh, line, fov } = this;
+
+    mesh.updateMatrixWorld();
+    var dir = new THREE.Vector3();
+    mesh.getWorldDirection(dir);
+    const alpha = THREE.Math.degToRad(fov / 2);
+    const d = -0.5 / Math.tan(alpha);
+    const move = dir.clone().multiplyScalar(d);
+    mesh.position.add(move);
+
+    line.position.copy(mesh.position);
+    line.scale.copy(mesh.scale);
+    line.rotation.copy(mesh.rotation);
+  }
+}
 
-	static async load(cameraParamsPath, imageParamsPath, viewer){
-
-		const tStart = performance.now();
-
-		const [cameraParams, imageParams] = await Promise.all([
-			OrientedImageLoader.loadCameraParams(cameraParamsPath),
-			OrientedImageLoader.loadImageParams(imageParamsPath),
-		]);
-
-		const orientedImageControls = new OrientedImageControls(viewer);
-		const raycaster = new THREE.Raycaster();
-
-		const tEnd = performance.now();
-		console.log(tEnd - tStart);
-
-		// const sp = new THREE.PlaneGeometry(1, 1);
-		// const lg = new THREE.Geometry();
-
-		// lg.vertices.push(
-		// 	new THREE.Vector3(-0.5, -0.5, 0),
-		// 	new THREE.Vector3( 0.5, -0.5, 0),
-		// 	new THREE.Vector3( 0.5,  0.5, 0),
-		// 	new THREE.Vector3(-0.5,  0.5, 0),
-		// 	new THREE.Vector3(-0.5, -0.5, 0),
-		// );
-
-		const {width, height} = cameraParams;
-		const orientedImages = [];
-		const sceneNode = new THREE.Object3D();
-		sceneNode.name = "oriented_images";
-
-		for(const params of imageParams){
-
-			// const material = createMaterial();
-			// const lm = new THREE.LineBasicMaterial( { color: 0x00ff00 } );
-			// const mesh = new THREE.Mesh(sp, material);
-
-			const {x, y, z, omega, phi, kappa} = params;
-			// const [rx, ry, rz] = [omega, phi, kappa]
-			// 	.map(THREE.Math.degToRad);
-			
-			// mesh.position.set(x, y, z);
-			// mesh.scale.set(width / height, 1, 1);
-			// mesh.rotation.set(rx, ry, rz);
-			// {
-			// 	mesh.updateMatrixWorld();
-			// 	const dir = mesh.getWorldDirection();
-			// 	const alpha = THREE.Math.degToRad(cameraParams.fov / 2);
-			// 	const d = -0.5 / Math.tan(alpha);
-			// 	const move = dir.clone().multiplyScalar(d);
-			// 	mesh.position.add(move);
-			// }
-			// sceneNode.add(mesh);
-
-			// const line = new THREE.Line(lg, lm);
-			// line.position.copy(mesh.position);
-			// line.scale.copy(mesh.scale);
-			// line.rotation.copy(mesh.rotation);
-			// sceneNode.add(line);
-
-			let orientedImage = new OrientedImage(params.id);
-			// orientedImage.setPosition(x, y, z);
-			// orientedImage.setRotation(omega, phi, kappa);
-			// orientedImage.setDimension(width, height);
-			let position = [x, y, z];
-			let rotation = [omega, phi, kappa];
-			let dimension = [width, height];
-			orientedImage.set(position, rotation, dimension, cameraParams.fov);
-
-			sceneNode.add(orientedImage.mesh);
-			sceneNode.add(orientedImage.line);
-			
-			orientedImages.push(orientedImage);
-		}
-
-		let hoveredElement = null;
-		let clipVolume = null;
-
-		const onMouseMove = (evt) => {
-			const tStart = performance.now();
-			if(hoveredElement){
-				hoveredElement.line.material.color.setRGB(0, 1, 0);
-			}
-			evt.preventDefault();
-
-			//var array = getMousePosition( container, evt.clientX, evt.clientY );
-			const rect = viewer.renderer.domElement.getBoundingClientRect();
-			const [x, y] = [evt.clientX, evt.clientY];
-			const array = [ 
-				( x - rect.left ) / rect.width, 
-				( y - rect.top ) / rect.height 
-			];
-			const onClickPosition = new THREE.Vector2(...array);
-			//const intersects = getIntersects(onClickPosition, scene.children);
-			const camera = viewer.scene.getActiveCamera();
-			const mouse = new THREE.Vector3(
-				+ ( onClickPosition.x * 2 ) - 1, 
-				- ( onClickPosition.y * 2 ) + 1 );
-			const objects = orientedImages.map(i => i.mesh);
-			raycaster.setFromCamera( mouse, camera );
-			const intersects = raycaster.intersectObjects( objects );
-			let selectionChanged = false;
-
-			if ( intersects.length > 0){
-				//console.log(intersects);
-				const intersection = intersects[0];
-				const orientedImage = intersection.object.orientedImage;
-				orientedImage.line.material.color.setRGB(1, 0, 0);
-				selectionChanged = hoveredElement !== orientedImage;
-				hoveredElement = orientedImage;
-			}else{
-				hoveredElement = null;
-			}
-
-			let shouldRemoveClipVolume = clipVolume !== null && hoveredElement === null;
-			let shouldAddClipVolume = clipVolume === null && hoveredElement !== null;
-
-			if(clipVolume !== null && (hoveredElement === null || selectionChanged)){
-				// remove existing
-				viewer.scene.removePolygonClipVolume(clipVolume);
-				clipVolume = null;
-			}
-			
-			if(shouldAddClipVolume || selectionChanged){
-				const img = hoveredElement;
-				const fov = cameraParams.fov;
-				const aspect  = cameraParams.width / cameraParams.height;
-				const near = 1.0;
-				const far = 1000 * 1000;
-				const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
-				camera.rotation.order = viewer.scene.getActiveCamera().rotation.order;
-				camera.rotation.copy(img.mesh.rotation);
-				{
-					const mesh = img.mesh;
-					const dir = mesh.getWorldDirection();
-					const pos = mesh.position;
-					const alpha = THREE.Math.degToRad(fov / 2);
-					const d = 0.5 / Math.tan(alpha);
-					const newCamPos = pos.clone().add(dir.clone().multiplyScalar(d));
-					const newCamDir = pos.clone().sub(newCamPos);
-					const newCamTarget = new THREE.Vector3().addVectors(
-						newCamPos,
-						newCamDir.clone().multiplyScalar(viewer.getMoveSpeed()));
-					camera.position.copy(newCamPos);
-				}
-				let volume = new Potree.PolygonClipVolume(camera);
-				let m0 = new THREE.Mesh();
-				let m1 = new THREE.Mesh();
-				let m2 = new THREE.Mesh();
-				let m3 = new THREE.Mesh();
-				m0.position.set(-1, -1, 0);
-				m1.position.set( 1, -1, 0);
-				m2.position.set( 1,  1, 0);
-				m3.position.set(-1,  1, 0);
-				volume.markers.push(m0, m1, m2, m3);
-				volume.initialized = true;
-				
-				viewer.scene.addPolygonClipVolume(volume);
-				clipVolume = volume;
-			}
-			const tEnd = performance.now();
-			//console.log(tEnd - tStart);
-		};
-
-		const moveToImage = (image) => {
-			console.log("move to image " + image.id);
-
-			const mesh = image.mesh;
-			const newCamPos = image.position.clone();
-			const newCamTarget = mesh.position.clone();
-
-			viewer.scene.view.setView(newCamPos, newCamTarget, 500, () => {
-				orientedImageControls.capture(image);
-			});
-
-			if(image.texture === null){
-
-				const target = image;
-
-				const tmpImagePath = `${Potree.resourcePath}/images/loading.jpg`;
-				new THREE.TextureLoader().load(tmpImagePath,
-					(texture) => {
-						if(target.texture === null){
-							target.texture = texture;
-							target.mesh.material.uniforms.tColor.value = texture;
-							mesh.material.needsUpdate = true;
-						}
-					}
-				);
-
-				const imagePath = `${imageParamsPath}/../${target.id}`;
-				new THREE.TextureLoader().load(imagePath,
-					(texture) => {
-						target.texture = texture;
-						target.mesh.material.uniforms.tColor.value = texture;
-						mesh.material.needsUpdate = true;
-					}
-				);
-				
-
-			}
-		};
-
-		const onMouseClick = (evt) => {
-
-			if(orientedImageControls.hasSomethingCaptured()){
-				return;
-			}
-
-			if(hoveredElement){
-				moveToImage(hoveredElement);
-			}
-		};
-		viewer.renderer.domElement.addEventListener( 'mousemove', onMouseMove, false );
-		viewer.renderer.domElement.addEventListener( 'mousedown', onMouseClick, false );
-
-		viewer.addEventListener("update", () => {
-
-			for(const image of orientedImages){
-				const world = image.mesh.matrixWorld;
-				const {width, height} = image;
-				const aspect = width / height;
-
-				const camera = viewer.scene.getActiveCamera();
-
-				const imgPos = image.mesh.getWorldPosition(new THREE.Vector3());
-				const camPos = camera.position;
-				const d = camPos.distanceTo(imgPos);
-
-				const minSize = 1; // in degrees of fov
-				const a = THREE.Math.degToRad(minSize);
-				let r = d * Math.tan(a);
-				r = Math.max(r, 1);
-
-
-				image.mesh.scale.set(r * aspect, r, 1);
-				image.line.scale.set(r * aspect, r, 1);
-
-				image.mesh.material.uniforms.uNear.value = camera.near;
-
-			}
-
-		});
-
-		const images = new OrientedImages();
-		images.node = sceneNode;
-		images.cameraParamsPath = cameraParamsPath;
-		images.imageParamsPath = imageParamsPath;
-		images.cameraParams = cameraParams;
-		images.imageParams = imageParams;
-		images.images = orientedImages;
-
-		Potree.debug.moveToImage = moveToImage;
-
-		return images;
-	}
+export class OrientedImages extends EventDispatcher {
+  constructor() {
+    super();
+
+    this.node = null;
+    this.cameraParams = null;
+    this.imageParams = null;
+    this.images = null;
+    this._visible = true;
+    this.focused = null;
+  }
+
+  set visible(visible) {
+    if (this._visible === visible) {
+      return;
+    }
+
+    for (const image of this.images) {
+      image.mesh.visible = visible;
+      image.line.visible = visible;
+    }
+
+    this._visible = visible;
+    this.dispatchEvent({
+      type: "visibility_changed",
+      images: this,
+    });
+  }
+
+  get visible() {
+    return this._visible;
+  }
 }
 
+export class OrientedImageLoader {
+  static async loadCameraParams(path) {
+    const res = await fetch(path);
+    const text = await res.text();
+
+    const parser = new DOMParser();
+    const doc = parser.parseFromString(text, "application/xml");
+
+    const width = parseInt(doc.getElementsByTagName("width")[0].textContent);
+    const height = parseInt(doc.getElementsByTagName("height")[0].textContent);
+    const f = parseFloat(doc.getElementsByTagName("f")[0].textContent);
+
+    let a = height / 2 / f;
+    let fov = 2 * THREE.Math.radToDeg(Math.atan(a));
+
+    const params = {
+      path: path,
+      width: width,
+      height: height,
+      f: f,
+      fov: fov,
+    };
+
+    return params;
+  }
+
+  static async loadImageParams(path, tm) {
+    const response = await fetch(path);
+    if (!response.ok) {
+      console.error(`failed to load ${path}`);
+      return;
+    }
+
+    const content = await response.text();
+
+    const imageParams = [];
+
+    const imgData = JSON.parse(content);
+
+    imgData.camname.forEach((imgName, index) => {
+      const rawPos = new THREE.Vector4(
+        Number.parseFloat(imgData.camX[index]),
+        Number.parseFloat(imgData.camY[index]),
+        Number.parseFloat(imgData.camZ[index]),
+        1
+      );
+      rawPos.applyMatrix4(tm);
+
+      const params = {
+        id: imgData.camname[index],
+        x: Number.parseFloat(imgData.camX[index]),
+        y: Number.parseFloat(imgData.camY[index]),
+        z: Number.parseFloat(imgData.camZ[index]),
+        x_tm: rawPos.x,
+        y_tm: rawPos.y,
+        z_tm: rawPos.z,
+        omega: Number.parseFloat(imgData.camRoll[index]),
+        phi: Number.parseFloat(imgData.camPitch[index]),
+        kappa: Number.parseFloat(imgData.camYaw[index]),
+      };
+
+      imageParams.push(params);
+    });
+
+    const width = parseInt(imgData.camPix[0]);
+    const height = parseInt(imgData.camPix[1]);
+    const f = parseFloat(imgData.camFocal);
+
+    let a = height / 2 / f;
+    let fov = 2 * THREE.Math.radToDeg(Math.atan(a));
+
+    const params = {
+      path: path,
+      width: width,
+      height: height,
+      f: f,
+      fov: fov,
+    };
+
+    return [params, imageParams];
+  }
+
+  static async load(imageParamsPath, imagesPath, viewer, tm_data) {
+    const tStart = performance.now();
+
+    let tmatrix, toffset;
+
+    tmatrix = tm_data.tm;
+    toffset = tm_data.offset;
+
+    const [cameraParams, imageParams] =
+      await OrientedImageLoader.loadImageParams(imageParamsPath, tmatrix);
+
+    const orientedImageControls = new OrientedImageControls(viewer);
+    const raycaster = new THREE.Raycaster();
+
+    const tEnd = performance.now();
+    console.log(tEnd - tStart);
+
+    const { width, height } = cameraParams;
+    const orientedImages = [];
+    const sceneNode = new THREE.Object3D();
+    sceneNode.name = "oriented_images";
+
+    for (const params of imageParams) {
+      const { x, y, z, x_tm, y_tm, z_tm, omega, phi, kappa } = params;
+      let orientedImage = new OrientedImage(params.id);
+      let position = [x, y, z];
+      let rotation = [omega, phi, kappa];
+      let dimension = [width, height];
+      orientedImage.set(position, rotation, dimension, cameraParams.fov);
+      orientedImage.mesh.applyMatrix4(tmatrix);
+      let curMeshPos = orientedImage.mesh.position.clone();
+      orientedImage.mesh.position.set(
+        curMeshPos.x - toffset[0],
+        curMeshPos.y - toffset[1],
+        curMeshPos.z - toffset[2]
+      );
+      orientedImage.line.applyMatrix4(tmatrix);
+      let curLinePos = orientedImage.line.position.clone();
+      orientedImage.line.position.set(
+        curLinePos.x - toffset[0],
+        curLinePos.y - toffset[1],
+        curLinePos.z - toffset[2]
+      );
+      orientedImage.position.set(
+        x_tm - toffset[0],
+        y_tm - toffset[1],
+        z_tm - toffset[2]
+      );
+      sceneNode.add(orientedImage.mesh);
+      sceneNode.add(orientedImage.line);
+
+      orientedImages.push(orientedImage);
+    }
+
+    let hoveredElement = null;
+    let clipVolume = null;
+
+    const images = new OrientedImages();
+    images.node = sceneNode;
+    images.imageParamsPath = imageParamsPath;
+    images.cameraParams = cameraParams;
+    images.imageParams = imageParams;
+    images.images = orientedImages;
+    images.hovered = hoveredElement;
+
+    const onMouseMove = (evt) => {
+      const tStart = performance.now();
+      if (hoveredElement) {
+        hoveredElement.line.material.color.setRGB(0, 1, 0);
+      }
+      evt.preventDefault();
+      if (images.visible) {
+        const rect = viewer.renderer.domElement.getBoundingClientRect();
+        const [x, y] = [evt.clientX, evt.clientY];
+        const array = [
+          (x - rect.left) / rect.width,
+          (y - rect.top) / rect.height,
+        ];
+        const onClickPosition = new THREE.Vector2(...array);
+        const camera = viewer.scene.getActiveCamera();
+        const mouse = new THREE.Vector3(
+          +(onClickPosition.x * 2) - 1,
+          -(onClickPosition.y * 2) + 1
+        );
+        const objects = orientedImages.map((i) => i.mesh);
+        raycaster.setFromCamera(mouse, camera);
+        const intersects = raycaster.intersectObjects(objects);
+        let selectionChanged = false;
+
+        if (intersects.length > 0) {
+          const intersection = intersects[0];
+          const orientedImage = intersection.object.orientedImage;
+          orientedImage.line.material.color.setRGB(1, 0, 0);
+          selectionChanged = hoveredElement !== orientedImage;
+          hoveredElement = orientedImage;
+        } else {
+          hoveredElement = null;
+        }
+
+        let shouldRemoveClipVolume =
+          clipVolume !== null && hoveredElement === null;
+        let shouldAddClipVolume =
+          clipVolume === null && hoveredElement !== null;
+
+        if (
+          clipVolume !== null &&
+          (hoveredElement === null || selectionChanged)
+        ) {
+          // remove existing
+          viewer.scene.removePolygonClipVolume(clipVolume);
+          clipVolume = null;
+        }
+
+        if (shouldAddClipVolume || selectionChanged) {
+          const img = hoveredElement;
+          const fov = cameraParams.fov;
+          const aspect = cameraParams.width / cameraParams.height;
+          const near = 1.0;
+          const far = 1000 * 1000;
+          const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
+          camera.rotation.order = viewer.scene.getActiveCamera().rotation.order;
+          camera.rotation.copy(img.mesh.rotation);
+          {
+            const mesh = img.mesh;
+            const dir = mesh.getWorldDirection();
+            const pos = mesh.position;
+            const alpha = THREE.Math.degToRad(fov / 2);
+            const d = 0.5 / Math.tan(alpha);
+            const newCamPos = pos.clone().add(dir.clone().multiplyScalar(d));
+            const newCamDir = pos.clone().sub(newCamPos);
+            const newCamTarget = new THREE.Vector3().addVectors(
+              newCamPos,
+              newCamDir.clone().multiplyScalar(viewer.getMoveSpeed())
+            );
+            camera.position.copy(newCamPos);
+          }
+          let volume = new Potree.PolygonClipVolume(camera);
+          let m0 = new THREE.Mesh();
+          let m1 = new THREE.Mesh();
+          let m2 = new THREE.Mesh();
+          let m3 = new THREE.Mesh();
+          m0.position.set(-1, -1, 0);
+          m1.position.set(1, -1, 0);
+          m2.position.set(1, 1, 0);
+          m3.position.set(-1, 1, 0);
+          volume.markers.push(m0, m1, m2, m3);
+          volume.initialized = true;
+
+          viewer.scene.addPolygonClipVolume(volume);
+          clipVolume = volume;
+        }
+        const tEnd = performance.now();
+        //console.log(tEnd - tStart);
+      } else {
+        hoveredElement = null;
+        if (clipVolume) {
+          viewer.scene.removePolygonClipVolume(clipVolume);
+          clipVolume = null;
+        }
+      }
+    };
+
+    const moveToImage = async (image, sendEvent = true) => {
+      viewer.controls.enabled = false;
+
+      
+
+      const mesh = image.mesh;
+      const target = image;
+
+      const newCamPos = image.position.clone();
+      const newCamTarget = mesh.position.clone();
+
+      viewer.scene.view.setView(newCamPos, newCamTarget);
+	if (sendEvent) {
+        const event = new CustomEvent("imageLoad", {
+          detail: {
+            viewer: viewer.canvasId,
+            image,
+          },
+        });
+        document.dispatchEvent(event);
+      }
+	  
+      function loadImageTexture(path) {
+        return new Promise((resolve, reject) => {
+          new THREE.TextureLoader().load(path, (texture) => {
+            resolve(texture);
+          });
+        });
+      }
+
+      function updateTexture(texture) {
+        target.texture = texture;
+        target.mesh.material.uniforms.tColor.value = texture;
+        mesh.material.needsUpdate = true;
+      }
+
+      viewer.scene.orientedImages[0].focused = image;
+      const tmpImagePath = `${imagesPath}/thumbnails/${target.id}`;
+      let texture = await loadImageTexture(tmpImagePath);
+      updateTexture(texture);
+      setTimeout(() => {
+        orientedImageControls.capture(image);
+      }, 100);
+      const imagePath = `${imagesPath}/${target.id}`;
+      let texture_org = await loadImageTexture(imagePath);
+      updateTexture(texture_org);
+      image.texture = texture_org;
+    };
+
+    const onMouseClick = (evt) => {
+      if (orientedImageControls.hasSomethingCaptured()) {
+        return;
+      }
+
+      if (hoveredElement) {
+        moveToImage(hoveredElement);
+      }
+    };
+    viewer.renderer.domElement.addEventListener(
+      "mousemove",
+      onMouseMove,
+      false
+    );
+    viewer.renderer.domElement.addEventListener(
+      "mousedown",
+      onMouseClick,
+      false
+    );
+
+    viewer.addEventListener("update", () => {
+      for (const image of orientedImages) {
+        const world = image.mesh.matrixWorld;
+        const { width, height } = image;
+        const aspect = width / height;
+
+        const camera = viewer.scene.getActiveCamera();
+
+        const imgPos = image.mesh.getWorldPosition(new THREE.Vector3());
+        const camPos = camera.position;
+        const d = camPos.distanceTo(imgPos);
+
+        const minSize = 1; // in degrees of fov
+        const a = THREE.Math.degToRad(minSize);
+        let r = d * Math.tan(a);
+        r = Math.max(r, 1);
+
+        image.mesh.scale.set(r * aspect, r, 1);
+        image.line.scale.set(r * aspect, r, 1);
+
+        image.mesh.material.uniforms.uNear.value = camera.near;
+      }
+    });
+
+    images.moveToImage = moveToImage;
+    images.release = function () {
+      orientedImageControls.release();
+    };
+    return images;
+  }
+}
diff --git a/src/navigation/OrbitControls.js b/src/navigation/OrbitControls.js
index 520a11b3..2ed5150c 100644
--- a/src/navigation/OrbitControls.js
+++ b/src/navigation/OrbitControls.js
@@ -14,281 +14,323 @@
  */
 
 import * as THREE from "../../libs/three.js/build/three.module.js";
-import {MOUSE} from "../defines.js";
-import {Utils} from "../utils.js";
-import {EventDispatcher} from "../EventDispatcher.js";
-
- 
-export class OrbitControls extends EventDispatcher{
-	
-	constructor(viewer){
-		super();
-		
-		this.viewer = viewer;
-		this.renderer = viewer.renderer;
+import { MOUSE } from "../defines.js";
+import { Utils } from "../utils.js";
+import { EventDispatcher } from "../EventDispatcher.js";
 
-		this.scene = null;
-		this.sceneControls = new THREE.Scene();
-
-		this.rotationSpeed = 5;
+export class OrbitControls extends EventDispatcher {
+  constructor(viewer) {
+    super();
 
-		this.fadeFactor = 20;
-		this.yawDelta = 0;
-		this.pitchDelta = 0;
-		this.panDelta = new THREE.Vector2(0, 0);
-		this.radiusDelta = 0;
+    this.viewer = viewer;
+    this.renderer = viewer.renderer;
 
-		this.doubleClockZoomEnabled = true;
+    this.scene = null;
+    this.sceneControls = new THREE.Scene();
 
-		this.tweens = [];
-
-		let drag = (e) => {
-			if (e.drag.object !== null) {
-				return;
-			}
-
-			if (e.drag.startHandled === undefined) {
-				e.drag.startHandled = true;
-
-				this.dispatchEvent({type: 'start'});
-			}
-
-			let ndrag = {
-				x: e.drag.lastDrag.x / this.renderer.domElement.clientWidth,
-				y: e.drag.lastDrag.y / this.renderer.domElement.clientHeight
-			};
-
-			if (e.drag.mouse === MOUSE.LEFT) {
-				this.yawDelta += ndrag.x * this.rotationSpeed;
-				this.pitchDelta += ndrag.y * this.rotationSpeed;
-
-				this.stopTweens();
-			} else if (e.drag.mouse === MOUSE.RIGHT) {
-				this.panDelta.x += ndrag.x;
-				this.panDelta.y += ndrag.y;
-
-				this.stopTweens();
-			}
-		};
-
-		let drop = e => {
-			this.dispatchEvent({type: 'end'});
-		};
-
-		let scroll = (e) => {
-			let resolvedRadius = this.scene.view.radius + this.radiusDelta;
-
-			this.radiusDelta += -e.delta * resolvedRadius * 0.1;
-
-			this.stopTweens();
-		};
-
-		let dblclick = (e) => {
-			if(this.doubleClockZoomEnabled){
-				this.zoomToLocation(e.mouse);
-			}
-		};
-
-		let previousTouch = null;
-		let touchStart = e => {
-			previousTouch = e;
-		};
-
-		let touchEnd = e => {
-			previousTouch = e;
-		};
-
-		let touchMove = e => {
-			if (e.touches.length === 2 && previousTouch.touches.length === 2){
-				let prev = previousTouch;
-				let curr = e;
-
-				let prevDX = prev.touches[0].pageX - prev.touches[1].pageX;
-				let prevDY = prev.touches[0].pageY - prev.touches[1].pageY;
-				let prevDist = Math.sqrt(prevDX * prevDX + prevDY * prevDY);
-
-				let currDX = curr.touches[0].pageX - curr.touches[1].pageX;
-				let currDY = curr.touches[0].pageY - curr.touches[1].pageY;
-				let currDist = Math.sqrt(currDX * currDX + currDY * currDY);
-
-				let delta = currDist / prevDist;
-				let resolvedRadius = this.scene.view.radius + this.radiusDelta;
-				let newRadius = resolvedRadius / delta;
-				this.radiusDelta = newRadius - resolvedRadius;
-
-				this.stopTweens();
-			}else if(e.touches.length === 3 && previousTouch.touches.length === 3){
-				let prev = previousTouch;
-				let curr = e;
-
-				let prevMeanX = (prev.touches[0].pageX + prev.touches[1].pageX + prev.touches[2].pageX) / 3;
-				let prevMeanY = (prev.touches[0].pageY + prev.touches[1].pageY + prev.touches[2].pageY) / 3;
-
-				let currMeanX = (curr.touches[0].pageX + curr.touches[1].pageX + curr.touches[2].pageX) / 3;
-				let currMeanY = (curr.touches[0].pageY + curr.touches[1].pageY + curr.touches[2].pageY) / 3;
-
-				let delta = {
-					x: (currMeanX - prevMeanX) / this.renderer.domElement.clientWidth,
-					y: (currMeanY - prevMeanY) / this.renderer.domElement.clientHeight
-				};
-
-				this.panDelta.x += delta.x;
-				this.panDelta.y += delta.y;
-
-				this.stopTweens();
-			}
-
-			previousTouch = e;
-		};
-
-		this.addEventListener('touchstart', touchStart);
-		this.addEventListener('touchend', touchEnd);
-		this.addEventListener('touchmove', touchMove);
-		this.addEventListener('drag', drag);
-		this.addEventListener('drop', drop);
-		this.addEventListener('mousewheel', scroll);
-		this.addEventListener('dblclick', dblclick);
-	}
-
-	setScene (scene) {
-		this.scene = scene;
-	}
-
-	stop(){
-		this.yawDelta = 0;
-		this.pitchDelta = 0;
-		this.radiusDelta = 0;
-		this.panDelta.set(0, 0);
-	}
-	
-	zoomToLocation(mouse){
-		let camera = this.scene.getActiveCamera();
-		
-		let I = Utils.getMousePointCloudIntersection(
-			mouse,
-			camera,
-			this.viewer,
-			this.scene.pointclouds,
-			{pickClipped: true});
-
-		if (I === null) {
-			return;
-		}
-
-		let targetRadius = 0;
-		{
-			let minimumJumpDistance = 0.2;
-
-			let domElement = this.renderer.domElement;
-			let ray = Utils.mouseToRay(mouse, camera, domElement.clientWidth, domElement.clientHeight);
-
-			let nodes = I.pointcloud.nodesOnRay(I.pointcloud.visibleNodes, ray);
-			let lastNode = nodes[nodes.length - 1];
-			let radius = lastNode.getBoundingSphere(new THREE.Sphere()).radius;
-			targetRadius = Math.min(this.scene.view.radius, radius);
-			targetRadius = Math.max(minimumJumpDistance, targetRadius);
-		}
-
-		let d = this.scene.view.direction.multiplyScalar(-1);
-		let cameraTargetPosition = new THREE.Vector3().addVectors(I.location, d.multiplyScalar(targetRadius));
-		// TODO Unused: let controlsTargetPosition = I.location;
-
-		let animationDuration = 600;
-		let easing = TWEEN.Easing.Quartic.Out;
-
-		{ // animate
-			let value = {x: 0};
-			let tween = new TWEEN.Tween(value).to({x: 1}, animationDuration);
-			tween.easing(easing);
-			this.tweens.push(tween);
-
-			let startPos = this.scene.view.position.clone();
-			let targetPos = cameraTargetPosition.clone();
-			let startRadius = this.scene.view.radius;
-			let targetRadius = cameraTargetPosition.distanceTo(I.location);
-
-			tween.onUpdate(() => {
-				let t = value.x;
-				this.scene.view.position.x = (1 - t) * startPos.x + t * targetPos.x;
-				this.scene.view.position.y = (1 - t) * startPos.y + t * targetPos.y;
-				this.scene.view.position.z = (1 - t) * startPos.z + t * targetPos.z;
-
-				this.scene.view.radius = (1 - t) * startRadius + t * targetRadius;
-				this.viewer.setMoveSpeed(this.scene.view.radius);
-			});
-
-			tween.onComplete(() => {
-				this.tweens = this.tweens.filter(e => e !== tween);
-			});
-
-			tween.start();
-		}
-	}
-
-	stopTweens () {
-		this.tweens.forEach(e => e.stop());
-		this.tweens = [];
-	}
-
-	update (delta) {
-		let view = this.scene.view;
-
-		{ // apply rotation
-			let progression = Math.min(1, this.fadeFactor * delta);
-
-			let yaw = view.yaw;
-			let pitch = view.pitch;
-			let pivot = view.getPivot();
-
-			yaw -= progression * this.yawDelta;
-			pitch -= progression * this.pitchDelta;
-
-			view.yaw = yaw;
-			view.pitch = pitch;
-
-			let V = this.scene.view.direction.multiplyScalar(-view.radius);
-			let position = new THREE.Vector3().addVectors(pivot, V);
-
-			view.position.copy(position);
-		}
-
-		{ // apply pan
-			let progression = Math.min(1, this.fadeFactor * delta);
-			let panDistance = progression * view.radius * 3;
-
-			let px = -this.panDelta.x * panDistance;
-			let py = this.panDelta.y * panDistance;
-
-			view.pan(px, py);
-		}
-
-		{ // apply zoom
-			let progression = Math.min(1, this.fadeFactor * delta);
-
-			// let radius = view.radius + progression * this.radiusDelta * view.radius * 0.1;
-			let radius = view.radius + progression * this.radiusDelta;
-
-			let V = view.direction.multiplyScalar(-radius);
-			let position = new THREE.Vector3().addVectors(view.getPivot(), V);
-			view.radius = radius;
-
-			view.position.copy(position);
-		}
-
-		{
-			let speed = view.radius;
-			this.viewer.setMoveSpeed(speed);
-		}
-
-		{ // decelerate over time
-			let progression = Math.min(1, this.fadeFactor * delta);
-			let attenuation = Math.max(0, 1 - this.fadeFactor * delta);
-
-			this.yawDelta *= attenuation;
-			this.pitchDelta *= attenuation;
-			this.panDelta.multiplyScalar(attenuation);
-			// this.radiusDelta *= attenuation;
-			this.radiusDelta -= progression * this.radiusDelta;
-		}
-	}
-};
+    this.rotationSpeed = 5;
+
+    this.fadeFactor = 20;
+    this.yawDelta = 0;
+    this.pitchDelta = 0;
+    this.panDelta = new THREE.Vector2(0, 0);
+    this.radiusDelta = 0;
+
+    this.doubleClockZoomEnabled = true;
+	this.isInterior=false
+    this.tweens = [];
+
+    this.changeEvent = new CustomEvent("camerachange");
+
+    let drag = (e) => {
+      if (e.drag.object !== null) {
+        return;
+      }
+
+      if (e.drag.startHandled === undefined) {
+        e.drag.startHandled = true;
+
+        this.dispatchEvent({ type: "start" });
+      }
+
+      let ndrag = {
+        x: e.drag.lastDrag.x / this.renderer.domElement.clientWidth,
+        y: e.drag.lastDrag.y / this.renderer.domElement.clientHeight,
+      };
+
+      if (e.drag.mouse === MOUSE.LEFT) {
+        this.yawDelta += ndrag.x * this.rotationSpeed;
+        this.pitchDelta += ndrag.y * this.rotationSpeed;
+
+        this.stopTweens();
+      } else if (e.drag.mouse === MOUSE.RIGHT) {
+        this.panDelta.x += ndrag.x;
+        this.panDelta.y += ndrag.y;
+
+        this.stopTweens();
+      }
+
+      document.dispatchEvent(this.changeEvent);
+    };
+
+    let drop = (e) => {
+      this.dispatchEvent({ type: "end" });
+      document.dispatchEvent(this.changeEvent);
+    };
+
+    let scroll = (e) => {
+      let resolvedRadius = this.scene.view.radius + this.radiusDelta;
+
+      this.radiusDelta += -e.delta * resolvedRadius * 0.1;
+
+      this.stopTweens();
+      document.dispatchEvent(this.changeEvent);
+    };
+
+    let dblclick = (e) => {
+      if (this.doubleClockZoomEnabled) {
+        this.zoomToLocation(e.mouse);
+      }
+    };
+
+    let previousTouch = null;
+    let touchStart = (e) => {
+      previousTouch = e;
+    };
+
+    let touchEnd = (e) => {
+      previousTouch = e;
+    };
+
+    let touchMove = (e) => {
+      if (e.touches.length === 2 && previousTouch.touches.length === 2) {
+        let prev = previousTouch;
+        let curr = e;
+
+        let prevDX = prev.touches[0].pageX - prev.touches[1].pageX;
+        let prevDY = prev.touches[0].pageY - prev.touches[1].pageY;
+        let prevDist = Math.sqrt(prevDX * prevDX + prevDY * prevDY);
+
+        let currDX = curr.touches[0].pageX - curr.touches[1].pageX;
+        let currDY = curr.touches[0].pageY - curr.touches[1].pageY;
+        let currDist = Math.sqrt(currDX * currDX + currDY * currDY);
+
+        let delta = currDist / prevDist;
+        let resolvedRadius = this.scene.view.radius + this.radiusDelta;
+        let newRadius = resolvedRadius / delta;
+        this.radiusDelta = newRadius - resolvedRadius;
+
+        this.stopTweens();
+      } else if (e.touches.length === 3 && previousTouch.touches.length === 3) {
+        let prev = previousTouch;
+        let curr = e;
+
+        let prevMeanX =
+          (prev.touches[0].pageX +
+            prev.touches[1].pageX +
+            prev.touches[2].pageX) /
+          3;
+        let prevMeanY =
+          (prev.touches[0].pageY +
+            prev.touches[1].pageY +
+            prev.touches[2].pageY) /
+          3;
+
+        let currMeanX =
+          (curr.touches[0].pageX +
+            curr.touches[1].pageX +
+            curr.touches[2].pageX) /
+          3;
+        let currMeanY =
+          (curr.touches[0].pageY +
+            curr.touches[1].pageY +
+            curr.touches[2].pageY) /
+          3;
+
+        let delta = {
+          x: (currMeanX - prevMeanX) / this.renderer.domElement.clientWidth,
+          y: (currMeanY - prevMeanY) / this.renderer.domElement.clientHeight,
+        };
+
+        this.panDelta.x += delta.x;
+        this.panDelta.y += delta.y;
+
+        this.stopTweens();
+      }
+
+      previousTouch = e;
+    };
+
+    this.addEventListener("touchstart", touchStart);
+    this.addEventListener("touchend", touchEnd);
+    this.addEventListener("touchmove", touchMove);
+    this.addEventListener("drag", drag);
+    this.addEventListener("drop", drop);
+    this.addEventListener("mousewheel", scroll);
+    this.addEventListener("dblclick", dblclick);
+  }
+
+  setScene(scene) {
+    this.scene = scene;
+  }
+
+  stop() {
+    this.yawDelta = 0;
+    this.pitchDelta = 0;
+    this.radiusDelta = 0;
+    this.panDelta.set(0, 0);
+  }
+
+  zoomToLocation(mouse) {
+    let camera = this.scene.getActiveCamera();
+
+    let I = Utils.getMousePointCloudIntersection(
+      mouse,
+      camera,
+      this.viewer,
+      this.scene.pointclouds,
+      { pickClipped: true }
+    );
+
+    if (I === null) {
+      return;
+    }
+
+    let targetRadius = 0;
+    {
+      let minimumJumpDistance = 0.2;
+
+      let domElement = this.renderer.domElement;
+      let ray = Utils.mouseToRay(
+        mouse,
+        camera,
+        domElement.clientWidth,
+        domElement.clientHeight
+      );
+
+      let nodes = I.pointcloud.nodesOnRay(I.pointcloud.visibleNodes, ray);
+      let lastNode = nodes[nodes.length - 1];
+      let radius = lastNode.getBoundingSphere(new THREE.Sphere()).radius;
+      targetRadius = Math.min(this.scene.view.radius, radius);
+      targetRadius = Math.max(minimumJumpDistance, targetRadius);
+    }
+
+    let d = this.scene.view.direction.multiplyScalar(-1);
+    let cameraTargetPosition = new THREE.Vector3().addVectors(
+      I.location,
+      d.multiplyScalar(targetRadius)
+    );
+    // TODO Unused: let controlsTargetPosition = I.location;
+
+    let animationDuration = 600;
+    let easing = TWEEN.Easing.Quartic.Out;
+
+    {
+      // animate
+      let value = { x: 0 };
+      let tween = new TWEEN.Tween(value).to({ x: 1 }, animationDuration);
+      tween.easing(easing);
+      this.tweens.push(tween);
+
+      let startPos = this.scene.view.position.clone();
+      let targetPos = cameraTargetPosition.clone();
+      let startRadius = this.scene.view.radius;
+      let targetRadius = cameraTargetPosition.distanceTo(I.location);
+
+      tween.onUpdate(() => {
+        let t = value.x;
+        this.scene.view.position.x = (1 - t) * startPos.x + t * targetPos.x;
+        this.scene.view.position.y = (1 - t) * startPos.y + t * targetPos.y;
+        this.scene.view.position.z = (1 - t) * startPos.z + t * targetPos.z;
+
+        this.scene.view.radius = (1 - t) * startRadius + t * targetRadius;
+        this.viewer.setMoveSpeed(this.scene.view.radius);
+        document.dispatchEvent(this.changeEvent);
+      });
+
+      tween.onComplete(() => {
+        this.tweens = this.tweens.filter((e) => e !== tween);
+        document.dispatchEvent(this.changeEvent);
+      });
+
+      tween.start();
+    }
+  }
+
+  stopTweens() {
+    this.tweens.forEach((e) => e.stop());
+    this.tweens = [];
+  }
+
+  update(delta) {
+    let view = this.scene.view;
+
+    {
+      // apply rotation
+      let progression = Math.min(1, this.fadeFactor * delta);
+
+      let yaw = view.yaw;
+      let pitch = view.pitch;
+      let pivot = view.getPivot();
+
+      yaw -= progression * this.yawDelta;
+      pitch -= progression * this.pitchDelta;
+	if (this.isInterior) {
+      if (pitch < -1 * 0.3) {
+        pitch = -1 * 0.3;
+      } else if (pitch > 1.3) {
+        pitch = 1.3;
+      }
+    }	
+      view.yaw = yaw;
+      view.pitch = pitch;
+
+      let V = this.scene.view.direction.multiplyScalar(-view.radius);
+      let position = new THREE.Vector3().addVectors(pivot, V);
+
+      view.position.copy(position);
+    }
+
+    {
+      // apply pan
+      let progression = Math.min(1, this.fadeFactor * delta);
+      let panDistance = progression * view.radius * 3;
+
+      let px = -this.panDelta.x * panDistance;
+      let py = this.panDelta.y * panDistance;
+
+      view.pan(px, py);
+    }
+
+    {
+      // apply zoom
+      let progression = Math.min(1, this.fadeFactor * delta);
+
+      // let radius = view.radius + progression * this.radiusDelta * view.radius * 0.1;
+      let radius = view.radius + progression * this.radiusDelta;
+
+      let V = view.direction.multiplyScalar(-radius);
+      let position = new THREE.Vector3().addVectors(view.getPivot(), V);
+      view.radius = radius;
+
+      view.position.copy(position);
+    }
+
+    {
+      let speed = view.radius;
+      this.viewer.setMoveSpeed(speed);
+    }
+
+    {
+      // decelerate over time
+      let progression = Math.min(1, this.fadeFactor * delta);
+      let attenuation = Math.max(0, 1 - this.fadeFactor * delta);
+
+      this.yawDelta *= attenuation;
+      this.pitchDelta *= attenuation;
+      this.panDelta.multiplyScalar(attenuation);
+      // this.radiusDelta *= attenuation;
+      this.radiusDelta -= progression * this.radiusDelta;
+    }
+  }
+}
diff --git a/src/viewer/Scene.js b/src/viewer/Scene.js
index d0008ac8..f656bf6a 100644
--- a/src/viewer/Scene.js
+++ b/src/viewer/Scene.js
@@ -1,437 +1,450 @@
-
 import * as THREE from "../../libs/three.js/build/three.module.js";
-import {Annotation} from "../Annotation.js";
-import {CameraMode} from "../defines.js";
-import {View} from "./View.js";
-import {Utils} from "../utils.js";
-import {EventDispatcher} from "../EventDispatcher.js";
-
-
-export class Scene extends EventDispatcher{
-
-	constructor(){
-		super();
-
-		this.annotations = new Annotation();
-		
-		this.scene = new THREE.Scene();
-		this.sceneBG = new THREE.Scene();
-		this.scenePointCloud = new THREE.Scene();
-
-		this.cameraP = new THREE.PerspectiveCamera(this.fov, 1, 0.1, 1000*1000);
-		this.cameraO = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 1000*1000);
-		this.cameraVR = new THREE.PerspectiveCamera();
-		this.cameraBG = new THREE.Camera();
-		this.cameraScreenSpace = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
-		this.cameraMode = CameraMode.PERSPECTIVE;
-		this.overrideCamera = null;
-		this.pointclouds = [];
-
-		this.measurements = [];
-		this.profiles = [];
-		this.volumes = [];
-		this.polygonClipVolumes = [];
-		this.cameraAnimations = [];
-		this.orientedImages = [];
-		this.images360 = [];
-		this.geopackages = [];
-		
-		this.fpControls = null;
-		this.orbitControls = null;
-		this.earthControls = null;
-		this.geoControls = null;
-		this.deviceControls = null;
-		this.inputHandler = null;
-
-		this.view = new View();
-
-		this.directionalLight = null;
-
-		this.initialize();
-	}
-
-	estimateHeightAt (position) {
-		let height = null;
-		let fromSpacing = Infinity;
-
-		for (let pointcloud of this.pointclouds) {
-			if (pointcloud.root.geometryNode === undefined) {
-				continue;
-			}
-
-			let pHeight = null;
-			let pFromSpacing = Infinity;
-
-			let lpos = position.clone().sub(pointcloud.position);
-			lpos.z = 0;
-			let ray = new THREE.Ray(lpos, new THREE.Vector3(0, 0, 1));
-
-			let stack = [pointcloud.root];
-			while (stack.length > 0) {
-				let node = stack.pop();
-				let box = node.getBoundingBox();
-
-				let inside = ray.intersectBox(box);
-
-				if (!inside) {
-					continue;
-				}
-
-				let h = node.geometryNode.mean.z +
-					pointcloud.position.z +
-					node.geometryNode.boundingBox.min.z;
-
-				if (node.geometryNode.spacing <= pFromSpacing) {
-					pHeight = h;
-					pFromSpacing = node.geometryNode.spacing;
-				}
-
-				for (let index of Object.keys(node.children)) {
-					let child = node.children[index];
-					if (child.geometryNode) {
-						stack.push(node.children[index]);
-					}
-				}
-			}
-
-			if (height === null || pFromSpacing < fromSpacing) {
-				height = pHeight;
-				fromSpacing = pFromSpacing;
-			}
-		}
-
-		return height;
-	}
-	
-	getBoundingBox(pointclouds = this.pointclouds){
-		let box = new THREE.Box3();
-
-		this.scenePointCloud.updateMatrixWorld(true);
-		this.referenceFrame.updateMatrixWorld(true);
-
-		for (let pointcloud of pointclouds) {
-			pointcloud.updateMatrixWorld(true);
-
-			let pointcloudBox = pointcloud.pcoGeometry.tightBoundingBox ? pointcloud.pcoGeometry.tightBoundingBox : pointcloud.boundingBox;
-			let boxWorld = Utils.computeTransformedBoundingBox(pointcloudBox, pointcloud.matrixWorld);
-			box.union(boxWorld);
-		}
-
-		return box;
-	}
-
-	addPointCloud (pointcloud) {
-		this.pointclouds.push(pointcloud);
-		this.scenePointCloud.add(pointcloud);
-
-		this.dispatchEvent({
-			type: 'pointcloud_added',
-			pointcloud: pointcloud
-		});
-	}
-
-	addVolume (volume) {
-		this.volumes.push(volume);
-		this.dispatchEvent({
-			'type': 'volume_added',
-			'scene': this,
-			'volume': volume
-		});
-	}
-
-	addOrientedImages(images){
-		this.orientedImages.push(images);
-		this.scene.add(images.node);
-
-		this.dispatchEvent({
-			'type': 'oriented_images_added',
-			'scene': this,
-			'images': images
-		});
-	};
-
-	removeOrientedImages(images){
-		let index = this.orientedImages.indexOf(images);
-		if (index > -1) {
-			this.orientedImages.splice(index, 1);
-
-			this.dispatchEvent({
-				'type': 'oriented_images_removed',
-				'scene': this,
-				'images': images
-			});
-		}
-	};
-
-	add360Images(images){
-		this.images360.push(images);
-		this.scene.add(images.node);
-
-		this.dispatchEvent({
-			'type': '360_images_added',
-			'scene': this,
-			'images': images
-		});
-	}
-
-	remove360Images(images){
-		let index = this.images360.indexOf(images);
-		if (index > -1) {
-			this.images360.splice(index, 1);
-
-			this.dispatchEvent({
-				'type': '360_images_removed',
-				'scene': this,
-				'images': images
-			});
-		}
-	}
-
-	addGeopackage(geopackage){
-		this.geopackages.push(geopackage);
-		this.scene.add(geopackage.node);
-
-		this.dispatchEvent({
-			'type': 'geopackage_added',
-			'scene': this,
-			'geopackage': geopackage
-		});
-	};
-
-	removeGeopackage(geopackage){
-		let index = this.geopackages.indexOf(geopackage);
-		if (index > -1) {
-			this.geopackages.splice(index, 1);
-
-			this.dispatchEvent({
-				'type': 'geopackage_removed',
-				'scene': this,
-				'geopackage': geopackage
-			});
-		}
-	};
-
-	removeVolume (volume) {
-		let index = this.volumes.indexOf(volume);
-		if (index > -1) {
-			this.volumes.splice(index, 1);
-
-			this.dispatchEvent({
-				'type': 'volume_removed',
-				'scene': this,
-				'volume': volume
-			});
-		}
-	};
-
-	addCameraAnimation(animation) {
-		this.cameraAnimations.push(animation);
-		this.dispatchEvent({
-			'type': 'camera_animation_added',
-			'scene': this,
-			'animation': animation
-		});
-	};
-
-	removeCameraAnimation(animation){
-		let index = this.cameraAnimations.indexOf(volume);
-		if (index > -1) {
-			this.cameraAnimations.splice(index, 1);
-
-			this.dispatchEvent({
-				'type': 'camera_animation_removed',
-				'scene': this,
-				'animation': animation
-			});
-		}
-	};
-
-	addPolygonClipVolume(volume){
-		this.polygonClipVolumes.push(volume);
-		this.dispatchEvent({
-			"type": "polygon_clip_volume_added",
-			"scene": this,
-			"volume": volume
-		});
-	};
-	
-	removePolygonClipVolume(volume){
-		let index = this.polygonClipVolumes.indexOf(volume);
-		if (index > -1) {
-			this.polygonClipVolumes.splice(index, 1);
-			this.dispatchEvent({
-				"type": "polygon_clip_volume_removed",
-				"scene": this,
-				"volume": volume
-			});
-		}
-	};
-	
-	addMeasurement(measurement){
-		measurement.lengthUnit = this.lengthUnit;
-		measurement.lengthUnitDisplay = this.lengthUnitDisplay;
-		this.measurements.push(measurement);
-		this.dispatchEvent({
-			'type': 'measurement_added',
-			'scene': this,
-			'measurement': measurement
-		});
-	};
-
-	removeMeasurement (measurement) {
-		let index = this.measurements.indexOf(measurement);
-		if (index > -1) {
-			this.measurements.splice(index, 1);
-			this.dispatchEvent({
-				'type': 'measurement_removed',
-				'scene': this,
-				'measurement': measurement
-			});
-		}
-	}
-
-	addProfile (profile) {
-		this.profiles.push(profile);
-		this.dispatchEvent({
-			'type': 'profile_added',
-			'scene': this,
-			'profile': profile
-		});
-	}
-
-	removeProfile (profile) {
-		let index = this.profiles.indexOf(profile);
-		if (index > -1) {
-			this.profiles.splice(index, 1);
-			this.dispatchEvent({
-				'type': 'profile_removed',
-				'scene': this,
-				'profile': profile
-			});
-		}
-	}
-
-	removeAllMeasurements () {
-		while (this.measurements.length > 0) {
-			this.removeMeasurement(this.measurements[0]);
-		}
-
-		while (this.profiles.length > 0) {
-			this.removeProfile(this.profiles[0]);
-		}
-
-		while (this.volumes.length > 0) {
-			this.removeVolume(this.volumes[0]);
-		}
-	}
-
-	removeAllClipVolumes(){
-		let clipVolumes = this.volumes.filter(volume => volume.clip === true);
-		for(let clipVolume of clipVolumes){
-			this.removeVolume(clipVolume);
-		}
-
-		while(this.polygonClipVolumes.length > 0){
-			this.removePolygonClipVolume(this.polygonClipVolumes[0]);
-		}
-	}
-
-	getActiveCamera() {
-
-		if(this.overrideCamera){
-			return this.overrideCamera;
-		}
-
-		if(this.cameraMode === CameraMode.PERSPECTIVE){
-			return this.cameraP;
-		}else if(this.cameraMode === CameraMode.ORTHOGRAPHIC){
-			return this.cameraO;
-		}else if(this.cameraMode === CameraMode.VR){
-			return this.cameraVR;
-		}
-
-		return null;
-	}
-	
-	initialize(){
-		
-		this.referenceFrame = new THREE.Object3D();
-		this.referenceFrame.matrixAutoUpdate = false;
-		this.scenePointCloud.add(this.referenceFrame);
-
-		this.cameraP.up.set(0, 0, 1);
-		this.cameraP.position.set(1000, 1000, 1000);
-		this.cameraO.up.set(0, 0, 1);
-		this.cameraO.position.set(1000, 1000, 1000);
-		//this.camera.rotation.y = -Math.PI / 4;
-		//this.camera.rotation.x = -Math.PI / 6;
-		this.cameraScreenSpace.lookAt(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, 1, 0));
-		
-		this.directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
-		this.directionalLight.position.set( 10, 10, 10 );
-		this.directionalLight.lookAt( new THREE.Vector3(0, 0, 0));
-		this.scenePointCloud.add( this.directionalLight );
-		
-		let light = new THREE.AmbientLight( 0x555555 ); // soft white light
-		this.scenePointCloud.add( light );
-
-		{ // background
-			let texture = Utils.createBackgroundTexture(512, 512);
-
-			texture.minFilter = texture.magFilter = THREE.NearestFilter;
-			texture.minFilter = texture.magFilter = THREE.LinearFilter;
-			let bg = new THREE.Mesh(
-				new THREE.PlaneBufferGeometry(2, 2, 1),
-				new THREE.MeshBasicMaterial({
-					map: texture
-				})
-			);
-			bg.material.depthTest = false;
-			bg.material.depthWrite = false;
-			this.sceneBG.add(bg);
-		}
-
-		// { // lights
-		// 	{
-		// 		let light = new THREE.DirectionalLight(0xffffff);
-		// 		light.position.set(10, 10, 1);
-		// 		light.target.position.set(0, 0, 0);
-		// 		this.scene.add(light);
-		// 	}
-
-		// 	{
-		// 		let light = new THREE.DirectionalLight(0xffffff);
-		// 		light.position.set(-10, 10, 1);
-		// 		light.target.position.set(0, 0, 0);
-		// 		this.scene.add(light);
-		// 	}
-
-		// 	{
-		// 		let light = new THREE.DirectionalLight(0xffffff);
-		// 		light.position.set(0, -10, 20);
-		// 		light.target.position.set(0, 0, 0);
-		// 		this.scene.add(light);
-		// 	}
-		// }
-	}
-	
-	addAnnotation(position, args = {}){		
-		if(position instanceof Array){
-			args.position = new THREE.Vector3().fromArray(position);
-		} else if (position.x != null) {
-			args.position = position;
-		}
-		let annotation = new Annotation(args);
-		this.annotations.add(annotation);
-
-		return annotation;
-	}
-
-	getAnnotations () {
-		return this.annotations;
-	};
-
-	removeAnnotation(annotationToRemove) {
-		this.annotations.remove(annotationToRemove);
-	}
-};
+import { Annotation } from "../Annotation.js";
+import { CameraMode } from "../defines.js";
+import { View } from "./View.js";
+import { Utils } from "../utils.js";
+import { EventDispatcher } from "../EventDispatcher.js";
+
+export class Scene extends EventDispatcher {
+  constructor() {
+    super();
+
+    this.annotations = new Annotation();
+
+    this.scene = new THREE.Scene();
+    this.sceneBG = new THREE.Scene();
+    this.scenePointCloud = new THREE.Scene();
+
+    this.cameraP = new THREE.PerspectiveCamera(this.fov, 1, 0.1, 1000 * 1000);
+    this.cameraO = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 1000 * 1000);
+    this.cameraVR = new THREE.PerspectiveCamera();
+    this.cameraBG = new THREE.Camera();
+    this.cameraScreenSpace = new THREE.OrthographicCamera(
+      -1,
+      1,
+      1,
+      -1,
+      0.1,
+      10
+    );
+    this.cameraMode = CameraMode.PERSPECTIVE;
+    this.overrideCamera = null;
+    this.pointclouds = [];
+
+    this.measurements = [];
+    this.profiles = [];
+    this.volumes = [];
+    this.polygonClipVolumes = [];
+    this.cameraAnimations = [];
+    this.orientedImages = [];
+    this.images360 = [];
+    this.geopackages = [];
+
+    this.fpControls = null;
+    this.orbitControls = null;
+    this.earthControls = null;
+    this.geoControls = null;
+    this.deviceControls = null;
+    this.inputHandler = null;
+
+    this.view = new View();
+
+    this.directionalLight = null;
+
+    this.initialize();
+  }
+
+  estimateHeightAt(position) {
+    let height = null;
+    let fromSpacing = Infinity;
+
+    for (let pointcloud of this.pointclouds) {
+      if (pointcloud.root.geometryNode === undefined) {
+        continue;
+      }
+
+      let pHeight = null;
+      let pFromSpacing = Infinity;
+
+      let lpos = position.clone().sub(pointcloud.position);
+      lpos.z = 0;
+      let ray = new THREE.Ray(lpos, new THREE.Vector3(0, 0, 1));
+
+      let stack = [pointcloud.root];
+      while (stack.length > 0) {
+        let node = stack.pop();
+        let box = node.getBoundingBox();
+
+        let inside = ray.intersectBox(box);
+
+        if (!inside) {
+          continue;
+        }
+
+        let h =
+          node.geometryNode.mean.z +
+          pointcloud.position.z +
+          node.geometryNode.boundingBox.min.z;
+
+        if (node.geometryNode.spacing <= pFromSpacing) {
+          pHeight = h;
+          pFromSpacing = node.geometryNode.spacing;
+        }
+
+        for (let index of Object.keys(node.children)) {
+          let child = node.children[index];
+          if (child.geometryNode) {
+            stack.push(node.children[index]);
+          }
+        }
+      }
+
+      if (height === null || pFromSpacing < fromSpacing) {
+        height = pHeight;
+        fromSpacing = pFromSpacing;
+      }
+    }
+
+    return height;
+  }
+
+  getBoundingBox(pointclouds = this.pointclouds) {
+    let box = new THREE.Box3();
+
+    this.scenePointCloud.updateMatrixWorld(true);
+    this.referenceFrame.updateMatrixWorld(true);
+
+    for (let pointcloud of pointclouds) {
+      pointcloud.updateMatrixWorld(true);
+
+      let pointcloudBox = pointcloud.pcoGeometry.tightBoundingBox
+        ? pointcloud.pcoGeometry.tightBoundingBox
+        : pointcloud.boundingBox;
+      let boxWorld = Utils.computeTransformedBoundingBox(
+        pointcloudBox,
+        pointcloud.matrixWorld
+      );
+      box.union(boxWorld);
+    }
+
+    return box;
+  }
+
+  addPointCloud(pointcloud) {
+    this.pointclouds.push(pointcloud);
+    this.scenePointCloud.add(pointcloud);
+
+    this.dispatchEvent({
+      type: "pointcloud_added",
+      pointcloud: pointcloud,
+    });
+  }
+
+  addVolume(volume) {
+    this.volumes.push(volume);
+    this.dispatchEvent({
+      type: "volume_added",
+      scene: this,
+      volume: volume,
+    });
+  }
+
+  addOrientedImages(images) {
+    this.orientedImages.push(images);
+    this.scene.add(images.node);
+
+    this.dispatchEvent({
+      type: "oriented_images_added",
+      scene: this,
+      images: images,
+    });
+  }
+
+  removeOrientedImages(images) {
+    let index = this.orientedImages.indexOf(images);
+    if (index > -1) {
+      this.orientedImages.splice(index, 1);
+
+      this.dispatchEvent({
+        type: "oriented_images_removed",
+        scene: this,
+        images: images,
+      });
+    }
+  }
+
+  add360Images(images) {
+    this.images360.push(images);
+    this.scene.add(images.node);
+
+    this.dispatchEvent({
+      type: "360_images_added",
+      scene: this,
+      images: images,
+    });
+  }
+
+  remove360Images(images) {
+    let index = this.images360.indexOf(images);
+    if (index > -1) {
+      this.images360.splice(index, 1);
+
+      this.dispatchEvent({
+        type: "360_images_removed",
+        scene: this,
+        images: images,
+      });
+    }
+  }
+
+  addGeopackage(geopackage) {
+    this.geopackages.push(geopackage);
+    this.scene.add(geopackage.node);
+
+    this.dispatchEvent({
+      type: "geopackage_added",
+      scene: this,
+      geopackage: geopackage,
+    });
+  }
+
+  removeGeopackage(geopackage) {
+    let index = this.geopackages.indexOf(geopackage);
+    if (index > -1) {
+      this.geopackages.splice(index, 1);
+
+      this.dispatchEvent({
+        type: "geopackage_removed",
+        scene: this,
+        geopackage: geopackage,
+      });
+    }
+  }
+
+  removeVolume(volume) {
+    let index = this.volumes.indexOf(volume);
+    if (index > -1) {
+      this.volumes.splice(index, 1);
+
+      this.dispatchEvent({
+        type: "volume_removed",
+        scene: this,
+        volume: volume,
+      });
+    }
+  }
+
+  addCameraAnimation(animation) {
+    this.cameraAnimations.push(animation);
+    this.dispatchEvent({
+      type: "camera_animation_added",
+      scene: this,
+      animation: animation,
+    });
+  }
+
+  removeCameraAnimation(animation) {
+    let index = this.cameraAnimations.indexOf(volume);
+    if (index > -1) {
+      this.cameraAnimations.splice(index, 1);
+
+      this.dispatchEvent({
+        type: "camera_animation_removed",
+        scene: this,
+        animation: animation,
+      });
+    }
+  }
+
+  addPolygonClipVolume(volume) {
+    this.polygonClipVolumes.push(volume);
+    this.dispatchEvent({
+      type: "polygon_clip_volume_added",
+      scene: this,
+      volume: volume,
+    });
+  }
+
+  removePolygonClipVolume(volume) {
+    let index = this.polygonClipVolumes.indexOf(volume);
+    if (index > -1) {
+      this.polygonClipVolumes.splice(index, 1);
+      this.dispatchEvent({
+        type: "polygon_clip_volume_removed",
+        scene: this,
+        volume: volume,
+      });
+    }
+  }
+
+  addMeasurement(measurement) {
+    measurement.lengthUnit = this.lengthUnit;
+    measurement.lengthUnitDisplay = this.lengthUnitDisplay;
+    this.measurements.push(measurement);
+    this.dispatchEvent({
+      type: "measurement_added",
+      scene: this,
+      measurement: measurement,
+    });
+  }
+
+  removeMeasurement(measurement) {
+    let index = this.measurements.indexOf(measurement);
+    if (index > -1) {
+      this.measurements.splice(index, 1);
+      this.dispatchEvent({
+        type: "measurement_removed",
+        scene: this,
+        measurement: measurement,
+      });
+    }
+  }
+
+  addProfile(profile) {
+    this.profiles.push(profile);
+    this.dispatchEvent({
+      type: "profile_added",
+      scene: this,
+      profile: profile,
+    });
+  }
+
+  removeProfile(profile) {
+    let index = this.profiles.indexOf(profile);
+    if (index > -1) {
+      this.profiles.splice(index, 1);
+      this.dispatchEvent({
+        type: "profile_removed",
+        scene: this,
+        profile: profile,
+      });
+    }
+  }
+
+  removeAllMeasurements() {
+    while (this.measurements.length > 0) {
+      this.removeMeasurement(this.measurements[0]);
+    }
+
+    while (this.profiles.length > 0) {
+      this.removeProfile(this.profiles[0]);
+    }
+
+    while (this.volumes.length > 0) {
+      this.removeVolume(this.volumes[0]);
+    }
+  }
+
+  removeAllClipVolumes() {
+    let clipVolumes = this.volumes.filter((volume) => volume.clip === true);
+    for (let clipVolume of clipVolumes) {
+      this.removeVolume(clipVolume);
+    }
+
+    while (this.polygonClipVolumes.length > 0) {
+      this.removePolygonClipVolume(this.polygonClipVolumes[0]);
+    }
+  }
+
+  getActiveCamera() {
+    if (this.overrideCamera) {
+      return this.overrideCamera;
+    }
+
+    if (this.cameraMode === CameraMode.PERSPECTIVE) {
+      return this.cameraP;
+    } else if (this.cameraMode === CameraMode.ORTHOGRAPHIC) {
+      return this.cameraO;
+    } else if (this.cameraMode === CameraMode.VR) {
+      return this.cameraVR;
+    }
+
+    return null;
+  }
+
+  initialize() {
+    this.referenceFrame = new THREE.Object3D();
+    this.referenceFrame.matrixAutoUpdate = false;
+    this.scenePointCloud.add(this.referenceFrame);
+
+    this.cameraP.up.set(0, 0, 1);
+    this.cameraP.position.set(1000, 1000, 1000);
+    this.cameraO.up.set(0, 0, 1);
+    this.cameraO.position.set(1000, 1000, 1000);
+    //this.camera.rotation.y = -Math.PI / 4;
+    //this.camera.rotation.x = -Math.PI / 6;
+    this.cameraScreenSpace.lookAt(
+      new THREE.Vector3(0, 0, 0),
+      new THREE.Vector3(0, 0, -1),
+      new THREE.Vector3(0, 1, 0)
+    );
+
+    this.directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
+    this.directionalLight.position.set(10, 10, 10);
+    this.directionalLight.lookAt(new THREE.Vector3(0, 0, 0));
+    this.scenePointCloud.add(this.directionalLight);
+
+    let light = new THREE.AmbientLight(0x555555); // soft white light
+    this.scenePointCloud.add(light);
+
+    {
+      // background
+      let texture = Utils.createBackgroundTexture(512, 512);
+
+      texture.minFilter = texture.magFilter = THREE.NearestFilter;
+      texture.minFilter = texture.magFilter = THREE.LinearFilter;
+      let bg = new THREE.Mesh(
+        new THREE.PlaneBufferGeometry(2, 2, 1),
+        new THREE.MeshBasicMaterial({
+          map: texture,
+        })
+      );
+      bg.material.depthTest = false;
+      bg.material.depthWrite = false;
+      this.sceneBG.add(bg);
+    }
+
+    // { // lights
+    // 	{
+    // 		let light = new THREE.DirectionalLight(0xffffff);
+    // 		light.position.set(10, 10, 1);
+    // 		light.target.position.set(0, 0, 0);
+    // 		this.scene.add(light);
+    // 	}
+
+    // 	{
+    // 		let light = new THREE.DirectionalLight(0xffffff);
+    // 		light.position.set(-10, 10, 1);
+    // 		light.target.position.set(0, 0, 0);
+    // 		this.scene.add(light);
+    // 	}
+
+    // 	{
+    // 		let light = new THREE.DirectionalLight(0xffffff);
+    // 		light.position.set(0, -10, 20);
+    // 		light.target.position.set(0, 0, 0);
+    // 		this.scene.add(light);
+    // 	}
+    // }
+  }
+
+  addAnnotation(position, args = {}) {
+    if (position instanceof Array) {
+      args.position = new THREE.Vector3().fromArray(position);
+    } else if (position.x != null) {
+      args.position = position;
+    }
+    let annotation = new Annotation(args);
+    this.annotations.add(annotation);
+
+    return annotation;
+  }
+
+  getAnnotations() {
+    return this.annotations;
+  }
+
+  removeAnnotation(annotationToRemove) {
+    this.annotations.remove(annotationToRemove);
+  }
+}
diff --git a/src/viewer/map.js b/src/viewer/map.js
index 0979c607..314ac1e5 100644
--- a/src/viewer/map.js
+++ b/src/viewer/map.js
@@ -305,7 +305,7 @@ export class MapView{
 		};
 
 		this.on360ImagesAdded = e => {
-			this.addImages360(e.images);
+			// this.addImages360(e.images);
 		};
 
 		this.onAnnotationAdded = e => {
diff --git a/src/viewer/viewer.js b/src/viewer/viewer.js
index baf1fb1b..bb07592d 100644
--- a/src/viewer/viewer.js
+++ b/src/viewer/viewer.js
@@ -788,6 +788,7 @@ export class Viewer extends EventDispatcher{
 	};
 
 	zoomTo(node, factor, animationDuration = 0){
+		let changeEvent = new CustomEvent("camerachange");
 		let view = this.scene.view;
 
 		let camera = this.scene.cameraP.clone();
@@ -825,6 +826,7 @@ export class Viewer extends EventDispatcher{
 
 			tween.onUpdate(() => {
 				view.position.copy(pos);
+				document.dispatchEvent(changeEvent);
 			});
 
 			tween.start();
@@ -836,10 +838,12 @@ export class Viewer extends EventDispatcher{
 			tween.easing(easing);
 			tween.onUpdate(() => {
 				view.lookAt(target);
+				document.dispatchEvent(changeEvent);
 			});
 			tween.onComplete(() => {
 				view.lookAt(target);
 				this.dispatchEvent({type: 'focusing_finished', target: this});
+				document.dispatchEvent(changeEvent);
 			});
 
 			this.dispatchEvent({type: 'focusing_started', target: this});
@@ -1205,118 +1209,118 @@ export class Viewer extends EventDispatcher{
 		}
 
 		let viewer = this;
-		let sidebarContainer = $('#potree_sidebar_container');
-		sidebarContainer.load(new URL(Potree.scriptPath + '/sidebar.html').href, () => {
-			sidebarContainer.css('width', '300px');
-			sidebarContainer.css('height', '100%');
-
-			let imgMenuToggle = document.createElement('img');
-			imgMenuToggle.src = new URL(Potree.resourcePath + '/icons/menu_button.svg').href;
-			imgMenuToggle.onclick = this.toggleSidebar;
-			imgMenuToggle.classList.add('potree_menu_toggle');
-
-			let imgMapToggle = document.createElement('img');
-			imgMapToggle.src = new URL(Potree.resourcePath + '/icons/map_icon.png').href;
-			imgMapToggle.style.display = 'none';
-			imgMapToggle.onclick = e => { this.toggleMap(); };
-			imgMapToggle.id = 'potree_map_toggle';
+		// let sidebarContainer = $('#potree_sidebar_container');
+		// sidebarContainer.load(new URL(Potree.scriptPath + '/sidebar.html').href, () => {
+		// 	sidebarContainer.css('width', '300px');
+		// 	sidebarContainer.css('height', '100%');
+
+		// 	let imgMenuToggle = document.createElement('img');
+		// 	imgMenuToggle.src = new URL(Potree.resourcePath + '/icons/menu_button.svg').href;
+		// 	imgMenuToggle.onclick = this.toggleSidebar;
+		// 	imgMenuToggle.classList.add('potree_menu_toggle');
+
+		// 	let imgMapToggle = document.createElement('img');
+		// 	imgMapToggle.src = new URL(Potree.resourcePath + '/icons/map_icon.png').href;
+		// 	imgMapToggle.style.display = 'none';
+		// 	imgMapToggle.onclick = e => { this.toggleMap(); };
+		// 	imgMapToggle.id = 'potree_map_toggle';
 
 			
 
-			let elButtons = $("#potree_quick_buttons").get(0);
+		// 	let elButtons = $("#potree_quick_buttons").get(0);
 
-			elButtons.append(imgMenuToggle);
-			elButtons.append(imgMapToggle);
+		// 	elButtons.append(imgMenuToggle);
+		// 	elButtons.append(imgMapToggle);
 
 
-			VRButton.createButton(this.renderer).then(vrButton => {
+		// 	VRButton.createButton(this.renderer).then(vrButton => {
 
-				if(vrButton == null){
-					console.log("VR not supported or active.");
+		// 		if(vrButton == null){
+		// 			console.log("VR not supported or active.");
 
-					return;
-				}
+		// 			return;
+		// 		}
 
-				this.renderer.xr.enabled = true;
+		// 		this.renderer.xr.enabled = true;
 
-				let element = vrButton.element;
+		// 		let element = vrButton.element;
 
-				element.style.position = "";
-				element.style.bottom = "";
-				element.style.left = "";
-				element.style.margin = "4px";
-				element.style.fontSize = "100%";
-				element.style.width = "2.5em";
-				element.style.height = "2.5em";
-				element.style.padding = "0";
-				element.style.textShadow = "black 2px 2px 2px";
-				element.style.display = "block";
+		// 		element.style.position = "";
+		// 		element.style.bottom = "";
+		// 		element.style.left = "";
+		// 		element.style.margin = "4px";
+		// 		element.style.fontSize = "100%";
+		// 		element.style.width = "2.5em";
+		// 		element.style.height = "2.5em";
+		// 		element.style.padding = "0";
+		// 		element.style.textShadow = "black 2px 2px 2px";
+		// 		element.style.display = "block";
 
-				elButtons.append(element);
+		// 		elButtons.append(element);
 
-				vrButton.onStart(() => {
-					this.dispatchEvent({type: "vr_start"});
-				});
+		// 		vrButton.onStart(() => {
+		// 			this.dispatchEvent({type: "vr_start"});
+		// 		});
 
-				vrButton.onEnd(() => {
-					this.dispatchEvent({type: "vr_end"});
-				});
-			});
+		// 		vrButton.onEnd(() => {
+		// 			this.dispatchEvent({type: "vr_end"});
+		// 		});
+		// 	});
 
-			this.mapView = new MapView(this);
-			this.mapView.init();
-
-			i18n.init({
-				lng: 'en',
-				resGetPath: Potree.resourcePath + '/lang/__lng__/__ns__.json',
-				preload: ['en', 'fr', 'de', 'jp', 'se', 'es', 'zh', 'it','ca'],
-				getAsync: true,
-				debug: false
-			}, function (t) {
-				// Start translation once everything is loaded
-				$('body').i18n();
-			});
+		// 	this.mapView = new MapView(this);
+		// 	this.mapView.init();
 
-			$(() => {
-				//initSidebar(this);
-				let sidebar = new Sidebar(this);
-				sidebar.init();
+		// 	i18n.init({
+		// 		lng: 'en',
+		// 		resGetPath: Potree.resourcePath + '/lang/__lng__/__ns__.json',
+		// 		preload: ['en', 'fr', 'de', 'jp', 'se', 'es'],
+		// 		getAsync: true,
+		// 		debug: false
+		// 	}, function (t) {
+		// 		// Start translation once everything is loaded
+		// 		$('body').i18n();
+		// 	});
 
-				this.sidebar = sidebar;
+		// 	$(() => {
+		// 		//initSidebar(this);
+		// 		let sidebar = new Sidebar(this);
+		// 		sidebar.init();
 
-				//if (callback) {
-				//	$(callback);
-				//}
+		// 		this.sidebar = sidebar;
 
-				let elProfile = $('<div>').load(new URL(Potree.scriptPath + '/profile.html').href, () => {
-					$(document.body).append(elProfile.children());
-					this.profileWindow = new ProfileWindow(this);
-					this.profileWindowController = new ProfileWindowController(this);
+		// 		//if (callback) {
+		// 		//	$(callback);
+		// 		//}
 
-					$('#profile_window').draggable({
-						handle: $('#profile_titlebar'),
-						containment: $(document.body)
-					});
-					$('#profile_window').resizable({
-						containment: $(document.body),
-						handles: 'n, e, s, w'
-					});
+		// 		let elProfile = $('<div>').load(new URL(Potree.scriptPath + '/profile.html').href, () => {
+		// 			$(document.body).append(elProfile.children());
+		// 			this.profileWindow = new ProfileWindow(this);
+		// 			this.profileWindowController = new ProfileWindowController(this);
+
+		// 			$('#profile_window').draggable({
+		// 				handle: $('#profile_titlebar'),
+		// 				containment: $(document.body)
+		// 			});
+		// 			$('#profile_window').resizable({
+		// 				containment: $(document.body),
+		// 				handles: 'n, e, s, w'
+		// 			});
 
-					$(() => {
+		// 			$(() => {
 						this.guiLoaded = true;
 						for(let task of this.guiLoadTasks){
 							task();
 						}
 
-					});
-				});
+		// 			});
+		// 		});
 
 				
 
-			});
+		// 	});
 
 			
-		});
+		// });
 
 		return this.promiseGuiLoaded();
 	}
@@ -1349,14 +1353,14 @@ export class Viewer extends EventDispatcher{
 
 				const file = item.getAsFile();
 
-				const isJson5 = file.name.toLowerCase().endsWith(".json5");
+				const isJson = file.name.toLowerCase().endsWith(".json");
 				const isGeoPackage = file.name.toLowerCase().endsWith(".gpkg");
 
-				if(isJson5){
+				if(isJson){
 					try{
 
 						const text = await file.text();
-						const json = JSON5.parse(text);
+						const json = JSON.parse(text);
 
 						if(json.type === "Potree"){
 							Potree.loadProject(viewer, json);
-- 
2.38.1.windows.1


From 1b972b08827b911da2757bdfb2139ba2a8eed2a2 Mon Sep 17 00:00:00 2001
From: SathyaKrishna Vanama <sathyakrishna.vanama@constructn.ai>
Date: Wed, 19 Jul 2023 19:16:11 +0530
Subject: [PATCH 2/2] Image 360 condition is added

---
 src/modules/Images360/Images360.js | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/src/modules/Images360/Images360.js b/src/modules/Images360/Images360.js
index 189fe367..1bc3901d 100644
--- a/src/modules/Images360/Images360.js
+++ b/src/modules/Images360/Images360.js
@@ -151,6 +151,8 @@ export class Images360 extends EventDispatcher{
 			}
 			
 		}
+		if(index!=this.images.length-1)
+		{
 			let i = index + 1
 			let current = new THREE.Vector3(this.images[index].position[0], this.images[index].position[1], this.images[index].position[2])
 			let next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
@@ -165,7 +167,7 @@ export class Images360 extends EventDispatcher{
 			this.images[i].ringGroup.visible = true
 			this.visibleRings.push(this.images[i])	
 			}
-		
+		}
 		this.selectingEnabled = true;
 		
 		this.sphere.visible = false;
-- 
2.38.1.windows.1

