From 255ec3d4fbc8c841288d2f5cb5f447824ec165ba Mon Sep 17 00:00:00 2001
From: SathyaKrishna Vanama <sathyakrishna.vanama@constructn.ai>
Date: Wed, 14 Jun 2023 17:21:46 +0530
Subject: [PATCH 01/11] code enhancements completed

---
 commands.txt                                  |   19 +
 examples/colorextension.js                    |  109 +
 examples/colorextension_optimized.js          |   52 +
 examples/dtwin_viewer_v0.html                 | 3603 +++++++++++++++++
 examples/lion_las.html                        |  445 +-
 src/modules/Images360/Images360.js            |  643 ++-
 .../OrientedImages/OrientedImageControls.js   |   37 +-
 src/modules/OrientedImages/OrientedImages.js  |  902 ++---
 src/navigation/OrbitControls.js               |  580 +--
 src/viewer/Scene.js                           |  885 ++--
 src/viewer/map.js                             |    2 +-
 src/viewer/viewer.js                          |  172 +-
 12 files changed, 5784 insertions(+), 1665 deletions(-)
 create mode 100644 commands.txt
 create mode 100644 examples/colorextension.js
 create mode 100644 examples/colorextension_optimized.js
 create mode 100644 examples/dtwin_viewer_v0.html

diff --git a/commands.txt b/commands.txt
new file mode 100644
index 00000000..ddfbd1a3
--- /dev/null
+++ b/commands.txt
@@ -0,0 +1,19 @@
+curl -v 'https://developer.api.autodesk.com/authentication/v1/authenticate' -X 'POST' -H 'Content-Type: application/x-www-form-urlencoded' -d 'client_id=aJRMrmok5UAbsdsXjckJmSBmoNnYKLzM&client_secret=mSqemcEE53l4THBJ&grant_type=client_credentials&scope=data:read%20data:write%20viewables:read%20bucket:create%20bucket:read'
+
+eyJhbGciOiJSUzI1NiIsImtpZCI6IlU3c0dGRldUTzlBekNhSzBqZURRM2dQZXBURVdWN2VhIn0.eyJzY29wZSI6WyJkYXRhOnJlYWQiLCJkYXRhOndyaXRlIiwidmlld2FibGVzOnJlYWQiLCJidWNrZXQ6Y3JlYXRlIiwiYnVja2V0OnJlYWQiXSwiY2xpZW50X2lkIjoiYUpSTXJtb2s1VUFic2RzWGpja0ptU0Jtb05uWUtMek0iLCJhdWQiOiJodHRwczovL2F1dG9kZXNrLmNvbS9hdWQvYWp3dGV4cDYwIiwianRpIjoibk5iYVlqamRLME5OU1QzVndneHFtbEVVRFZaM1h0b2VydUtBM1FQSkxva2JQSVBMbWRaeWlQMUNIb2JnalZwUCIsImV4cCI6MTYyNTY1OTQ0NH0.CdolgqfI6YO4Bc7U7c3FGIR080fwlwDAXauXKPg4eqgjSdaYYdgK_ch-ahO-STi_Nl2p7a2TirotH3opgYp0CbyyXL6_fd8ETkk6eX0vKU0LOo7D6gk0CtigKWF7Xxta6icsWUM80lDNppYiSW1Cn1pWaAxHyQ4aSqfjlNVRdQ48V-d8MJ6VmbgCz57UyCcmUtkESrwgYzxOmvoVqwWDA72J6Uoj4gHU5pJnDjaOtzaOzIui11V1dgMZgsUkkoa1GpzarIsRKMeBGhyldTOD474pKn-L-vhM7qtfYjTbq24w9hHAHsnxWvuBdCMogwoWLh4mek4HPO72YpwTQAd8wA
+
+curl -v 'https://developer.api.autodesk.com/oss/v2/buckets' -X 'POST' -H 'Content-Type: application/json' -H 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsImtpZCI6Imp3dF9zeW1tZXRyaWNfa2V5In0.eyJjbGllbnRfaWQiOiJpWFdZbTNGVkdNaExZTHNzQVFBd2RNR01xNUhzQXdOYiIsImV4cCI6MTU4NTEyMTY0NSwic2NvcGUiOlsiZGF0YTpyZWFkIiwiZGF0YTp3cml0ZSIsInZpZXdhYmxlczpyZWFkIiwiYnVja2V0OmNyZWF0ZSIsImJ1Y2tldDpyZWFkIl0sImF1ZCI6Imh0dHBzOi8vYXV0b2Rlc2suY29tL2F1ZC9qd3RleHA2MCIsImp0aSI6Im10VklEWGtrOUJwUVBUYU84UlpEV3NWNWpCSHR3VkRObUIwVlN3dnJVeXFiNTVveFlibW5vaUNsMk02Vks4Ym4ifQ.71YkbtExiXDVkWeGODigBWGViNj9_5RSHwTjgvd_MME' -d '{"bucketKey":"threeforge","policyKey":"transient"}'
+digitaltwins
+Verify Bucket
+curl -v 'https://developer.api.autodesk.com/oss/v2/buckets/dtwin/details' -X 'GET' -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IlU3c0dGRldUTzlBekNhSzBqZURRM2dQZXBURVdWN2VhIn0.eyJzY29wZSI6WyJkYXRhOnJlYWQiLCJkYXRhOndyaXRlIiwidmlld2FibGVzOnJlYWQiLCJidWNrZXQ6Y3JlYXRlIiwiYnVja2V0OnJlYWQiXSwiY2xpZW50X2lkIjoiYUpSTXJtb2s1VUFic2RzWGpja0ptU0Jtb05uWUtMek0iLCJhdWQiOiJodHRwczovL2F1dG9kZXNrLmNvbS9hdWQvYWp3dGV4cDYwIiwianRpIjoibk5iYVlqamRLME5OU1QzVndneHFtbEVVRFZaM1h0b2VydUtBM1FQSkxva2JQSVBMbWRaeWlQMUNIb2JnalZwUCIsImV4cCI6MTYyNTY1OTQ0NH0.CdolgqfI6YO4Bc7U7c3FGIR080fwlwDAXauXKPg4eqgjSdaYYdgK_ch-ahO-STi_Nl2p7a2TirotH3opgYp0CbyyXL6_fd8ETkk6eX0vKU0LOo7D6gk0CtigKWF7Xxta6icsWUM80lDNppYiSW1Cn1pWaAxHyQ4aSqfjlNVRdQ48V-d8MJ6VmbgCz57UyCcmUtkESrwgYzxOmvoVqwWDA72J6Uoj4gHU5pJnDjaOtzaOzIui11V1dgMZgsUkkoa1GpzarIsRKMeBGhyldTOD474pKn-L-vhM7qtfYjTbq24w9hHAHsnxWvuBdCMogwoWLh4mek4HPO72YpwTQAd8wA'
+
+
+curl -v 'https://developer.api.autodesk.com/oss/v2/buckets/dtwin/objects/floor_4.ifc' -X 'PUT' -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IlU3c0dGRldUTzlBekNhSzBqZURRM2dQZXBURVdWN2VhIn0.eyJzY29wZSI6WyJkYXRhOnJlYWQiLCJkYXRhOndyaXRlIiwidmlld2FibGVzOnJlYWQiLCJidWNrZXQ6Y3JlYXRlIiwiYnVja2V0OnJlYWQiXSwiY2xpZW50X2lkIjoiYUpSTXJtb2s1VUFic2RzWGpja0ptU0Jtb05uWUtMek0iLCJhdWQiOiJodHRwczovL2F1dG9kZXNrLmNvbS9hdWQvYWp3dGV4cDYwIiwianRpIjoibk5iYVlqamRLME5OU1QzVndneHFtbEVVRFZaM1h0b2VydUtBM1FQSkxva2JQSVBMbWRaeWlQMUNIb2JnalZwUCIsImV4cCI6MTYyNTY1OTQ0NH0.CdolgqfI6YO4Bc7U7c3FGIR080fwlwDAXauXKPg4eqgjSdaYYdgK_ch-ahO-STi_Nl2p7a2TirotH3opgYp0CbyyXL6_fd8ETkk6eX0vKU0LOo7D6gk0CtigKWF7Xxta6icsWUM80lDNppYiSW1Cn1pWaAxHyQ4aSqfjlNVRdQ48V-d8MJ6VmbgCz57UyCcmUtkESrwgYzxOmvoVqwWDA72J6Uoj4gHU5pJnDjaOtzaOzIui11V1dgMZgsUkkoa1GpzarIsRKMeBGhyldTOD474pKn-L-vhM7qtfYjTbq24w9hHAHsnxWvuBdCMogwoWLh4mek4HPO72YpwTQAd8wA' -H 'Content-Type: application/octet-stream' -T 'floor_4.ifc'
+
+urn:adsk.objects:os.object:dtwin/floor_4.ifc
+
+dXJuOmFkc2sub2JqZWN0czpvcy5vYmplY3Q6ZHR3aW4vZmxvb3JfNC5pZmM=
+
+curl -X 'POST' -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IlU3c0dGRldUTzlBekNhSzBqZURRM2dQZXBURVdWN2VhIn0.eyJzY29wZSI6WyJkYXRhOnJlYWQiLCJkYXRhOndyaXRlIiwidmlld2FibGVzOnJlYWQiLCJidWNrZXQ6Y3JlYXRlIiwiYnVja2V0OnJlYWQiXSwiY2xpZW50X2lkIjoiYUpSTXJtb2s1VUFic2RzWGpja0ptU0Jtb05uWUtMek0iLCJhdWQiOiJodHRwczovL2F1dG9kZXNrLmNvbS9hdWQvYWp3dGV4cDYwIiwianRpIjoibk5iYVlqamRLME5OU1QzVndneHFtbEVVRFZaM1h0b2VydUtBM1FQSkxva2JQSVBMbWRaeWlQMUNIb2JnalZwUCIsImV4cCI6MTYyNTY1OTQ0NH0.CdolgqfI6YO4Bc7U7c3FGIR080fwlwDAXauXKPg4eqgjSdaYYdgK_ch-ahO-STi_Nl2p7a2TirotH3opgYp0CbyyXL6_fd8ETkk6eX0vKU0LOo7D6gk0CtigKWF7Xxta6icsWUM80lDNppYiSW1Cn1pWaAxHyQ4aSqfjlNVRdQ48V-d8MJ6VmbgCz57UyCcmUtkESrwgYzxOmvoVqwWDA72J6Uoj4gHU5pJnDjaOtzaOzIui11V1dgMZgsUkkoa1GpzarIsRKMeBGhyldTOD474pKn-L-vhM7qtfYjTbq24w9hHAHsnxWvuBdCMogwoWLh4mek4HPO72YpwTQAd8wA' -H 'Content-Type: application/json' -v 'https://developer.api.autodesk.com/modelderivative/v2/designdata/job' -d '{"input": {"urn": "dXJuOmFkc2sub2JqZWN0czpvcy5vYmplY3Q6ZHR3aW4vZmxvb3JfNC5pZmM="},"output":{"formats":[{"type":"svf","views":["2d","3d"]}]}}'
+
+curl -X 'GET' -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IlU3c0dGRldUTzlBekNhSzBqZURRM2dQZXBURVdWN2VhIn0.eyJzY29wZSI6WyJkYXRhOnJlYWQiLCJkYXRhOndyaXRlIiwidmlld2FibGVzOnJlYWQiLCJidWNrZXQ6Y3JlYXRlIiwiYnVja2V0OnJlYWQiXSwiY2xpZW50X2lkIjoiYUpSTXJtb2s1VUFic2RzWGpja0ptU0Jtb05uWUtMek0iLCJhdWQiOiJodHRwczovL2F1dG9kZXNrLmNvbS9hdWQvYWp3dGV4cDYwIiwianRpIjoibk5iYVlqamRLME5OU1QzVndneHFtbEVVRFZaM1h0b2VydUtBM1FQSkxva2JQSVBMbWRaeWlQMUNIb2JnalZwUCIsImV4cCI6MTYyNTY1OTQ0NH0.CdolgqfI6YO4Bc7U7c3FGIR080fwlwDAXauXKPg4eqgjSdaYYdgK_ch-ahO-STi_Nl2p7a2TirotH3opgYp0CbyyXL6_fd8ETkk6eX0vKU0LOo7D6gk0CtigKWF7Xxta6icsWUM80lDNppYiSW1Cn1pWaAxHyQ4aSqfjlNVRdQ48V-d8MJ6VmbgCz57UyCcmUtkESrwgYzxOmvoVqwWDA72J6Uoj4gHU5pJnDjaOtzaOzIui11V1dgMZgsUkkoa1GpzarIsRKMeBGhyldTOD474pKn-L-vhM7qtfYjTbq24w9hHAHsnxWvuBdCMogwoWLh4mek4HPO72YpwTQAd8wA' -v 'https://developer.api.autodesk.com/modelderivative/v2/designdata/dXJuOmFkc2sub2JqZWN0czpvcy5vYmplY3Q6ZHR3aW4vZmxvb3JfNC5pZmM=/manifest'
\ No newline at end of file
diff --git a/examples/colorextension.js b/examples/colorextension.js
new file mode 100644
index 00000000..a1bdf86f
--- /dev/null
+++ b/examples/colorextension.js
@@ -0,0 +1,109 @@
+///////////////////////////////////////////////////////////////////////////////
+// Autodesk.ADN.Viewing.Extension.Color
+//
+///////////////////////////////////////////////////////////////////////////////
+AutodeskNamespace("Autodesk.ADN.Viewing.Extension");
+Autodesk.ADN.Viewing.Extension.Color = function(viewer, options) {
+
+    Autodesk.Viewing.Extension.call(this, viewer, options);
+
+    var overlayName = "temperary-colored-overlay";
+    var _self = this;
+    var defMaterials = {}
+
+    _self.load = function() {
+
+        console.log('Autodesk.ADN.Viewing.Extension.Color loaded');
+        ///////////////////////////////////////////////////////////////////////////
+        // Generate GUID
+        //
+        ///////////////////////////////////////////////////////////////////////////
+        // function newGuid() {
+        //     var d = new Date().getTime();
+        //     var guid = 'xxxx-xxxx-xxxx-xxxx-xxxx'.replace(/[xy]/g, function(c) {
+        //         var r = (d + Math.random() * 16) % 16 | 0;
+        //         d = Math.floor(d / 16);
+        //         return (c == 'x' ? r : (r & 0x7 | 0x8)).toString(16);
+        //     });
+        //     return guid;
+        // };
+
+        ///////////////////////////////////////////////////////////////////////////
+        // add new material
+        //
+        ///////////////////////////////////////////////////////////////////////////
+        function addMaterial(color, name) {
+            var material =  new THREE.MeshPhongMaterial({side: THREE.DoubleSide, color, opacity: 1, transparent: false})
+            viewer.impl.matman().addMaterial(name, material);
+            // viewer.impl.createOverlayScene(name, material, material);
+            return material;
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Set color for nodes
+        // objectIds should be an array of dbId
+        // 
+        //
+        ///////////////////////////////////////////////////////////////////////////
+        Autodesk.Viewing.Viewer3D.prototype.setColorMaterial = function(objectIds, color, name) {
+            var material = addMaterial(color, name);
+            const frags = viewer.model.getFragmentList();
+            for (var i=0; i<objectIds.length; i++) {
+
+                var dbid = objectIds[i];
+
+                //from dbid to node, to fragid
+                var it = viewer.model.getData().instanceTree;
+
+                it.enumNodeFragments(dbid, function (fragId) {
+    
+                    defMaterials[dbid] = viewer.model.getFragmentList().getMaterial(fragId);
+                    // var renderProxy = viewer.impl.getRenderProxy(viewer.model, fragId);
+                    
+                    // renderProxy.meshProxy = new THREE.Mesh(renderProxy.geometry, renderProxy.material);
+
+                    // renderProxy.meshProxy.matrix.copy(renderProxy.matrixWorld);
+                    // renderProxy.meshProxy.matrixWorldNeedsUpdate = true;
+                    // renderProxy.meshProxy.matrixAutoUpdate = false;
+                    // renderProxy.meshProxy.frustumCulled = false;
+
+                    // viewer.impl.addOverlay(name, renderProxy.meshProxy);
+                    frags.setMaterial(fragId, material);
+                    viewer.impl.invalidate(true);
+                    
+                }, false);
+            }
+
+        }
+
+
+        Autodesk.Viewing.Viewer3D.prototype.restoreColorMaterial = function(objectIds) {
+       
+            const frags = viewer.model.getFragmentList();
+            for (var i=0; i<objectIds.length; i++) {
+
+                var dbid = objectIds[i];
+
+                //from dbid to node, to fragid
+                var it = viewer.model.getData().instanceTree;
+
+                it.enumNodeFragments(dbid, function (fragId) {
+                    if (defMaterials[dbid]) {
+                        frags.setMaterial(fragId, defMaterials[dbid]);
+                        viewer.impl.invalidate(true);
+                    }
+                    
+                }, false);
+            }
+  
+        }
+
+        _self.unload = function() {
+            console.log('Autodesk.ADN.Viewing.Extension.Color unloaded');
+            return true;
+        };
+    };
+};
+Autodesk.ADN.Viewing.Extension.Color.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
+Autodesk.ADN.Viewing.Extension.Color.prototype.constructor = Autodesk.ADN.Viewing.Extension.Color;
+Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.ADN.Viewing.Extension.Color', Autodesk.ADN.Viewing.Extension.Color);
\ No newline at end of file
diff --git a/examples/colorextension_optimized.js b/examples/colorextension_optimized.js
new file mode 100644
index 00000000..15ac71c9
--- /dev/null
+++ b/examples/colorextension_optimized.js
@@ -0,0 +1,52 @@
+AutodeskNamespace("Autodesk.ADN.Viewing.Extension");
+Autodesk.ADN.Viewing.Extension.Color = function(viewer, options) {
+
+    Autodesk.Viewing.Extension.call(this, viewer, options);
+
+    var overlayName = "temperary-colored-overlay";
+    var _self = this;
+    var defMaterials = {}
+    var materials = {}
+
+    _self.load = function() {
+
+        console.log('Autodesk.ADN.Viewing.Extension.Color loaded');
+        
+        function addMaterial(color, name) {
+            if (name in materials){
+                return materials[name]
+            } else {
+                console.log('Creating Material for ', name)
+                const material = new THREE.Vector4(color[0], color[1], color[2], color[3]);
+                materials[name] = material
+                return material;
+            }
+
+        }
+
+        Autodesk.Viewing.Viewer3D.prototype.setColorMaterial = function(objectIds, color, name) {
+            var material = addMaterial(color, name);
+            const frags = viewer.model.getFragmentList();
+            //from dbid to node, to fragid
+            var it = viewer.model.getData().instanceTree;
+            for (var i=0; i<objectIds.length; i++) {
+                var dbid = objectIds[i];
+                viewer.setThemingColor(dbid, material, null, true);
+            }
+            viewer.impl.invalidate(true);
+        }
+
+        Autodesk.Viewing.Viewer3D.prototype.restoreColorMaterial = function(objectIds) {
+            viewer.clearThemingColors();
+            viewer.impl.invalidate(true);
+        }
+
+        _self.unload = function() {
+            console.log('Autodesk.ADN.Viewing.Extension.Color unloaded');
+            return true;
+        };
+    };
+};
+Autodesk.ADN.Viewing.Extension.Color.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
+Autodesk.ADN.Viewing.Extension.Color.prototype.constructor = Autodesk.ADN.Viewing.Extension.Color;
+Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.ADN.Viewing.Extension.Color', Autodesk.ADN.Viewing.Extension.Color);
\ No newline at end of file
diff --git a/examples/dtwin_viewer_v0.html b/examples/dtwin_viewer_v0.html
new file mode 100644
index 00000000..0624ae6a
--- /dev/null
+++ b/examples/dtwin_viewer_v0.html
@@ -0,0 +1,3603 @@
+<!DOCTYPE html>
+<html lang="en">
+  <head>
+    <meta charset="utf-8" />
+    <meta name="description" content="" />
+    <meta name="author" content="" />
+    <meta
+      name="viewport"
+      content="width=device-width, initial-scale=1.0, user-scalable=no"
+    />
+    <title>Potree Viewer</title>
+
+    <link rel="stylesheet" type="text/css" href="../build/potree/potree.css" />
+    <link
+      rel="stylesheet"
+      type="text/css"
+      href="../libs/jquery-ui/jquery-ui.min.css"
+    />
+    <link rel="stylesheet" type="text/css" href="../libs/openlayers3/ol.css" />
+    <link
+      rel="stylesheet"
+      type="text/css"
+      href="../libs/spectrum/spectrum.css"
+    />
+    <link
+      rel="stylesheet"
+      type="text/css"
+      href="../libs/jstree/themes/mixed/style.css"
+    />
+    <link
+      rel="stylesheet"
+      href="https://developer.api.autodesk.com/modelderivative/v2/viewers/7.*/style.min.css"
+      type="text/css"
+    />
+    <script src="https://developer.api.autodesk.com/modelderivative/v2/viewers/7.*/viewer3D.min.js"></script>
+    <link
+      rel="stylesheet"
+      href="https://fonts.googleapis.com/icon?family=Material+Icons"
+    />
+    <link
+      rel="stylesheet"
+      href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css"
+    />
+    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
+    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
+    <script src="./colorextension_optimized.js"></script>
+    <script>
+      (function (h, o, t, j, a, r) {
+        h.hj =
+          h.hj ||
+          function () {
+            (h.hj.q = h.hj.q || []).push(arguments);
+          };
+        h._hjSettings = { hjid: 2746579, hjsv: 6 };
+        a = o.getElementsByTagName("head")[0];
+        r = o.createElement("script");
+        r.async = 1;
+        r.src = t + h._hjSettings.hjid + j + h._hjSettings.hjsv;
+        a.appendChild(r);
+      })(window, document, "https://static.hotjar.com/c/hotjar-", ".js?sv=");
+    </script>
+    <style>
+      .dropup .dropdown-menu,
+      .navbar-fixed-bottom .dropdown .dropdown-menu {
+        bottom: 5%;
+        background-color: rgba(34, 34, 34, 0.94);
+      }
+      .dropdown-menu {
+        min-width: 230px;
+        left: 50px;
+      }
+      .panoIcon {
+        background: greenyellow;
+        border-radius: 100%;
+        position: absolute;
+        z-index: 101;
+        opacity: 0.7;
+      }
+
+      .panoIcon:hover {
+        background: rgb(0, 217, 255);
+        cursor: pointer;
+        opacity: 1;
+      }
+
+      .userIcon {
+        width: 20px;
+        height: 20px;
+        position: absolute;
+        z-index: 1000;
+      }
+
+      .actionIcon {
+        font-size: 50px;
+        /* border-style: double; */
+        color: white;
+        border-radius: 10px;
+        background-color: rgba(34, 34, 34, 0.94);
+        display: inline-block;
+        position: relative;
+      }
+
+      .actionIcon:hover {
+        cursor: pointer;
+      }
+
+      .fpFullScreen {
+        position: absolute;
+        top: 1%;
+        right: 1%;
+      }
+
+      .fpFullScreen:hover {
+        cursor: pointer;
+      }
+
+      .actionButtons {
+        position: absolute;
+        bottom: 10px;
+        width: calc(100% - 20px);
+        height: 50px;
+        text-align: center;
+        z-index: 100;
+        display: none;
+      }
+
+      .floormap {
+        position: absolute;
+        right: 0px;
+        top: 10px;
+        z-index: 100;
+        display: none;
+      }
+
+      .goto3d {
+        right: 2%;
+        position: absolute;
+        display: none;
+      }
+
+      .noBIM {
+        background: #e1e1e1;
+        margin: 0 auto;
+        position: absolute;
+        z-index: 200;
+        top: 25%;
+        left: 25%;
+        height: calc(100% - 50%);
+        width: calc(100% - 50%);
+        padding: 30px;
+        -webkit-box-shadow: 0 0 10px rgba(0, 0, 0, 0.4);
+        -moz-box-shadow: 0 0 10px rgba(0, 0, 0, 0.4);
+        box-shadow: 0 0 10px rgba(0, 0, 0, 0.4);
+        display: none;
+        text-align: center;
+        vertical-align: middle;
+      }
+      .utility_icons {
+        position: relative;
+        cursor: pointer;
+        padding: 6px;
+        margin: 4px;
+        border: 1px solid rgba(34, 34, 34, 0);
+        border-radius: 4px;
+        display: inline-block;
+        padding-top: 3px;
+        font-size: 24px;
+        line-height: 1;
+        background-repeat: no-repeat;
+        background-position: 50%;
+      }
+      .actionButtonsTest {
+        color: #f4f4f4;
+        background-color: rgba(34, 34, 34, 0.94);
+        box-shadow: 1px 3px 10px 0 rgb(0 0 0 / 50%);
+        position: relative;
+        float: left;
+        cursor: pointer;
+        padding: 6px;
+        margin: 4px;
+        border: 1px solid rgba(34, 34, 34, 0);
+        border-radius: 4px;
+      }
+      .icon-test {
+        padding: 5px;
+      }
+      .icon-test:hover {
+        color: #f5ca52;
+        border: 1px solid #f5ca52;
+      }
+      .icon-test:focus {
+        color: #f5ca52;
+        outline: none;
+        border-radius: 3px;
+        box-shadow: inset 0 2px 2px 0 #000;
+      }
+      .s3-icon {
+        width: 30px;
+        height: 30px;
+        margin: 2px;
+      }
+      #datepickerLeft,
+      #datepickerRight {
+        color: #000;
+        padding: 4px;
+        margin-right: 5px;
+      }
+      .closeBtn {
+        position: absolute;
+        float: left;
+        z-index: 9;
+      }
+      .bim-legend-container {
+        right: 10px;
+        bottom: 10px;
+        position: absolute;
+        background-color: rgba(34, 34, 34, 0.94);
+        z-index: 2;
+        display: none;
+      }
+
+      .bim-legend {
+        list-style: none;
+      }
+      .bim-legend li {
+        margin-right: 10px;
+        color: #f4f4f4;
+        cursor: pointer;
+      }
+      .bim-legend span {
+        border: 1px solid #ccc;
+        float: left;
+        width: 12px;
+        height: 12px;
+        margin: 2px;
+      }
+      .bim-legend .not_started {
+        background-color: #ff0000;
+      }
+      .bim-legend .in_progress {
+        background-color: #f39b3a;
+      }
+      .bim-legend .complete {
+        background-color: #71e03a;
+      }
+
+      .bim-details-card {
+        float: right;
+        width: 20%;
+        /* background:rgb(249, 247, 249); */
+        right: 1%;
+        top: 50%;
+        height: 25%;
+        position: absolute;
+        z-index: 2;
+        display: none;
+      }
+
+      table {
+        font-family: arial, sans-serif;
+        border-collapse: collapse;
+        width: 100%;
+      }
+
+      td,
+      th {
+        border: 1px solid #dddddd;
+        text-align: left;
+        padding: 8px;
+        background-color: #dddddd;
+      }
+
+      .bim-card-close {
+        right: 0px;
+        top: 0px;
+        z-index: 2;
+        position: absolute;
+      }
+
+      .bim-card-close:hover {
+        /* background: rgb(0, 217, 255); */
+        cursor: pointer;
+        /* opacity: 1; */
+      }
+    </style>
+  </head>
+
+  <body>
+    <script src="../libs/jquery/jquery-3.1.1.min.js"></script>
+    <script src="../libs/spectrum/spectrum.js"></script>
+    <script src="../libs/jquery-ui/jquery-ui.min.js"></script>
+    <script src="../libs/other/BinaryHeap.js"></script>
+    <script src="../libs/tween/tween.min.js"></script>
+    <script src="../libs/d3/d3.js"></script>
+    <script src="../libs/proj4/proj4.js"></script>
+    <script src="../libs/openlayers3/ol.js"></script>
+    <script src="../libs/i18next/i18next.js"></script>
+    <script src="../libs/jstree/jstree.js"></script>
+    <script src="../build/potree/potree.js"></script>
+    <script src="../libs/plasio/js/laslaz.js"></script>
+
+    <div
+      id="viewer_1"
+      style="position: absolute; width: 100%; height: 100%; left: 0px; top: 0px"
+    >
+      <div id="fpContainer_1" class="floormap" onclick="actionIconClick()">
+        <i
+          title="fullscreen"
+          id="fp_fullscreen_1"
+          data='{"id": "viewer_1", "type": "fp_fullscreen"}'
+          class="material-icons fpFullScreen"
+          >fullscreen</i
+        >
+        <i
+          title="minimise"
+          id="fp_minimise_1"
+          data='{"id": "viewer_1", "type": "fp_fullscreen"}'
+          class="material-icons fpFullScreen"
+          style="display: none"
+          >fullscreen_exit</i
+        >
+        <canvas id="floormap_1"></canvas>
+      </div>
+      <div id="no_bim_1" class="noBIM">
+        <p>Data Not Available</p>
+      </div>
+      <div
+        id="bim_details_card_container_1"
+        class="bim-details-card"
+        onclick="actionIconClick()"
+      >
+        <i
+          data='{"id": "viewer_1", "type": "bim_card_close"}'
+          class="material-icons bim-card-close"
+          >clear</i
+        >
+        <div id="bim_details_card_1"></div>
+      </div>
+      <div
+        id="bim_legend_1"
+        class="bim-legend-container bim-legend"
+        onclick="actionIconClick()"
+      >
+        <li
+          id="bim_not_started"
+          data='{"id": "viewer_1", "type": "bim_legend"}'
+        >
+          <span class="not_started"></span> Not Started
+        </li>
+        <li
+          id="bim_in_progress"
+          data='{"id": "viewer_1", "type": "bim_legend"}'
+        >
+          <span class="in_progress"></span> In Progress
+        </li>
+        <li id="bim_complete" data='{"id": "viewer_1", "type": "bim_legend"}'>
+          <span class="complete"></span> Complete
+        </li>
+      </div>
+      <div
+        id="action_buttons_1"
+        onclick="actionIconClick()"
+        class="actionButtons"
+      >
+        <div class="dropup actionButtonsTest">
+          <input class="datepickerDigi" type="text" id="datepickerLeft" />
+        </div>
+        <div title="bim compare" class="dropup actionButtonsTest">
+          <img
+            id="bim_compare_view_1"
+            data='{"id": "viewer_1", "type":"bim-compare"}'
+            src="https://dtwin-viewers.s3.ap-south-1.amazonaws.com/icons/3d-bim1.png"
+            class="s3-icon"
+          />
+        </div>
+        <div class="dropup actionButtonsTest">
+          <i
+            title="timeline compare"
+            id="compare_view_1"
+            data='{"id": "viewer_1", "type": "compare"}'
+            class="material-icons icon-test"
+            >compare</i
+          >
+        </div>
+        <div class="dropup actionButtonsTest">
+          <i
+            title="point cloud"
+            id="3d_view_1"
+            data='{"id": "viewer_1", "type": "3d"}'
+            class="material-icons icon-test"
+            style="display: none"
+            >3d_rotation</i
+          >
+        </div>
+        <div class="dropup actionButtonsTest">
+          <i
+            title="show images"
+            id="cameras_on_1"
+            data='{"id": "viewer_1", "type": "cameras", "condition": "on"}'
+            class="material-icons icon-test"
+            style="display: none"
+            >photo_camera</i
+          >
+          <i
+            title="hide images"
+            id="cameras_off_1"
+            data='{"id": "viewer_1", "type": "cameras", "condition": "off"}'
+            class="material-icons icon-test"
+            style="display: none"
+            >no_photography</i
+          >
+        </div>
+
+        <div class="dropup actionButtonsTest">
+          <i
+            id="measure_top_1"
+            data='{"id": "viewer_1", "type": "measure"}'
+            title="measure"
+            data-toggle="dropdown"
+            class="material-icons icon-test"
+            >straighten</i
+          >
+          <ul id="measure_tool_1" class="dropdown-menu" style="margin: unset">
+            <i
+              title="point"
+              data='{"id": "viewer_1", "type": "point"}'
+              class="material-icons icon-test"
+              >gps_fixed</i
+            >
+            <i
+              title="distance"
+              data='{"id": "viewer_1", "type": "distance"}'
+              class="material-icons icon-test"
+              >timeline</i
+            >
+            <i
+              title="area"
+              data='{"id": "viewer_1", "type": "area"}'
+              class="material-icons icon-test"
+              >crop</i
+            >
+            <i
+              title="height"
+              data='{"id": "viewer_1", "type": "height"}'
+              class="material-icons icon-test"
+              >height</i
+            >
+            <i
+              title="clear"
+              data='{"id": "viewer_1", "type": "clear"}'
+              class="material-icons icon-test"
+              >clear</i
+            >
+            <i
+              title="save"
+              data='{"id": "viewer_1", "type": "save"}'
+              class="material-icons icon-test"
+              >save</i
+            >
+          </ul>
+        </div>
+      </div>
+    </div>
+    <div
+      id="viewer_2"
+      style="
+        position: absolute;
+        width: 50%;
+        height: 100%;
+        right: 0px;
+        top: 0px;
+        display: none;
+      "
+    >
+      <div id="fpContainer_2" class="floormap" onclick="actionIconClick()">
+        <i
+          title="fullscreen"
+          id="fp_fullscreen_2"
+          data='{"id": "viewer_2", "type": "fp_fullscreen"}'
+          class="material-icons fpFullScreen"
+          >fullscreen</i
+        >
+        <i
+          title="minimise"
+          id="fp_minimise_2"
+          data='{"id": "viewer_2", "type": "fp_fullscreen"}'
+          class="material-icons fpFullScreen"
+          style="display: none"
+          >fullscreen_exit</i
+        >
+        <canvas id="floormap_2"></canvas>
+      </div>
+      <div id="no_bim_2" class="noBIM">
+        <p>Data Not Available</p>
+      </div>
+
+      <div
+        id="bim_details_card_container_2"
+        class="bim-details-card"
+        onclick="actionIconClick()"
+      >
+        <i
+          data='{"id": "viewer_2", "type": "bim_card_close"}'
+          class="material-icons bim-card-close"
+          >clear</i
+        >
+        <div id="bim_details_card_2"></div>
+      </div>
+
+      <div
+        id="bim_legend_2"
+        class="bim-legend-container bim-legend"
+        onclick="actionIconClick()"
+      >
+        <li
+          title="not srated"
+          id="bim_not_started"
+          data='{"id": "viewer_2", "type": "bim_legend"}'
+        >
+          <span class="not_started"></span> Not Started
+        </li>
+        <li
+          title="in progress"
+          id="bim_in_progress"
+          data='{"id": "viewer_2", "type": "bim_legend"}'
+        >
+          <span class="in_progress"></span> In Progress
+        </li>
+        <li
+          title="completed"
+          id="bim_complete"
+          data='{"id": "viewer_2", "type": "bim_legend"}'
+        >
+          <span class="complete"></span> Complete
+        </li>
+      </div>
+      <div
+        id="action_buttons_2"
+        onclick="actionIconClick()"
+        class="actionButtons"
+      >
+        <div class="dropup actionButtonsTest">
+          <input class="datepickerDigi" type="text" id="datepickerRight" />
+        </div>
+        <div title="bim compare" class="dropup actionButtonsTest">
+          <img
+            id="bim_compare_view_2"
+            data='{"id": "viewer_2", "type" : "bim-compare"}'
+            src="https://dtwin-viewers.s3.ap-south-1.amazonaws.com/icons/3d-bim1.png"
+            class="s3-icon"
+          />
+        </div>
+        <div class="dropup actionButtonsTest">
+          <i
+            title="timeline compare"
+            id="compare_view_2"
+            data='{"id": "viewer_2", "type": "3d"}'
+            class="material-icons icon-test"
+            >compare</i
+          >
+        </div>
+        <div class="dropup actionButtonsTest">
+          <i
+            title="point cloud"
+            id="3d_view_2"
+            data='{"id": "viewer_2", "type": "3d"}'
+            class="material-icons icon-test"
+            style="display: none"
+            >3d_rotation</i
+          >
+        </div>
+
+        <div class="dropup actionButtonsTest">
+          <i
+            title="show images"
+            id="cameras_on_2"
+            data='{"id": "viewer_2", "type": "cameras", "condition": "on"}'
+            class="material-icons icon-test"
+            style="display: none"
+            >photo_camera</i
+          >
+          <i
+            title="hide images"
+            id="cameras_off_2"
+            data='{"id": "viewer_2", "type": "cameras", "condition": "off"}'
+            class="material-icons icon-test"
+            style="display: none"
+            >no_photography</i
+          >
+        </div>
+
+        <div class="dropup actionButtonsTest">
+          <i
+            id="measure_top_2"
+            data='{"id": "viewer_2", "type": "measure"}'
+            title="measure"
+            data-toggle="dropdown"
+            class="material-icons icon-test"
+            >straighten</i
+          >
+          <ul id="measure_tool_2" class="dropdown-menu" style="margin: unset">
+            <i
+              title="point"
+              data='{"id": "viewer_2", "type": "point"}'
+              class="material-icons icon-test"
+              >gps_fixed</i
+            >
+            <i
+              title="distance"
+              data='{"id": "viewer_2", "type": "distance"}'
+              class="material-icons icon-test"
+              >timeline</i
+            >
+            <i
+              title="area"
+              data='{"id": "viewer_2", "type": "area"}'
+              class="material-icons icon-test"
+              >crop</i
+            >
+            <i
+              title="height"
+              data='{"id": "viewer_2", "type": "height"}'
+              class="material-icons icon-test"
+              >height</i
+            >
+            <i
+              title="clear"
+              data='{"id": "viewer_2", "type": "clear"}'
+              class="material-icons icon-test"
+              >clear</i
+            >
+            <i
+              title="save"
+              data='{"id": "viewer_2", "type": "save"}'
+              class="material-icons icon-test"
+              >save</i
+            >
+          </ul>
+        </div>
+      </div>
+      <div class="closeBtn actionButtonsTest" onclick="actionIconClick()">
+        <i
+          title="close compare"
+          data='{"id": "viewer_2", "type": "compare-close"}'
+          class="material-icons icon-test"
+          >clear</i
+        >
+      </div>
+    </div>
+
+    <script type="module">
+      // http://localhost:4200/examples/tourWrapperAdv.html?project=16&snapshot1=12&snapshot2=11&isExterior=0&isFM=1&mode=compare_bim
+      // http://localhost:4200/examples/tourWrapperAdv.html?project=25&snapshot1=16&snapshot2=17&isExterior=1&isFM=0&mode=compare_bim
+
+      function getParameterByName(name, url = window.location.href) {
+        name = name.replace(/[\[\]]/g, "\\$&");
+        var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
+          results = regex.exec(url);
+        if (!results) return null;
+        if (!results[2]) return "";
+        return decodeURIComponent(results[2].replace(/\+/g, " "));
+      }
+
+      function doAPIcall(in_url, in_method, in_token) {
+        return new Promise((resolve, reject) => {
+          $.ajax({
+            url: in_url,
+            method: in_method,
+            headers: {
+              authorization: "Bearer " + in_token,
+            },
+
+            success: (rawData) => {
+              console.log(rawData);
+              resolve(rawData);
+            },
+            error: (e) => {
+              console.log(e);
+              resolve(null);
+            },
+          });
+        });
+      }
+      const mainProjectID = getParameterByName("project");
+      const structure_id = getParameterByName("structure");
+      const inTilesetID = getParameterByName("snapshot1");
+      const inTilesetID2 = getParameterByName("snapshot2");
+      // const isExterior = parseInt(getParameterByName('isExterior'));
+      // const isFloorMap = parseInt(getParameterByName('isFM'));
+      const mode = getParameterByName("mode");
+      const token = getParameterByName("token"); //'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiJVU1IzOTA4OTUiLCJmaXJzdE5hbWUiOiJLcmlzaG5hIFRlamEiLCJsYXN0TmFtZSI6IlRhbmdhdHVyaSIsImVtYWlsIjoia3RkYWlpY3RAZ21haWwuY29tIiwiY29udGFjdCI6eyJjb2RlIjoiKzkxIiwibnVtYmVyIjo5Njc2MzE2MzIzfSwiZG9iIjoiMTk4OS0wMi0xNlQwMDowMDowMC4wMDBaIiwidmVyaWZpZWQiOnRydWUsImNyZWF0ZWRBdCI6IjIwMjItMDMtMjJUMTI6MTY6MzAuODk0WiIsInVwZGF0ZWRBdCI6IjIwMjItMDMtMjJUMTI6MTc6NTMuMTIyWiIsIl9fdiI6MCwiZnVsbE5hbWUiOiJLcmlzaG5hIFRlamEgVGFuZ2F0dXJpIiwiYWdlIjozMywiaWF0IjoxNjUxNzY4MDExLCJleHAiOjE2NTE3NzE2MTF9.xJT4oa55tODe7KzK7YkYM62NrpgJfWzusbevVggL_Vg'
+      // const structure_id = 'STR772693' //getParameterByName('structure');
+      const inProjectID = structure_id;
+      const structure_id_details = await doAPIcall(
+        "https://api.dev.constructn.ai/api/v1/projects/" +
+          mainProjectID +
+          "/structures/" +
+          structure_id,
+        "GET",
+        token
+      );
+      console.log(
+        "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
+      );
+      // console.log(structure_id_details)
+
+      const isExterior = structure_id_details["result"]["isExterior"] ? 1 : 0;
+
+      const isFloorMap = structure_id_details["result"]["isExterior"] ? 0 : 1;
+
+      console.log("Exterior : ", isExterior);
+
+      const inputCamera = JSON.parse(getParameterByName("camera"));
+      console.log("Input Camera ", inputCamera);
+
+      const inputTag = JSON.parse(getParameterByName("tag"));
+      console.log("Input Tag", inputTag);
+
+      let isCompareMode = false;
+      let isMouseOnV1 = true;
+      let compareType = "potree";
+      let viewerMode = "image";
+      let syncPotreeEvent = false;
+      let syncForgeEvent = false;
+      let bimProgressData = {};
+      let bimProgressMode = false;
+      var tagToAddOnImageLoad = null;
+      let progress_walk_index = 0;
+      let progress_walk_mode = false;
+
+      let s3_bucket = "constructn-projects"; //'digitrack-projects'
+
+      import * as THREE from "../libs/three.js/build/three.module.js";
+      // initFirstPotree();
+      // window.compareMode = compareMode;
+      // window.loadSnapshot = loadSnapshot;
+      // window.closeCompareMode = closeCompareMode;
+      // window.addMeasure = addMeasure;
+      // window.removeMeasure = removeMeasure;
+      window.actionIconClick = actionIconClick;
+      window.locate = locate;
+      window.getInverse = getInverse;
+      window.select_group_bim = select_group_bim;
+      window.bimDefaultView = bimDefaultView;
+      window.remove_group_bim = remove_group_bim;
+      window.addTag = addTag;
+      window.start_progress_delta_walk = start_progress_delta_walk;
+      window.exit_progress_walk = exit_progress_walk;
+      window.update_progress_walk = update_progress_walk;
+
+      if (mode == "3d") {
+        initFirstPotree();
+      } else if (mode == "compare_3d") {
+        initFirstPotree();
+        compareMode("potree");
+      } else if (mode == "compare_bim") {
+        initFirstPotree();
+        compareMode("forge");
+      } else if (mode == "bim") {
+        viewerMode = "3d";
+        initForge(inProjectID, inTilesetID, "viewer_1", inputCamera);
+        // document.getElementById('fpContainer_2').style.display = 'none';
+      }
+
+      window.addEventListener("message", function (e) {
+        console.log("From Parent : ", e.data);
+        if (e.data.type == "getCamera") {
+          let cam = locate(viewer_1);
+          console.log("Sending Camera Details to Parent : ", cam);
+          window.top.postMessage(
+            { type: "camera", data: JSON.stringify(cam) },
+            "*"
+          );
+        } else if (e.data.type == "context") {
+          flyToContext(e.data.data);
+        } else if (e.data.type == "select-tag") {
+          let tagData = JSON.parse(e.data.data);
+          console.log(tagData);
+          flyToTagContext(tagData);
+        } else if (e.data.type == "bim-grouping") {
+          let data = e.data.data;
+          if (viewer_1.customtype == "forge") {
+            select_group_bim(data.guids, viewer_1, data.mode, data.condition);
+          } else if (compareMode && viewer_2.customtype == "forge") {
+            select_group_bim(data.guids, viewer_2, data.mode, data.condition);
+          }
+        } else if (e.data.type == "reset-bim-grouping") {
+          if (viewer_1.customtype == "forge") {
+            remove_group_bim(viewer_1, e.data.data.mode);
+          } else if (compareMode && viewer_2.customtype == "forge") {
+            remove_group_bim(viewer_2, e.data.data.mode);
+          }
+        }
+      });
+
+      function initFirstPotree() {
+        if (inTilesetID == "") {
+          document.getElementById("no_bim_1").style.display = "block";
+        } else {
+          window.viewer_1 = new Potree.Viewer(
+            document.getElementById("viewer_1")
+          );
+          viewer_1.setFOV(60);
+          viewer_1.setPointBudget(1 * 1000 * 1000);
+          document.title = "";
+          viewer_1.setEDLEnabled(false);
+          viewer_1.setBackground("gradient"); // ["skybox", "gradient", "black", "white"];
+          viewer_1.setDescription(``);
+          viewer_1.loadSettingsFromURL();
+          viewer_1.canvasId = "viewer_1";
+          viewer_1.customtype = "potree";
+
+          viewer_1.loadGUI(async () => {
+            viewer_1.setLanguage("en");
+            console.log("VIewer_1 Loaded");
+            viewer_1.fpContainerId = "fpContainer_1";
+            viewer_1.fpCanvasId = "floormap_1";
+            loadSnapshot(
+              viewer_1,
+              inProjectID,
+              inTilesetID,
+              false,
+              inputCamera
+            );
+            viewer_1.tileset = inTilesetID;
+            toggleVisibility("action_buttons_1", true);
+            addEventListeners();
+          });
+        }
+      }
+
+      function addEventListeners() {
+        document
+          .getElementById("viewer_1")
+          .addEventListener("mouseenter", () => {
+            isMouseOnV1 = true;
+          });
+        document
+          .getElementById("viewer_2")
+          .addEventListener("mouseenter", () => {
+            isMouseOnV1 = false;
+          });
+
+        document.addEventListener("imageLoad", (event) => {
+          console.log("imageLoad ", event.detail.viewer, event.detail.image);
+          viewer_1.scene.removeAllMeasurements();
+          if (isCompareMode && compareType == "potree") {
+            viewer_2.scene.removeAllMeasurements();
+          }
+          viewerMode = "image";
+          toggleVisibility("3d_view_1", true);
+          toggleVisibility("3d_view_2", true);
+
+          if (event.detail.viewer == "viewer_1") {
+            viewer_1.cur_loaded_image = event.detail.image.id;
+          } else {
+            viewer_2.cur_loaded_image = event.detail.image.id;
+          }
+
+          if (isCompareMode) {
+            if (compareType == "forge") {
+              setForgeControls("image");
+            } else {
+              maintainContext(event.detail.viewer, event.detail.image);
+            }
+          }
+          pointCloudView(true);
+
+          setTimeout(() => {
+            if (tagToAddOnImageLoad != null) {
+              console.log("Adding Tag");
+              console.log(tagToAddOnImageLoad["info"]);
+              addTag(
+                tagToAddOnImageLoad["info"],
+                tagToAddOnImageLoad["viewer"]
+              );
+              tagToAddOnImageLoad = null;
+            }
+          }, 100);
+        });
+
+        document.addEventListener("imageUnload", (event) => {
+          console.log("imageUnload ", event.detail.viewer);
+          toggleVisibility("3d_view_1", false);
+          toggleVisibility("3d_view_2", false);
+          viewer_1.scene.removeAllClipVolumes(); // To remove hovered image
+          viewer_1.scene.removeAllMeasurements();
+          viewer_1.cur_loaded_image = null;
+          if (isCompareMode) {
+            viewerMode = "3d";
+            if (isCompareMode && compareType == "potree") {
+              viewer_2.scene.removeAllMeasurements();
+            }
+            viewer_2.cur_loaded_image = null;
+            if (compareType == "forge") {
+              setForgeControls("orbit");
+            } else {
+              if (event.detail.viewer == "viewer_1") {
+                viewer_2.scene.orientedImages[0].release();
+              } else {
+                viewer_1.scene.orientedImages[0].release();
+              }
+              viewer_2.scene.removeAllClipVolumes(); // To remove hovered image
+            }
+            viewer_1.fitToScreen();
+            if (!isMouseOnV1) {
+              if (compareType == "potree") {
+                viewer_2.fitToScreen();
+              } else {
+                viewer_2.navigation.setRequestFitToView(true);
+              }
+            }
+            pointCloudView(false);
+          } else if (event.detail.viewer == "viewer_1") {
+            viewer_1.fitToScreen();
+            pointCloudView(false);
+            viewerMode = "3d";
+          }
+        });
+
+        let zoomHandler_1 = (e) => {
+          let fov_delta = e.wheelDelta < 0 ? -5 : 5;
+          let fov = viewer_1.getFOV() + fov_delta;
+          if (fov > 10 && fov < 100) {
+            viewer_1.setFOV(fov);
+          }
+          isCompareMode && syncViewers();
+        };
+
+        let zoomHandler_2 = (e) => {
+          let fov_delta = e.wheelDelta < 0 ? -5 : 5;
+          let fov = viewer_2.getFOV() + fov_delta;
+          if (fov > 10 && fov < 100) {
+            viewer_2.setFOV(fov);
+          }
+          isCompareMode && syncViewers();
+        };
+
+        document.addEventListener("panoLoad", (event) => {
+          console.log("panoLoad ", event.detail.viewer, event.detail.image);
+          viewerMode = "panorama";
+          viewer_1.renderArea.addEventListener("mousewheel", zoomHandler_1);
+          viewer_1.scene.removeAllMeasurements();
+          if (isCompareMode && compareType == "potree") {
+            viewer_2.renderArea.addEventListener("mousewheel", zoomHandler_2);
+            viewer_2.scene.removeAllMeasurements();
+          }
+          if (event.detail.viewer == "viewer_1") {
+            viewer_1.cur_loaded_image = event.detail.image.file
+              .split("/")
+              .pop();
+          } else {
+            viewer_2.cur_loaded_image = event.detail.image.file
+              .split("/")
+              .pop();
+          }
+          if (isCompareMode) {
+            if (compareType == "forge") {
+              setForgeControls("panorama");
+            } else {
+              maintainContext(event.detail.viewer, event.detail.image);
+            }
+          }
+          pointCloudView(true);
+
+          if (viewer_1.isFloorMap) {
+            toggleFloorMap(viewer_1, true);
+          }
+
+          if (isCompareMode && compareType == "potree" && viewer_2.isFloorMap) {
+            toggleFloorMap(viewer_2, true);
+          }
+
+          setTimeout(() => {
+            if (tagToAddOnImageLoad != null) {
+              console.log("Adding Tag");
+              console.log(tagToAddOnImageLoad["info"]);
+              addTag(
+                tagToAddOnImageLoad["info"],
+                tagToAddOnImageLoad["viewer"]
+              );
+              tagToAddOnImageLoad = null;
+            }
+          }, 100);
+        });
+
+        document.addEventListener("panoUnload", (event) => {
+          console.log("panoUnload ", event.detail.viewer);
+          viewer_1.cur_loaded_image = null;
+          viewer_1.scene.removeAllMeasurements();
+          viewer_1.renderArea.removeEventListener("mousewheel", zoomHandler_1);
+          if (isCompareMode) {
+            viewer_2.cur_loaded_image = null;
+            if (isCompareMode && compareType == "potree") {
+              viewer_2.renderArea.removeEventListener(
+                "mousewheel",
+                zoomHandler_2
+              );
+              viewer_2.scene.removeAllMeasurements();
+            }
+            viewerMode = "3d";
+            if (compareType == "forge") {
+              setForgeControls("orbit");
+            } else {
+              if (event.detail.viewer == "viewer_1") {
+                viewer_2.scene.images360[0].unfocus();
+              } else {
+                viewer_1.scene.images360[0].unfocus();
+              }
+            }
+            viewer_1.fitToScreen();
+            if (!isMouseOnV1) {
+              if (compareType == "potree") {
+                viewer_2.fitToScreen();
+              } else {
+                viewer_2.navigation.setRequestFitToView(true);
+              }
+            }
+            pointCloudView(false);
+
+            if (viewer_1.isFloorMap) {
+              toggleFloorMap(viewer_1, false);
+            }
+
+            if (compareType == "potree" && viewer_2.isFloorMap) {
+              toggleFloorMap(viewer_2, false);
+            }
+          } else if (event.detail.viewer == "viewer_1") {
+            viewer_1.fitToScreen();
+            pointCloudView(false);
+            if (viewer_1.isFloorMap) {
+              toggleFloorMap(viewer_1, false);
+            }
+            viewerMode = "3d";
+          }
+        });
+
+        // Keyboard Shortcuts
+
+        document.addEventListener("keydown", (event) => {
+          if (event.key === "Escape") {
+            // Exit in viewer 2 is already handled in contex maintanance
+            if (viewerMode == "image") {
+              viewer_1.controls.elExit.click();
+            }
+            // else if (viewerMode == 'panorama') {
+            //     viewer_1.scene.images360[0].unfocus();
+            // }
+          } else if (event.key === "ArrowUp") {
+            // up arrow
+            if (viewerMode == "image") {
+              viewer_1.controls.elUp.click();
+              if (isCompareMode && compareType == "potree") {
+                viewer_2.controls.elUp.click();
+              }
+            } else if (viewerMode == "panorama") {
+              if (event.ctrlKey) {
+                setPitch(viewer_1, 0.5);
+                if (isCompareMode && compareType == "potree") {
+                  setPitch(viewer_2, 0.5);
+                }
+              } else {
+                nextPanoImage(viewer_1);
+              }
+            }
+          } else if (event.key === "ArrowDown") {
+            // down arrow
+            if (viewerMode == "image") {
+              viewer_1.controls.elDown.click();
+              if (isCompareMode && compareType == "potree") {
+                viewer_2.controls.elDown.click();
+              }
+            } else if (viewerMode == "panorama") {
+              if (event.ctrlKey) {
+                setPitch(viewer_1, -0.5);
+                if (isCompareMode && compareType == "potree") {
+                  setPitch(viewer_2, -0.5);
+                }
+              }
+            }
+          } else if (event.key === "ArrowLeft") {
+            // left arrow
+            if (viewerMode == "image") {
+              viewer_1.controls.elLeft.click();
+              if (isCompareMode && compareType == "potree") {
+                viewer_2.controls.elLeft.click();
+              }
+            } else if (viewerMode == "panorama") {
+              setYaw(viewer_1, 0.5);
+              if (isCompareMode && compareType == "potree") {
+                setYaw(viewer_2, 0.5);
+              }
+            }
+          } else if (event.key === "ArrowRight") {
+            // right arrow
+            if (viewerMode == "image") {
+              viewer_1.controls.elRight.click();
+              if (isCompareMode && compareType == "potree") {
+                viewer_2.controls.elRight.click();
+              }
+            } else if (viewerMode == "panorama") {
+              setYaw(viewer_1, -0.5);
+              if (isCompareMode && compareType == "potree") {
+                setYaw(viewer_2, -0.5);
+              }
+            }
+          }
+        });
+
+        // document.addEventListener('mousedown', event => {
+        // 	sendSyncEvents = true;
+        // });
+        // document.addEventListener('mouseup', event => {
+        // 	sendSyncEvents = false;
+        // });
+
+        document.addEventListener("camerachange", (event) => {
+          syncPotreeEvent = true;
+        });
+      }
+
+      function pointCloudView(cond) {
+        viewer_1.setEDLEnabled(cond);
+        if (cond) {
+          viewer_1.setEDLOpacity(0);
+        } else {
+          viewer_1.setEDLOpacity(1);
+        }
+        if (isCompareMode && compareType == "potree") {
+          viewer_2.setEDLEnabled(cond);
+          if (cond) {
+            viewer_2.setEDLOpacity(0);
+          } else {
+            viewer_2.setEDLOpacity(1);
+          }
+        }
+      }
+
+      function maintainContext(viewerId, info) {
+        if (viewerMode == "image") {
+          let nearestImage = null;
+          let nearestImageDist = 10000;
+          if (viewerId == "viewer_1" && viewer_2.scene.orientedImages[0]) {
+            viewer_2.scene.orientedImages[0].images.forEach((image) => {
+              let curDist = image.position.distanceTo(info.position);
+              if (curDist < nearestImageDist) {
+                nearestImageDist = curDist;
+                nearestImage = image;
+              }
+            });
+            if (nearestImage) {
+              console.log(nearestImage.id);
+              viewer_2.scene.orientedImages[0].moveToImage(nearestImage, false);
+              viewer_2.cur_loaded_image = nearestImage.id;
+            }
+          } else if (viewer_1.scene.orientedImages[0]) {
+            viewer_1.scene.orientedImages[0].images.forEach((image) => {
+              let curDist = image.position.distanceTo(info.position);
+              if (curDist < nearestImageDist) {
+                nearestImageDist = curDist;
+                nearestImage = image;
+              }
+            });
+            if (nearestImage) {
+              console.log(nearestImage.id);
+              viewer_1.scene.orientedImages[0].moveToImage(nearestImage, false);
+              viewer_1.cur_loaded_image = nearestImage.id;
+            }
+          }
+        } else {
+          let nearestImage = null;
+          let nearestImageDist = 1000;
+          let inputPos = new THREE.Vector2().fromArray([
+            info.position[0],
+            info.position[1],
+          ]);
+          if (viewerId == "viewer_1") {
+            if (viewer_2.scene.images360[0]) {
+              viewer_2.scene.images360[0].images.forEach((pano) => {
+                let curPos = new THREE.Vector2().fromArray([
+                  pano.position[0],
+                  pano.position[1],
+                ]);
+                let curDist = curPos.distanceTo(inputPos);
+                if (curDist < nearestImageDist) {
+                  nearestImageDist = curDist;
+                  nearestImage = pano;
+                }
+              });
+              if (nearestImage) {
+                console.log(nearestImage.file);
+                viewer_2.scene.images360[0].focus(nearestImage, false);
+                viewer_2.cur_loaded_image = nearestImage.file.split("/").pop();
+              }
+            }
+          } else if (viewer_1.scene.images360[0]) {
+            viewer_1.scene.images360[0].images.forEach((pano) => {
+              let curPos = new THREE.Vector2().fromArray([
+                pano.position[0],
+                pano.position[1],
+              ]);
+              let curDist = curPos.distanceTo(inputPos);
+              if (curDist < nearestImageDist) {
+                nearestImageDist = curDist;
+                nearestImage = pano;
+              }
+            });
+            if (nearestImage) {
+              console.log(nearestImage.file);
+              viewer_1.scene.images360[0].focus(nearestImage, false);
+              viewer_1.cur_loaded_image = nearestImage.file.split("/").pop();
+            }
+          }
+        }
+      }
+
+      function getNearestImage(viewer, camInfo, mode) {
+        let nearestImage = null;
+        let nearestImageDist = 10000;
+        if (mode == "image") {
+          viewer.scene.orientedImages[0].images.forEach((image) => {
+            let curDist = image.position.distanceTo(camInfo.position);
+            if (curDist < nearestImageDist) {
+              nearestImageDist = curDist;
+              nearestImage = image;
+            }
+          });
+          if (nearestImage) {
+            console.log(nearestImage.id);
+            viewer.scene.orientedImages[0].moveToImage(nearestImage);
+          }
+        } else {
+          let inputPos = new THREE.Vector2().fromArray([
+            camInfo.position.x,
+            camInfo.position.y,
+          ]);
+          viewer.scene.images360[0].images.forEach((pano) => {
+            let curPos = new THREE.Vector2().fromArray([
+              pano.position[0],
+              pano.position[1],
+            ]);
+            let curDist = curPos.distanceTo(inputPos);
+            if (curDist < nearestImageDist) {
+              nearestImageDist = curDist;
+              nearestImage = pano;
+            }
+          });
+          if (nearestImage) {
+            console.log(nearestImage.file);
+            viewer.scene.images360[0].focus(nearestImage, true, camInfo);
+          }
+        }
+      }
+
+      function syncViewers() {
+        if (isCompareMode) {
+          if (viewerMode == "3d") {
+            if (isMouseOnV1) {
+              if (compareType == "potree") {
+                let v1Pos = viewer_1.scene.view.position.toArray();
+                viewer_2.scene.view.position.set(v1Pos[0], v1Pos[1], v1Pos[2]);
+                viewer_2.scene.view.lookAt(viewer_1.scene.view.getPivot());
+                viewer_2.setFOV(viewer_1.fov);
+              } else if (syncPotreeEvent) {
+                // Conditional syncing only for forge
+                viewer_2.navigation.setPosition(
+                  viewer_1.scene.view.position.clone()
+                );
+                viewer_2.navigation.setTarget(viewer_1.scene.view.getPivot());
+                viewer_2.navigation.setVerticalFov(viewer_1.fov, false);
+              }
+            } else {
+              if (compareType == "potree") {
+                let v2Pos = viewer_2.scene.view.position.toArray();
+                viewer_1.scene.view.position.set(v2Pos[0], v2Pos[1], v2Pos[2]);
+                viewer_1.scene.view.lookAt(viewer_2.scene.view.getPivot());
+                viewer_1.setFOV(viewer_2.fov);
+              } else if (syncForgeEvent) {
+                viewer_2.navigation.setCameraUpVector(
+                  new THREE.Vector3().fromArray([0, 0, 1])
+                );
+                const state = viewer_2.getState({ viewport: true }).viewport;
+                viewer_1.scene.view.position.set(
+                  state.eye[0],
+                  state.eye[1],
+                  state.eye[2]
+                );
+                viewer_1.scene.view.lookAt(
+                  new THREE.Vector3().fromArray(state.target)
+                );
+                viewer_1.setFOV(state.fieldOfView);
+                // viewer_2.navigation.setWorldUpVector(new THREE.Vector3().fromArray([0, 0, 1]), false);
+              }
+            }
+          } else if (viewerMode == "panorama" && compareType == "potree") {
+            if (isMouseOnV1) {
+              viewer_2.scene.view.pitch = viewer_1.scene.view.pitch;
+              viewer_2.scene.view.yaw = viewer_1.scene.view.yaw;
+              viewer_2.fov = viewer_1.fov;
+            } else {
+              viewer_1.scene.view.pitch = viewer_2.scene.view.pitch;
+              viewer_1.scene.view.yaw = viewer_2.scene.view.yaw;
+              viewer_1.fov = viewer_2.fov;
+            }
+          } else if (compareType == "forge" && syncPotreeEvent) {
+            // Do nothing if secondary viewer is potree
+            viewer_2.navigation.setPosition(
+              viewer_1.scene.view.position.clone()
+            );
+            viewer_2.navigation.setTarget(viewer_1.scene.view.getPivot());
+            viewer_2.navigation.setVerticalFov(viewer_1.fov, false);
+          }
+          syncPotreeEvent = false;
+          syncForgeEvent = false;
+        }
+      }
+
+      async function loadPointCloud(
+        viewer,
+        projectID,
+        tilesetID,
+        secondary = false,
+        inCamera
+      ) {
+        let pcMatrix = new THREE.Matrix4().set(
+          1,
+          0,
+          0,
+          0,
+          0,
+          1,
+          0,
+          0,
+          0,
+          0,
+          1,
+          0,
+          0,
+          0,
+          0,
+          1
+        );
+        let pcOffset = [0, 0, 0];
+        viewer["globalOffset"] = pcOffset;
+        const tm_json_raw = await fetch(
+          `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${projectID}/snapshots/${tilesetID}/pointcloud/tm.json`
+        );
+        if (tm_json_raw.status == 200) {
+          const tm_json = JSON.parse(await tm_json_raw.text());
+          if (tm_json.tm) {
+            pcMatrix = new THREE.Matrix4().fromArray(tm_json.tm).transpose();
+          }
+          if (tm_json.offset) {
+            pcOffset = tm_json.offset;
+          }
+          viewer["globalOffset"] = pcOffset;
+          if (inCamera) {
+            let pos = inCamera.position;
+            let tar = inCamera.target;
+            let offset = viewer.globalOffset;
+            inCamera.position = new THREE.Vector3(
+              pos[0] - offset[0],
+              pos[1] - offset[1],
+              pos[2] - offset[2]
+            );
+            inCamera.target = new THREE.Vector3(
+              tar[0] - offset[0],
+              tar[1] - offset[1],
+              tar[2] - offset[2]
+            );
+          }
+          console.log("PC TM Loaded", tm_json);
+        }
+
+        Potree.loadPointCloud(
+          `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${projectID}/snapshots/${tilesetID}/pointcloud/cloud.json`,
+          projectID + "_" + tilesetID,
+          (e) => {
+            let scene = viewer.scene;
+            let pointcloud = e.pointcloud;
+
+            let material = pointcloud.material;
+            material.size = 1;
+            material.pointSizeType = Potree.PointSizeType.FIXED;
+            material.shape = Potree.PointShape.SQUARE;
+            pointcloud.applyMatrix(pcMatrix);
+            const assetPosition = pointcloud.position.clone();
+            pointcloud.position.set(
+              assetPosition.x - pcOffset[0],
+              assetPosition.y - pcOffset[1],
+              assetPosition.z - pcOffset[2]
+            );
+            scene.addPointCloud(pointcloud);
+            viewer.fitToScreen();
+            console.log("Point Cloud Loaded");
+
+            let startWithImage = true;
+
+            if (inputTag && !inputTag.image) {
+              let startWithImage = false;
+              viewerMode = "3d";
+              flyToContext(inputTag.camera);
+            }
+
+            if (isExterior) {
+              console.log("Exterior Project");
+              loadDroneImages(
+                viewer,
+                projectID,
+                tilesetID,
+                { tm: pcMatrix, offset: pcOffset },
+                secondary,
+                inCamera,
+                startWithImage
+              );
+              if (viewer.canvasId == "viewer_1") {
+                document.getElementById("cameras_off_1").style.display =
+                  "inline-block";
+              } else {
+                document.getElementById("cameras_off_2").style.display =
+                  "inline-block";
+              }
+            } else {
+              console.log("Interior Project");
+              // loadPanoImages(viewer, projectID, tilesetID, {tm: pcMatrix, offset1: [232067.2387, 1936749.6433, 563], offset: pcOffset}, secondary);
+              loadPanoImages(
+                viewer,
+                projectID,
+                tilesetID,
+                { tm: new THREE.Matrix4(), offset: pcOffset },
+                secondary,
+                inCamera,
+                startWithImage
+              );
+            }
+          }
+        );
+      }
+
+      function loadDroneImages(
+        viewer,
+        projectID,
+        tilesetID,
+        tmatrix,
+        secondary,
+        inCamera,
+        showImage
+      ) {
+        const imageParamsPath = `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${projectID}/snapshots/${tilesetID}/images.json`;
+        const imagesPath = `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${projectID}/snapshots/${tilesetID}/images`;
+        Potree.OrientedImageLoader.load(
+          imageParamsPath,
+          imagesPath,
+          viewer,
+          tmatrix
+        ).then((images) => {
+          viewer.scene.addOrientedImages(images);
+          // setTimeout(() => {
+          if (showImage) {
+            if (secondary && viewerMode == "image") {
+              maintainContext(
+                "viewer_1",
+                viewer_1.scene.orientedImages[0].focused
+              );
+              pointCloudView(true);
+            } else if (!secondary) {
+              // setTimeout(() => {
+              if (inputTag) {
+                flyToTagContext(inputTag);
+              } else if (inCamera) {
+                if (Array.isArray(inCamera.position)) {
+                  inCamera.position = new THREE.Vector3().fromArray(
+                    inCamera.position
+                  );
+                  inCamera.target = new THREE.Vector3().fromArray(
+                    inCamera.target
+                  );
+                }
+                getNearestImage(viewer, inCamera, "image");
+              } else {
+                viewer.scene.orientedImages[0].moveToImage(
+                  viewer.scene.orientedImages[0].images[0]
+                );
+              }
+              // }, 2000);
+            }
+          }
+          // }, 2000);
+        });
+      }
+
+      function loadPanoImages(
+        viewer,
+        projectID,
+        tilesetID,
+        tmatrix,
+        secondary,
+        inCamera,
+        showImage
+      ) {
+        viewerMode = "panorama";
+        const imageParamsPath = `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${projectID}/snapshots/${tilesetID}/images.json`;
+        // const imageParamsPath = `http://localhost:1234/indoor_images_15_17_48_66.json`;
+        // const imagesPath = `https://localhost:1234`
+        const imagesPath = `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${projectID}/snapshots/${tilesetID}/images`;
+        Potree.Images360Loader.load(
+          imageParamsPath,
+          imagesPath,
+          viewer,
+          tmatrix
+        ).then((images) => {
+          viewer.scene.add360Images(images);
+          if (showImage) {
+            if (secondary && viewerMode == "panorama") {
+              maintainContext(
+                "viewer_1",
+                viewer_1.scene.images360[0].focusedImage
+              );
+              // pointCloudView(true);viewer_2.navigation.setCameraUpVector(new THREE.Vector3().fromArray([0, 0, 1]));
+            } else if (!secondary) {
+              if (inputTag) {
+                flyToTagContext(inputTag);
+              } else if (inCamera) {
+                getNearestImage(viewer, inCamera, "panorama");
+              } else {
+                viewer.scene.images360[0].focus(
+                  viewer.scene.images360[0].images[0]
+                );
+              }
+            }
+          }
+        });
+      }
+
+      function compareMode(type) {
+        let pid = inProjectID;
+        let tid = inTilesetID2;
+        if (isCompareMode) {
+          closeCompareMode();
+        }
+        compareType = type;
+        document.getElementById("viewer_1").style.width = "50%";
+        document.getElementById("viewer_2").style.display = "block";
+
+        isCompareMode = true;
+        if (type == "potree") {
+          initSecondPotree(pid, tid);
+        } else {
+          initForge(pid, inTilesetID, "viewer_2");
+          document.getElementById("fpContainer_2").style.display = "none";
+        }
+
+        if (viewer_1.isFloorMap) {
+          updateFPSize(viewer_1.floorMap);
+        }
+      }
+
+      function closeCompareMode() {
+        isCompareMode = false;
+        document.getElementById("viewer_1").style.width = "100%";
+        document.getElementById("viewer_2").style.display = "none";
+        if (compareType == "forge") {
+          viewer_2.finish();
+          viewer_2 = null;
+          Autodesk.Viewing.shutdown();
+        } else {
+          removeAssets(viewer_2);
+          viewer_2 = null;
+        }
+
+        if (viewer_1.isFloorMap) {
+          updateFPSize(viewer_1.floorMap);
+        }
+      }
+
+      function initSecondPotree(pid_2, tid_2) {
+        if (tid_2 == "") {
+          document.getElementById("no_bim_2").style.display = "block";
+          isCompareMode = false;
+        } else {
+          window.viewer_2 = new Potree.Viewer(
+            document.getElementById("viewer_2")
+          );
+          viewer_2.setFOV(60);
+          viewer_2.setPointBudget(1 * 1000 * 1000);
+          document.title = "";
+          viewer_2.setEDLEnabled(false);
+          viewer_2.setBackground("gradient"); // ["skybox", "gradient", "black", "white"];
+          viewer_2.setDescription(``);
+          viewer_2.loadSettingsFromURL();
+          viewer_2.canvasId = "viewer_2";
+          viewer_2.customtype = "potree";
+
+          viewer_2.loadGUI(async () => {
+            viewer_2.setLanguage("en");
+            console.log("Viewer_2 Loaded");
+            isCompareMode = true;
+            viewer_2.fpContainerId = "fpContainer_2";
+            viewer_2.fpCanvasId = "floormap_2";
+            loadSnapshot(viewer_2, pid_2, tid_2, true);
+            viewer_2.tileset = tid_2;
+            toggleVisibility("action_buttons_2", true);
+          });
+        }
+      }
+
+      function removeAssets(viewer) {
+        viewer.scene.scenePointCloud.remove(viewer.scene.pointclouds[0]);
+        viewer.scene.pointclouds = [];
+        if (viewer.scene.orientedImages.length) {
+          viewer.scene.orientedImages[0].release();
+          viewer.scene.orientedImages[0].images.forEach((image) => {
+            viewer.scene.scene.children[0].remove(image.mesh);
+            viewer.scene.scene.children[0].remove(image.line);
+          });
+          viewer.scene.scene.remove(viewer.scene.scene.children[0]);
+          viewer.scene.removeOrientedImages(viewer.scene.orientedImages[0]);
+        }
+
+        if (viewer.scene.images360.length) {
+          viewer.scene.images360[0].unfocus(false);
+          viewer.scene.images360[0].images.forEach((image) => {
+            viewer.scene.scene.children[0].remove(image.mesh);
+          });
+          viewer.scene.scene.children[0].remove(
+            viewer.scene.images360[0].sphere
+          );
+          viewer.scene.scene.remove(viewer.scene.scene.children[0]);
+          viewer.scene.remove360Images(viewer.scene.images360[0]);
+        }
+        if (viewer.isFloorMap) {
+          removeFloorMap(viewer);
+        }
+      }
+
+      function loadSnapshot(
+        viewer,
+        pid,
+        tid,
+        secondary = false,
+        inCamera = null
+      ) {
+        removeAssets(viewer);
+        loadPointCloud(viewer, pid, tid, secondary, inCamera);
+        isFloorMap &&
+          loadFloormap(
+            viewer.fpContainerId,
+            viewer.fpCanvasId,
+            viewer,
+            pid,
+            tid
+          );
+      }
+
+      function getAutodeskToken() {
+        return new Promise((resolve, reject) => {
+          $.ajax({
+            url: "https://developer.api.autodesk.com/authentication/v1/authenticate",
+            method: "POST",
+            headers: {
+              "Content-Type": "application/x-www-form-urlencoded",
+            },
+            data: {
+              client_id: "aJRMrmok5UAbsdsXjckJmSBmoNnYKLzM",
+              // client_id: 'iXWYm3FVGMhLYLssAQAwdMGMq5HsAwNb',
+              client_secret: "mSqemcEE53l4THBJ",
+              // client_Secret: 'hPvkyDrWToKUG8c3',
+              grant_type: "client_credentials",
+              scope: "data:read",
+            },
+            success: (rawData) => {
+              resolve(rawData);
+            },
+            error: (e) => {
+              resolve(null);
+            },
+          });
+        });
+      }
+
+      function pointerToRaycasterForge(domElement, camera, pointer) {
+        const pointerVector = new THREE.Vector3();
+        const pointerDir = new THREE.Vector3();
+        const ray = new THREE.Raycaster();
+        const rect = domElement.getBoundingClientRect();
+        const x = ((pointer.clientX - rect.left) / rect.width) * 2 - 1;
+        const y = -((pointer.clientY - rect.top) / rect.height) * 2 + 1;
+        if (camera.isPerspective) {
+          pointerVector.set(x, y, 0.5);
+          pointerVector.unproject(camera);
+          ray.set(
+            camera.position,
+            pointerVector.sub(camera.position).normalize()
+          );
+        } else {
+          pointerVector.set(x, y, -1);
+          pointerVector.unproject(camera);
+          pointerDir.set(0, 0, -1);
+          ray.set(
+            pointerVector,
+            pointerDir.transformDirection(camera.matrixWorld)
+          );
+        }
+        return ray;
+      }
+
+      function getAllDbIds(viewer) {
+        const { instanceTree } = viewer.model.getData();
+        const { dbIdToIndex } = instanceTree.nodeAccess;
+        return Object.keys(dbIdToIndex).map((dbId) => {
+          return parseInt(dbId);
+        });
+      }
+
+      function initForge(pid, tid, divId, inCamera = null) {
+        var options = {
+          env: "Local",
+          api: "derivativeV2", // for models uploaded to EMEA change this option to 'derivativeV2_EU'
+          getAccessToken: async function (onTokenReady) {
+            const res = await getAutodeskToken();
+            onTokenReady(res.access_token, res.expires_in);
+          },
+        };
+        Autodesk.Viewing.Initializer(options, function () {
+          var htmlDiv = document.getElementById(divId);
+
+          const config3d = {
+            extensions: ["Autodesk.ADN.Viewing.Extension.Color"],
+          };
+
+          if (
+            inProjectID == "161" ||
+            inProjectID == "165" ||
+            inProjectID == "166"
+          ) {
+            config3d["navToolsConfig"] = {
+              dollyScrollScale: 0.005,
+            };
+          } else if (inProjectID == "235") {
+            config3d["navToolsConfig"] = {
+              dollyScrollScale: 0.001,
+            };
+          }
+
+          let viewer = new Autodesk.Viewing.GuiViewer3D(htmlDiv, config3d);
+          window[divId] = viewer;
+          var startedCode = viewer.start();
+          viewer.canvasId = divId;
+          if (startedCode > 0) {
+            console.error("Failed to create a Viewer: WebGL not supported.");
+            return;
+          }
+          console.log("Initialization complete, loading a model next...");
+          // isCompareMode = true;
+
+          viewer.navigation.setWorldUpVector(
+            new THREE.Vector3().fromArray([0, 0, 1]),
+            false
+          );
+
+          viewer.navigation.setReverseZoomDirection(true);
+
+          localStorage.setItem(
+            "Autodesk.Viewing.Private.GuiViewer3D.SavedSettings.viewCube",
+            false
+          );
+          localStorage.setItem(
+            "Autodesk.Viewing.Private.GuiViewer3D.SavedSettings.groundShadow",
+            false
+          );
+
+          viewer.addEventListener(
+            Autodesk.Viewing.CAMERA_CHANGE_EVENT,
+            (event) => {
+              syncForgeEvent = true;
+            }
+          );
+
+          viewer.container.addEventListener("click", function (ev) {
+            const result = viewer.clientToWorld(ev.clientX, ev.clientY);
+            if (result) {
+              console.log("Click Point", result.point);
+            }
+          });
+
+          viewer.addEventListener(
+            Autodesk.Viewing.SELECTION_CHANGED_EVENT,
+            (event) => {
+              var currSelection = viewer.getSelection();
+              console.log("Selection: ");
+
+              if (currSelection.length && bimProgressData[viewer.canvasId]) {
+                let guid =
+                  bimProgressData[viewer.canvasId]["dbtoguid"][
+                    currSelection[0]
+                  ];
+                let progress =
+                  bimProgressData[viewer.canvasId]["progress"][guid];
+
+                console.log(
+                  "dbid: ",
+                  currSelection[0],
+                  "guid: ",
+                  guid,
+                  "progress: ",
+                  progress
+                );
+
+                // let card_container_id = divId == 'viewer_1' ? 'bim_details_card_container_1' : 'bim_details_card_container_2'
+                // let card_id = divId == 'viewer_1' ? 'bim_details_card_1' : 'bim_details_card_2'
+                // let card_container = document.getElementById(card_container_id);
+                // let card = document.getElementById(card_id);
+                // let card_details = '<table>'
+                // card_details += `<tr> <td>    </td> <td>    </td> </tr>`
+                // card_details += `<tr> <td> GUID </td> <td> ${guid} </td> </tr>`
+                // card_details += `<tr> <td> Progress </td> <td> ${progress} </td> </tr>`
+
+                // card_details += '</table>'
+                // card.innerHTML = card_details;
+                // card_container.style.display = 'block';
+                let bim_element_details = { guid: guid, progress: progress };
+                window.top.postMessage(
+                  {
+                    type: "bim-click",
+                    data: JSON.stringify(bim_element_details),
+                  },
+                  "*"
+                );
+                console.log("Sending ", bim_element_details);
+
+                // const pointer = event.pointers ? event.pointers[0] : event;
+                // const rayCaster = pointerToRaycasterForge(viewer.canvas, viewer.navigation.getCamera(), pointer);
+                // const forgeClickObject = viewer.model.rayIntersect(rayCaster, true, this.getAllDbIds(viewer));
+                // console.log('Click point')
+                // console.log(forgeClickObject)
+
+                // const result = viewer.clientToWorld(event.clientX, event.clientY);
+                // if (result) {
+                // 	console.log(result.point);
+                // }
+              } else {
+                window.top.postMessage(
+                  { type: "bim-click", data: JSON.stringify({}) },
+                  "*"
+                );
+                // closeBimDetailsCard(divId);
+              }
+            }
+          );
+
+          viewer.customtype = "forge";
+          loadBIM(viewer, pid, tid, inCamera);
+        });
+      }
+
+      function closeBimDetailsCard(viewer_id) {
+        let container_id =
+          viewer_id == "viewer_1"
+            ? "bim_details_card_container_1"
+            : "bim_details_card_container_2";
+        let card = document.getElementById(container_id);
+        card.style.display = "none";
+        viewer_id == "viewer_1"
+          ? viewer_1.clearSelection()
+          : viewer_2.clearSelection();
+      }
+
+      async function loadBIM(viewer, pid, tid, inCamera) {
+        // let path = `http://localhost:1234/0.svf`;
+        let path = `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${pid}/forge/model/0.svf`;
+        const modelOptions = { applyScaling: "m" };
+        modelOptions.globalOffset = { x: 0, y: 0, z: 0 };
+        let globalOff = [0, 0, 0];
+        viewer["globalOffset"] = globalOff;
+        viewer["properties_child"] = ["GLOBALID", "NAME"];
+        viewer["properties_head"] = ["IFC"];
+
+        const tm_json_raw = await fetch(
+          `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${pid}/forge/tm_forge.json`
+        );
+        if (tm_json_raw.status == 200) {
+          const tm_json = JSON.parse(await tm_json_raw.text());
+          if (tm_json.tm) {
+            modelOptions.placementTransform = new THREE.Matrix4()
+              .fromArray(tm_json.tm)
+              .transpose();
+            // modelOptions.placementTransform = new THREE.Matrix4().fromArray([0.216,1.022,-0.007,367033.477,-1.022,0.216,-0.001,2053135.281,-0.000,0.007,1.045,-57.5,0.000,0.000,0.000,1.000]).transpose()
+            console.log("BIM TM Loaded");
+          }
+
+          if (tm_json.offset) {
+            globalOff = tm_json.offset;
+            modelOptions.globalOffset = {
+              x: globalOff[0],
+              y: globalOff[1],
+              z: globalOff[2],
+            };
+          }
+
+          if (tm_json.properties_child) {
+            viewer["properties_child"] = tm_json.properties_child;
+          }
+
+          if (tm_json.properties_head) {
+            viewer["properties_head"] = tm_json.properties_head;
+          }
+
+          viewer["globalOffset"] = globalOff;
+          if (inCamera) {
+            let pos = inCamera.position;
+            let tar = inCamera.target;
+            let offset = viewer.globalOffset;
+            inCamera.position = new THREE.Vector3(
+              pos[0] - offset[0],
+              pos[1] - offset[1],
+              pos[2] - offset[2]
+            );
+            inCamera.target = new THREE.Vector3(
+              tar[0] - offset[0],
+              tar[1] - offset[1],
+              tar[2] - offset[2]
+            );
+          }
+        }
+
+        viewer.loadModel(
+          path,
+          modelOptions,
+          async (model) => {
+            if (inCamera) {
+              // Only Happens in 'bim' only mode
+              viewer.navigation.setPosition(inCamera.position);
+              viewer.navigation.setTarget(inCamera.target);
+            } else if (viewer.canvasId == "viewer_2") {
+              if (viewerMode != "3d") {
+                function checkFlag() {
+                  if (!viewer.getExtension("Autodesk.BimWalk")) {
+                    console.log("Loading BimWalk Extension ...");
+                    window.setTimeout(checkFlag, 1000);
+                  } else {
+                    setForgeControls(viewerMode);
+                  }
+                }
+                checkFlag();
+              }
+              viewer_2.navigation.setPosition(
+                viewer_1.scene.view.position.clone()
+              );
+              viewer_2.navigation.setTarget(viewer_1.scene.view.getPivot());
+              viewer_2.navigation.setVerticalFov(viewer_1.fov, false);
+            }
+
+            // Set Pivot Point
+
+            let fuzzy_box = viewer.model.getFuzzyBox();
+            let fuzzy_min = fuzzy_box["min"];
+            let fuzzy_max = fuzzy_box["max"];
+            let fuzzy_center = new THREE.Vector3(
+              (fuzzy_min["x"] + fuzzy_max["x"]) / 2,
+              (fuzzy_min["y"] + fuzzy_max["y"]) / 2,
+              (fuzzy_min["z"] + fuzzy_max["z"]) / 2
+            );
+            viewer.navigation.setPivotPoint(fuzzy_center);
+
+            // Generate GUID - DBID Mapping and progress view/
+
+            loadProgressView(viewer, pid, tid);
+          },
+          (e) => {
+            if (viewer.canvasId == "viewer_2") {
+              document.getElementById("no_bim_2").style.display = "block";
+            } else {
+              document.getElementById("no_bim_1").style.display = "block";
+            }
+          }
+        );
+      }
+
+      function loop(timestamp) {
+        syncViewers();
+        requestAnimationFrame(loop);
+        if (viewer_1.isFloorMap) {
+          updateUserLocation(viewer_1);
+        }
+        if (isCompareMode && compareType == "potree" && viewer_2.isFloorMap) {
+          updateUserLocation(viewer_2);
+        }
+      }
+
+      function setForgeControls(type) {
+        if (type == "orbit") {
+          viewer_2.navigation.setIsLocked(false);
+          if (viewer_2.getExtension("Autodesk.BimWalk")) {
+            viewer_2.getExtension("Autodesk.BimWalk").deactivate();
+          }
+        } else {
+          viewer_2.navigation.setLockSettings({
+            orbit: false,
+            pan: false,
+            zoom: false,
+            roll: false,
+            fov: true,
+          });
+          viewer_2.navigation.setIsLocked(true);
+
+          if (viewer_2.getExtension("Autodesk.BimWalk")) {
+            viewer_2.getExtension("Autodesk.BimWalk").activate();
+          }
+        }
+      }
+
+      function setPitch(viewer, delta) {
+        const startPitch = { p: viewer.scene.view.pitch };
+        const endPitch = { p: startPitch.p + delta };
+        let tween = new TWEEN.Tween(startPitch).to(endPitch, 500);
+        tween.easing(TWEEN.Easing.Quartic.Out);
+        tween.onUpdate(() => {
+          viewer.scene.view.pitch = startPitch.p;
+          syncPotreeEvent = true;
+        });
+        tween.onComplete(() => {
+          viewer.scene.view.pitch = endPitch.p;
+          syncPotreeEvent = true;
+        });
+        tween.start();
+      }
+
+      function setYaw(viewer, delta) {
+        const startYaw = { y: viewer.scene.view.yaw };
+        const endYaw = { y: startYaw.y + delta };
+        let tween = new TWEEN.Tween(startYaw).to(endYaw, 500);
+        tween.easing(TWEEN.Easing.Quartic.Out);
+        tween.onUpdate(() => {
+          viewer.scene.view.yaw = startYaw.y;
+          syncPotreeEvent = true;
+        });
+        tween.onComplete(() => {
+          viewer.scene.view.yaw = endYaw.y;
+          syncPotreeEvent = true;
+        });
+        tween.start();
+      }
+
+      function nextPanoImage(viewer) {
+        let cameraInstance = viewer.scene.cameraP;
+        const camDir = new THREE.Vector3();
+        cameraInstance.getWorldDirection(camDir);
+        camDir.normalize();
+        const camPos = cameraInstance.position;
+        const weightages = { angle: 0.5, distance: 0.5 };
+        let totalSum = 10000;
+        let curSum;
+        let selectedPanoImageId;
+        let cameraViewProjectionMatrix;
+        let imgPos;
+        let dist;
+        let angle;
+        let frustum;
+        const camToImgDir = new THREE.Vector3();
+        const maxDist = 10;
+        const panoImgs = viewer.scene.images360[0].images;
+
+        for (let i = 0; i < panoImgs.length; i++) {
+          if (panoImgs[i].file == viewer.scene.images360[0].focusedImage.file) {
+            continue;
+          }
+          imgPos = new THREE.Vector3().fromArray(panoImgs[i].position);
+          frustum = new THREE.Frustum();
+          cameraViewProjectionMatrix = new THREE.Matrix4();
+          cameraInstance.updateMatrixWorld(); // make sure the camera matrix is updated
+          // cameraInstance.matrixWorldInverse.getInverse(cameraInstance.matrixWorld);
+          cameraInstance.matrixWorldInverse
+            .copy(cameraInstance.matrixWorld)
+            .invert();
+          cameraViewProjectionMatrix.multiplyMatrices(
+            cameraInstance.projectionMatrix,
+            cameraInstance.matrixWorldInverse
+          );
+          frustum.setFromMatrix(cameraViewProjectionMatrix);
+
+          // // if (frustum.containsPoint(imgPos)) {
+          dist = imgPos.distanceTo(camPos);
+          if (dist < maxDist) {
+            camToImgDir.subVectors(imgPos, camPos).normalize();
+            angle = Math.abs(camToImgDir.angleTo(camDir));
+            // tslint:disable-next-line: no-string-literal
+            curSum =
+              weightages["angle"] * angle + weightages["distance"] * dist;
+            if (curSum < totalSum) {
+              selectedPanoImageId = i;
+              totalSum = curSum;
+            }
+          }
+          // // }
+
+          // dist = imgPos.distanceTo(camPos);
+          // if (dist < maxDist) {
+          //     camToImgDir.subVectors(imgPos, camPos).normalize();
+          //     angle = Math.abs(camToImgDir.angleTo(camDir));
+          //     // tslint:disable-next-line: no-string-literal
+          //     // curSum = (weightages['angle'] * angle) + (weightages['distance'] * dist);
+          //     if (angle < totalSum) {
+          //         selectedPanoImageId = i;
+          //         totalSum = angle;
+          //     }
+          // }
+        }
+        if (selectedPanoImageId != undefined) {
+          viewer.scene.images360[0].focus(panoImgs[selectedPanoImageId]);
+        } else {
+          console.warn("No Nearest 360 Images");
+        }
+      }
+
+      function loadFloormap(fpContainerId, fpCanvasId, viewer, pid, tid) {
+        let base_image = new Image();
+        base_image.src = `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${pid}/floormap/floormap.png`;
+        // return new Promise((resolve, reject) => {
+        let fpCanvas = document.getElementById(fpCanvasId);
+        let fpContainer = document.getElementById(fpContainerId);
+        let viewerDiv = document.getElementById(viewer.canvasId);
+        fpContainer.style.display = viewerMode == "3d" ? "none" : "block";
+
+        viewer.floorMap = {};
+        viewer.floorMap.canvas = fpCanvas;
+        viewer.floorMap.container = fpContainer;
+        viewer.floorMap.div = viewerDiv;
+        viewer.floorMap.coverage = mode.includes("compare") ? 0.25 : 0.15;
+
+        base_image.onload = async () => {
+          viewer.floorMap.image = base_image;
+          updateFPSize(viewer.floorMap);
+
+          let fpMarix = new THREE.Matrix4().set(
+            1,
+            0,
+            0,
+            0,
+            0,
+            1,
+            0,
+            0,
+            0,
+            0,
+            1,
+            0,
+            0,
+            0,
+            0,
+            1
+          );
+          let fpOffset = [0, 0, 0];
+          const tm_json_raw = await fetch(
+            `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${pid}/floormap/tm.json`
+          );
+          if (tm_json_raw.status == 200) {
+            const tm_json = JSON.parse(await tm_json_raw.text());
+            if (tm_json.tm) {
+              fpMarix = new THREE.Matrix4().fromArray(tm_json.tm).transpose();
+              console.log("FP TM Loaded");
+            }
+            viewer.floorMap.tm = fpMarix;
+
+            if (tm_json.offset) {
+              fpOffset = tm_json.offset;
+            }
+            viewer.floorMap.offset = fpOffset;
+          }
+
+          const indoor_images_raw = await fetch(
+            `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${pid}/snapshots/${tid}/images.json`
+          );
+          // const indoor_images_raw = await fetch(`http://localhost:1234/indoor_images_15_17_48_66.json`);
+          if (indoor_images_raw.status == 200) {
+            const indoor_images = JSON.parse(await indoor_images_raw.text());
+            console.log("Indoor Images Loaded");
+            loadIcons(
+              indoor_images,
+              fpMarix,
+              base_image,
+              fpCanvas,
+              fpContainer,
+              viewer.floorMap,
+              viewer.canvasId
+            );
+            addUserLocation(
+              "https://dtwin-viewers.s3.ap-south-1.amazonaws.com/icons/fp_user.png",
+              viewer
+            ); // Update Required
+            viewer.floorMap.images = indoor_images;
+          }
+          viewer.isFloorMap = true;
+        };
+        fpContainer.addEventListener("click", (e) => {
+          const clickData = JSON.parse(e.target.getAttribute("data"));
+          if (clickData.id == "viewer_1") {
+            viewer_1.scene.images360[0].images.forEach((pano) => {
+              if (pano.file.split("/").pop() == clickData.name) {
+                viewer_1.scene.images360[0].focus(pano);
+              }
+            });
+          } else if (clickData.id == "viewer_2") {
+            viewer_2.scene.images360[0].images.forEach((pano) => {
+              if (pano.file.split("/").pop() == clickData.name) {
+                viewer_2.scene.images360[0].focus(pano);
+              }
+            });
+          }
+          console.log(clickData.name);
+        });
+      }
+
+      function toggleFloorMap(viewer, cond) {
+        viewer.floorMap.container.style.display = cond ? "block" : "none";
+      }
+
+      function loadIcons(
+        inData,
+        tm,
+        fpImage,
+        fpCanvas,
+        fpContainer,
+        fpStoreData,
+        id
+      ) {
+        let iconSize = 0.01;
+        fpStoreData.icons = [];
+        Object.keys(inData).forEach((imageName) => {
+          const cur_image_pos = inData[imageName].position;
+          const pixelCoords = worldToimage(
+            [cur_image_pos[0], cur_image_pos[1], cur_image_pos[2]],
+            tm
+          );
+          const screenCoords = imageToScreen(pixelCoords, fpImage, fpCanvas);
+          let icon = document.createElement("span");
+          icon.setAttribute("class", "panoIcon");
+          icon.setAttribute(
+            "data",
+            JSON.stringify({ name: imageName, id: id })
+          );
+          icon.style.width = fpCanvas.width * iconSize + "px";
+          icon.style.height = fpCanvas.width * iconSize + "px";
+          icon.style.top = screenCoords[1] - 5 + "px";
+          icon.style.left = screenCoords[0] - 5 + "px";
+          fpContainer.appendChild(icon);
+          fpStoreData.icons.push(icon);
+        });
+      }
+
+      function addUserLocation(path, viewer) {
+        let base_image = new Image();
+        base_image.src = path;
+        return new Promise((resolve, reject) => {
+          base_image.onload = () => {
+            base_image.setAttribute("class", "userIcon");
+            viewer.floorMap.userIcon = base_image;
+            viewer.floorMap.container.appendChild(base_image);
+          };
+        });
+      }
+
+      function calAngle(cx, cy, ex, ey) {
+        var dy = ey - cy;
+        var dx = ex - cx;
+        var theta = Math.atan2(dy, dx); // range (-PI, PI]
+        theta *= 180 / Math.PI; // rads to degs, range (-180, 180]
+        if (theta < 0) theta = 360 + theta; // range [0, 360)
+        return theta - 90 + 180;
+        // return 90 - theta;
+      }
+
+      function updateUserLocation(viewer) {
+        let curView = viewer.scene.view;
+        const position = curView.position.toArray();
+        position[0] += viewer.floorMap.offset[0];
+        position[1] += viewer.floorMap.offset[1];
+        position[2] += viewer.floorMap.offset[2];
+        const pixelCoordsOffset = worldToimage(position, viewer.floorMap.tm);
+        const screenCoords = imageToScreen(
+          pixelCoordsOffset,
+          viewer.floorMap.image,
+          viewer.floorMap.canvas
+        );
+        viewer.floorMap.userIcon.style.left =
+          screenCoords[0] - viewer.floorMap.userIcon.width / 2 + 5 + "px";
+        viewer.floorMap.userIcon.style.top =
+          screenCoords[1] - viewer.floorMap.userIcon.height / 2 + 5 + "px";
+        const camTarget = new THREE.Vector3()
+          .addVectors(curView.position, curView.direction.multiplyScalar(1))
+          .toArray();
+        camTarget[0] += viewer.floorMap.offset[0];
+        camTarget[1] += viewer.floorMap.offset[1];
+        camTarget[2] += viewer.floorMap.offset[2];
+        const camTargetPixel = worldToimage(camTarget, viewer.floorMap.tm);
+        const angle = calAngle(
+          pixelCoordsOffset[0],
+          pixelCoordsOffset[1],
+          camTargetPixel[0],
+          camTargetPixel[1]
+        );
+        viewer.floorMap.userIcon.style.transform = "rotate(" + angle + "deg)";
+      }
+
+      function worldToimage(coords, intm) {
+        const a = new THREE.Vector4(coords[0], coords[1], coords[2], 1);
+        a.applyMatrix4(intm);
+        return [Math.ceil(a.x), Math.ceil(a.y)];
+      }
+
+      function imageToScreen(pix, image, canvas) {
+        const pxx = (pix[0] * canvas.width) / image.naturalWidth;
+        const pyy = (pix[1] * canvas.height) / image.naturalHeight;
+        return [pxx, pyy];
+      }
+
+      function resizeFP(image, fpCanvas, v, coverage) {
+        // let coverage = 0.5;
+        // if (isCompareMode) {
+        // coverage = 0.25;
+        // }
+        // let coverage =
+        if (image.naturalWidth > image.naturalHeight) {
+          fpCanvas.width = v.clientWidth * coverage;
+          fpCanvas.height =
+            fpCanvas.width * (image.naturalHeight / image.naturalWidth);
+        } else {
+          fpCanvas.height = coverage * v.clientWidth;
+          fpCanvas.width =
+            fpCanvas.height * (image.naturalWidth / image.naturalHeight);
+        }
+      }
+
+      function updateFPSize(fpData) {
+        resizeFP(fpData.image, fpData.canvas, fpData.div, fpData.coverage);
+        let context = fpData.canvas.getContext("2d");
+        context.drawImage(
+          fpData.image,
+          0,
+          0,
+          fpData.canvas.width,
+          fpData.canvas.height
+        );
+        if (fpData.icons) {
+          updateFpIcons(fpData);
+        }
+      }
+
+      function updateFpIcons(fpInfo) {
+        let iconSize = 0.02;
+        Object.keys(fpInfo.images).forEach((imageName, index) => {
+          const cur_image_pos = fpInfo.images[imageName].position;
+          const pixelCoords = worldToimage(cur_image_pos, fpInfo.tm);
+          const screenCoords = imageToScreen(
+            pixelCoords,
+            fpInfo.image,
+            fpInfo.canvas
+          );
+          let icon = fpInfo.icons[index];
+          icon.style.width = fpInfo.canvas.width * iconSize + "px";
+          icon.style.height = fpInfo.canvas.width * iconSize + "px";
+          icon.style.top = screenCoords[1] - 5 + "px";
+          icon.style.left = screenCoords[0] - 5 + "px";
+        });
+      }
+
+      function removeFloorMap(viewer) {
+        viewer.floorMap.icons.forEach((icon) => {
+          viewer.floorMap.container.removeChild(icon);
+        });
+        viewer.floorMap.icons = [];
+        viewer.floorMap.container.removeChild(viewer.floorMap.userIcon);
+        viewer.floorMap.userIcon = null;
+        viewer.floorMap.images = null;
+        let context = viewer.floorMap.canvas.getContext("2d");
+        context.clearRect(
+          0,
+          0,
+          viewer.floorMap.canvas.width,
+          viewer.floorMap.canvas.height
+        );
+        viewer.floorMap = {};
+        viewer.isFloorMap = false;
+      }
+
+      async function addMeasure(type, id) {
+        let viewer;
+        if (id == "viewer_1") {
+          viewer = viewer_1;
+          document.getElementById("measure_tool_1").style.display = "block";
+          document
+            .getElementById("measure_top_1")
+            .setAttribute("measure_tool", true);
+        } else {
+          viewer = viewer_2;
+          document.getElementById("measure_tool_2").style.display = "block";
+          document
+            .getElementById("measure_top_2")
+            .setAttribute("measure_tool", true);
+        }
+        if (type == "point") {
+          console.log("Adding Point Measure");
+
+          if (viewerMode == "3d") {
+            let measurement = viewer.measuringTool.startInsertion({
+              showDistances: false,
+              showAngles: false,
+              showCoordinates: true,
+              showArea: false,
+              closed: true,
+              maxMarkers: 1,
+              name: "Point",
+            });
+          } else {
+            let clickHandler = (event) => {
+              const raycaster = new THREE.Raycaster();
+              let pickedObject = undefined;
+
+              const rect = viewer.renderArea.getBoundingClientRect();
+              let pos = {
+                x: event.clientX - rect.left,
+                y: event.clientY - rect.top,
+              };
+
+              // const pos = this.getCanvasRelativePosition(event);
+              let pickPosition = { x: 0, y: 0 };
+              pickPosition.x = (pos.x / viewer.renderArea.clientWidth) * 2 - 1;
+              pickPosition.y =
+                (pos.y / viewer.renderArea.clientHeight) * -2 + 1; // note we flip Y
+
+              raycaster.setFromCamera(pickPosition, viewer.scene.cameraP);
+              let objs =
+                viewerMode == "image"
+                  ? viewer.scene.scene.children
+                  : [viewer.scene.scene.children[0].children[0]];
+              const intersectedObjects = raycaster.intersectObjects(objs, true);
+              if (intersectedObjects.length) {
+                let click_point =
+                  viewerMode == "image"
+                    ? intersectedObjects[2].point
+                    : intersectedObjects[0].point;
+                let measure = new Potree.Measure();
+                measure.showDistances = false;
+                measure.showCoordinates = true;
+                measure.maxMarkers = 1;
+                measure.type = "Point";
+                measure.name = "Point";
+                measure.addMarker(click_point);
+                viewer.scene.addMeasurement(measure);
+              }
+              viewer.renderArea.removeEventListener("click", clickHandler);
+            };
+            setTimeout(() => {
+              viewer.renderArea.addEventListener("click", clickHandler);
+            }, 1);
+          }
+        } else if (type == "distance") {
+          console.log("Adding Distance Measure");
+          let measurement = viewer.measuringTool.startInsertion({
+            showDistances: true,
+            showArea: false,
+            closed: false,
+            name: "Distance",
+          });
+        } else if (type == "area") {
+          console.log("Adding Area Measure");
+          let measurement = viewer.measuringTool.startInsertion({
+            showDistances: true,
+            showArea: true,
+            closed: true,
+            name: "Area",
+          });
+        } else if (type == "height") {
+          console.log("Adding Area Measure");
+          let measurement = viewer.measuringTool.startInsertion({
+            showDistances: false,
+            showHeight: true,
+            showArea: false,
+            closed: false,
+            maxMarkers: 2,
+            name: "Height",
+          });
+        } else if (type == "clear") {
+          viewer.scene.removeAllMeasurements();
+        } else if (type == "save") {
+          let date_time = new Date();
+          let screenShotPath = `${mainProjectID}/structures/${inProjectID}/snapshots/${
+            viewer.tileset
+          }/${date_time.getTime()}.png`;
+          let latest_measure = viewer.scene.measurements.slice(-1)[0];
+          let save_obj = {
+            type: latest_measure.name,
+            points: latest_measure.points.map((point) =>
+              point.position.toArray()
+            ),
+            image: viewer.cur_loaded_image,
+            tileset: viewer.tileset,
+            camera: locate(viewer),
+            screenShot: `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${screenShotPath}`,
+          };
+          console.log("Saving Annotation: ", save_obj);
+          window.top.postMessage(
+            { type: "save-tag", data: JSON.stringify(save_obj) },
+            "*"
+          );
+          takeScreenshot(screenShotPath, viewer);
+        }
+      }
+
+      function toggleVisibility(id, cond) {
+        let div = document.getElementById(id);
+        if (cond) {
+          div.style.display = "block";
+        } else {
+          div.style.display = "none";
+        }
+        updateIconsDisplay();
+      }
+
+      function toggleOrientedImages(id, cond) {
+        if (id == "viewer_1") {
+          viewer_1.scene.orientedImages[0].visible = cond;
+          document.getElementById("cameras_on_1").style.display = cond
+            ? "none"
+            : "inline-block";
+          document.getElementById("cameras_off_1").style.display = cond
+            ? "inline-block"
+            : "none";
+        } else {
+          viewer_2.scene.orientedImages[0].visible = cond;
+          document.getElementById("cameras_on_2").style.display = cond
+            ? "none"
+            : "inline-block";
+          document.getElementById("cameras_off_2").style.display = cond
+            ? "inline-block"
+            : "none";
+        }
+      }
+
+      function actionIconClick(icon) {
+        const inData = JSON.parse(event.target.getAttribute("data"));
+        if (inData) {
+          // parent.postMessage(`${inData.type} button clicked`, "*");
+          if (inData.type == "3d") {
+            if (inData.id == "viewer_1") {
+              viewer_1.controls.elExit.click();
+            } else {
+              viewer_2.controls.elExit.click();
+            }
+          } else if (inData.type == "cameras") {
+            if (inData.id == "viewer_1") {
+              inData.condition == "on"
+                ? toggleOrientedImages("viewer_1", true)
+                : toggleOrientedImages("viewer_1", false);
+            } else {
+              inData.condition == "on"
+                ? toggleOrientedImages("viewer_2", true)
+                : toggleOrientedImages("viewer_2", false);
+            }
+          } else if (inData.type == "compare") {
+            let cam = locate(viewer_1);
+            console.log("3D COMPARE");
+            window.location.href =
+              "https://internal.constructn.ai/tour1?project=" +
+              mainProjectID +
+              "&structure=" +
+              structure_id +
+              "&snapshot1=" +
+              inTilesetID +
+              "&snapshot2=" +
+              inTilesetID2 +
+              "&token=" +
+              token +
+              "&mode=compare_3d" +
+              "&camera=" +
+              JSON.stringify(cam);
+          } else if (inData.type == "bim-compare") {
+            let cam = locate(viewer_1);
+            console.log("BIM COMPARE");
+            window.location.href =
+              "https://internal.constructn.ai/tour1?project=" +
+              mainProjectID +
+              "&structure=" +
+              structure_id +
+              "&snapshot1=" +
+              inTilesetID +
+              "&snapshot2=" +
+              inTilesetID2 +
+              "&mode=compare_bim" +
+              "&camera=" +
+              JSON.stringify(cam) +
+              "&token=" +
+              token;
+          } else if (inData.type == "fp_fullscreen") {
+            if (inData.id == "viewer_1") {
+              if (event.target.id == "fp_fullscreen_1") {
+                document.getElementById("fp_fullscreen_1").style.display =
+                  "none";
+                document.getElementById("fp_minimise_1").style.display =
+                  "block";
+                viewer_1.floorMap.coverage = 0.5;
+                updateFPSize(viewer_1.floorMap);
+              } else {
+                document.getElementById("fp_fullscreen_1").style.display =
+                  "block";
+                document.getElementById("fp_minimise_1").style.display = "none";
+                viewer_1.floorMap.coverage = isCompareMode ? 0.25 : 0.15;
+                updateFPSize(viewer_1.floorMap);
+              }
+            } else if (inData.id == "viewer_2") {
+              if (event.target.id == "fp_fullscreen_2") {
+                document.getElementById("fp_fullscreen_2").style.display =
+                  "none";
+                document.getElementById("fp_minimise_2").style.display =
+                  "block";
+                viewer_2.floorMap.coverage = 0.5;
+                updateFPSize(viewer_2.floorMap);
+              } else {
+                document.getElementById("fp_fullscreen_2").style.display =
+                  "block";
+                document.getElementById("fp_minimise_2").style.display = "none";
+                viewer_2.floorMap.coverage = isCompareMode ? 0.25 : 0.15;
+                updateFPSize(viewer_2.floorMap);
+              }
+            }
+          } else if (inData.type == "compare-close") {
+            let cam = locate(viewer_1);
+            window.location.href =
+              "https://internal.constructn.ai/tour1?project=" +
+              mainProjectID +
+              "&structure=" +
+              structure_id +
+              "&snapshot1=" +
+              inTilesetID +
+              "&snapshot2=" +
+              inTilesetID2 +
+              "&mode=3d" +
+              "&camera=" +
+              JSON.stringify(cam) +
+              "&token=" +
+              token;
+          } else if (inData.type == "bim_legend") {
+            let visible = false;
+            if (event.target.style.opacity == 0.5) {
+              visible = true;
+              event.target.style.opacity = 1;
+            } else {
+              event.target.style.opacity = 0.5;
+            }
+
+            if (inData.id == "viewer_1") {
+              bimFilters(viewer_1, "progress", event.target.id, visible);
+            } else {
+              bimFilters(viewer_2, "progress", event.target.id, visible);
+            }
+          } else if (inData.type == "bim_card_close") {
+            // if (inData.id == 'viewer_1') {
+            // 	closeBimDetailsCard('viewer_1');
+            // } else if (inData.id == 'viewer_2') {
+            // 	closeBimDetailsCard('viewer_2');
+            // }
+          } else if (inData.type == "measure") {
+            if (inData.id == "viewer_1") {
+              if (event.target.getAttribute("measure_tool") == null) {
+                event.target.setAttribute("measure_tool", false);
+              }
+              if (event.target.getAttribute("measure_tool") == "true") {
+                document.getElementById("measure_tool_1").style.display =
+                  "none";
+                event.target.setAttribute("measure_tool", false);
+              } else {
+                document.getElementById("measure_tool_1").style.display =
+                  "block";
+                event.target.setAttribute("measure_tool", true);
+              }
+            } else {
+              if (event.target.getAttribute("measure_tool") == "true") {
+                document.getElementById("measure_tool_2").style.display =
+                  "none";
+                event.target.setAttribute("measure_tool", false);
+              } else {
+                document.getElementById("measure_tool_1").style.display =
+                  "block";
+                event.target.setAttribute("measure_tool", true);
+              }
+            }
+          } else {
+            // event.stopPropagation()
+            addMeasure(inData.type, inData.id);
+          }
+        }
+      }
+
+      function getAllLeafComponents(viewer, callback) {
+        var cbCount = 0; // count pending callbacks
+        var components = []; // store the results
+        var tree; // the instance tree
+
+        function getLeafComponentsRec(parent) {
+          cbCount++;
+          if (tree.getChildCount(parent) != 0) {
+            tree.enumNodeChildren(
+              parent,
+              function (children) {
+                getLeafComponentsRec(children);
+              },
+              false
+            );
+          } else {
+            components.push(parent);
+          }
+          if (--cbCount == 0) callback(components);
+        }
+        viewer.getObjectTree(function (objectTree) {
+          tree = objectTree;
+          var allLeafComponents = getLeafComponentsRec(tree.getRootId());
+        });
+      }
+
+      function getRecursiveGUID(viewer, dbIds) {
+        return new Promise((resolve, reject) => {
+          let guidMapping = {};
+          let guidTodbid = {};
+          let parentMapping = {};
+          let guidToName = {};
+          let dbIdToGuid = {};
+          let property_childs = viewer["properties_child"];
+          let property_head = viewer["properties_head"][0];
+
+          function getGUID(ids) {
+            let dbIdsProcessed = [];
+            viewer.model.getBulkProperties(ids, property_childs, (data) => {
+              data.map((elementDetails) => {
+                let id = elementDetails.properties.filter(
+                  (details) =>
+                    details.displayCategory == property_head &&
+                    details.displayName == property_childs[0]
+                )[0]["displayValue"];
+                let name = elementDetails.properties.filter(
+                  (details) =>
+                    details.displayCategory == property_head &&
+                    details.displayName == property_childs[1]
+                )[0]["displayValue"];
+                if (id) {
+                  guidMapping[elementDetails.dbId] = id;
+                  dbIdsProcessed.push(elementDetails.dbId);
+                  guidToName[id] = name;
+                } else {
+                  console.log("No IFC id for ", elementDetails);
+                }
+              });
+              // console.log('Got ' + dbIdsProcessed.length + ' guids ....')
+              // Get GUID from parent for remaining Ids
+              let remainingDbIds = ids.filter(
+                (lid) => !dbIdsProcessed.includes(lid)
+              );
+              if (remainingDbIds.length) {
+                // console.log('Getting Parents for ' + remainingDbIds.length + ' dbids ....')
+                viewer.model.getBulkProperties(
+                  remainingDbIds,
+                  ["parent"],
+                  (data) => {
+                    let parentsForRemaining = data.map((elementDetails) => {
+                      parentMapping[elementDetails.dbId] =
+                        elementDetails.properties[0].displayValue;
+                      return elementDetails.properties[0].displayValue;
+                    });
+                    getGUID(parentsForRemaining);
+                  }
+                );
+              } else {
+                function getGIdFromParent(id) {
+                  if (guidMapping[parentMapping[id]]) {
+                    return guidMapping[parentMapping[id]];
+                  } else {
+                    return getGIdFromParent(parentMapping[id]);
+                  }
+                }
+
+                dbIds.map((dbid) => {
+                  let gid = guidMapping[dbid];
+                  if (gid) {
+                    if (guidTodbid[gid]) {
+                      guidTodbid[gid].push(dbid);
+                    } else {
+                      guidTodbid[gid] = [dbid];
+                    }
+                    dbIdToGuid[dbid] = gid;
+                  } else {
+                    gid = getGIdFromParent(dbid);
+                    if (guidTodbid[gid]) {
+                      guidTodbid[gid].push(dbid);
+                    } else {
+                      guidTodbid[gid] = [dbid];
+                    }
+                    dbIdToGuid[dbid] = gid;
+                  }
+                });
+
+                // console.log(guidTodbid)
+                console.log(guidToName);
+                bimProgressData[viewer.canvasId] = resolve({
+                  guidMapping: guidTodbid,
+                  dbIdToGuid: dbIdToGuid,
+                });
+              }
+            });
+          }
+
+          console.log("Got " + dbIds.length + " input ids");
+          getGUID(dbIds);
+        });
+      }
+
+      function getguidTodbidMapping(viewer) {
+        return new Promise((resolve, reject) => {
+          getAllLeafComponents(viewer, async (leafIds) => {
+            let guidDetails = await getRecursiveGUID(viewer, leafIds);
+            resolve(guidDetails);
+          });
+        });
+      }
+
+      async function bimProgressView(viewer) {
+        if (
+          inProjectID == "161" ||
+          inProjectID == "165" ||
+          inProjectID == "166"
+        ) {
+          viewer.hideAll();
+          viewer.show(bimProgressData[viewer.canvasId]["green"]);
+          viewer.show(bimProgressData[viewer.canvasId]["blue"]);
+        }
+
+        viewer.setColorMaterial(
+          bimProgressData[viewer.canvasId]["red"],
+          [1, 0, 0, 0.5],
+          "red"
+        );
+        viewer.setColorMaterial(
+          bimProgressData[viewer.canvasId]["green"],
+          [0.5, 0.88, 0.22, 0.5],
+          "green"
+        );
+        viewer.setColorMaterial(
+          bimProgressData[viewer.canvasId]["blue"],
+          [0.95, 0.6, 0.22, 0.5],
+          "blue"
+        );
+
+        // viewer.setColorMaterial(bimProgressData[viewer.canvasId]['red'], 0xFF0000, 'red')
+        // viewer.setColorMaterial(bimProgressData[viewer.canvasId]['green'], 0x71E03A, 'green')
+        // viewer.setColorMaterial(bimProgressData[viewer.canvasId]['blue'], 0xF39B3A, 'blue')
+
+        // viewer.setLightPreset(4)
+        viewer.setQualityLevel(false, false);
+      }
+
+      function bimFilters(viewer, filterType, filterName, visible) {
+        if (filterType == "progress") {
+          if (filterName == "bim_not_started") {
+            visible
+              ? viewer.show(bimProgressData[viewer.canvasId]["red"])
+              : viewer.hide(bimProgressData[viewer.canvasId]["red"]);
+          } else if (filterName == "bim_complete") {
+            visible
+              ? viewer.show(bimProgressData[viewer.canvasId]["green"])
+              : viewer.hide(bimProgressData[viewer.canvasId]["green"]);
+          } else if (filterName == "bim_in_progress") {
+            visible
+              ? viewer.show(bimProgressData[viewer.canvasId]["blue"])
+              : viewer.hide(bimProgressData[viewer.canvasId]["blue"]);
+          }
+        }
+      }
+
+      function bimDefaultView(viewer) {
+        if (
+          inProjectID == "161" ||
+          inProjectID == "165" ||
+          inProjectID == "166"
+        ) {
+          viewer.showAll();
+        }
+        var instanceTree = viewer.model.getData().instanceTree;
+
+        var allDbIdsStr = Object.keys(instanceTree.nodeAccess.dbIdToIndex);
+
+        let dbIds = allDbIdsStr.map(function (id) {
+          return parseInt(id);
+        });
+        viewer.restoreColorMaterial(dbIds);
+        // viewer.setLightPreset(1)
+        viewer.setQualityLevel(true, true);
+      }
+
+      function addProgressButton(viewer) {
+        let group = new Autodesk.Viewing.UI.ControlGroup("BimProgress");
+        viewer.toolbar.addControl(group);
+
+        // Add a new button to the toolbar group
+        let button = new Autodesk.Viewing.UI.Button("progress");
+        // instead of using bootstrap classes e.g.
+        // button.icon.classList.add("fas", "fa-arrows-alt");
+        // you can do this
+        let iconPath =
+          "https://dtwin-viewers.s3.ap-south-1.amazonaws.com/icons/progress.png";
+        button.icon.style = `background-image: url(${iconPath}); background-size: 24px 24px;`;
+
+        button.setToolTip("Progress View");
+
+        button.onClick = function (e) {
+          toggleBimProgressView(viewer);
+
+          // button.icon.classList.add('adsk-viewing-viewer', 'dark-theme', 'adsk-button.active', 'adsk-button')
+          // button.icon.classList.add("fas", "fa-arrows-alt");
+        };
+
+        group.addControl(button);
+
+        toggleBimProgressView(viewer);
+
+        let elems = document.querySelectorAll("[id=bim_not_started]");
+
+        if (viewer.canvasId == "viewer_1") {
+          elems[0].click();
+        } else {
+          elems[1].click();
+        }
+      }
+
+      function toggleBimProgressView(viewer) {
+        console.log("Go to Progress View");
+        bimProgressMode ? bimDefaultView(viewer) : bimProgressView(viewer);
+        if (viewer.canvasId == "viewer_1") {
+          bimProgressMode
+            ? (document.getElementById("bim_legend_1").style.display = "none")
+            : (document.getElementById("bim_legend_1").style.display = "block");
+        } else {
+          bimProgressMode
+            ? (document.getElementById("bim_legend_2").style.display = "none")
+            : (document.getElementById("bim_legend_2").style.display = "block");
+        }
+        bimProgressMode = !bimProgressMode;
+      }
+
+      async function loadProgressView(viewer, projectID, tilesetID) {
+        const progress_data_raw = await fetch(
+          `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${projectID}/snapshots/${tilesetID}/bim_progress.json`
+        );
+        if (progress_data_raw.status == 200) {
+          let guidDetails = await getguidTodbidMapping(viewer);
+          let guidMapping = guidDetails.guidMapping;
+          let guids = Object.keys(guidDetails.guidMapping);
+
+          bimProgressData[viewer.canvasId] = {
+            mapping: guidDetails.guidMapping,
+            dbtoguid: guidDetails.dbIdToGuid,
+            guids: guids,
+          };
+
+          console.log("GUID - DBID mapping done");
+          const progress_data = JSON.parse(await progress_data_raw.text());
+          console.log("BIM progress json loaded");
+
+          bimProgressData[viewer.canvasId]["progress"] = progress_data;
+
+          // let guids = bimProgressData[viewer.canvasId]['guids']
+          // let guidMapping = bimProgressData[viewer.canvasId]['mapping']
+
+          let redArr = guids.filter((key) => progress_data[key] == 0);
+          let greenArr = guids.filter((key) => progress_data[key] == 100);
+          let blueArr = guids.filter(
+            (key) => !redArr.includes(key) && !greenArr.includes(key)
+          );
+          let redDbArr = [];
+          let greenDbArr = [];
+          let blueDbArr = [];
+          if (
+            inProjectID != "161" &&
+            inProjectID != "165" &&
+            inProjectID != "166"
+          ) {
+            redArr.map((id) => (redDbArr = redDbArr.concat(guidMapping[id])));
+          }
+          blueArr.map((id) => (blueDbArr = blueDbArr.concat(guidMapping[id])));
+          greenArr.map(
+            (id) => (greenDbArr = greenDbArr.concat(guidMapping[id]))
+          );
+
+          bimProgressData[viewer.canvasId]["red"] = redDbArr;
+          bimProgressData[viewer.canvasId]["green"] = greenDbArr;
+          bimProgressData[viewer.canvasId]["blue"] = blueDbArr;
+
+          console.log("###############################");
+          console.log(redArr);
+
+          addProgressButton(viewer);
+
+          loadProgressWalk(viewer, projectID, tilesetID);
+        }
+      }
+
+      function select_group_bim(in_guids, viewer, mode, in_field) {
+        let dbArr = [];
+        let guidMapping = bimProgressData[viewer.canvasId]["mapping"];
+        in_guids.map((id) => (dbArr = dbArr.concat(guidMapping[id])));
+
+        if (mode == "material") {
+          bimDefaultView(viewer);
+          viewer.setColorMaterial(dbArr, in_field, "temp_mat");
+        } else if (mode == "visibility") {
+          in_field ? viewer.show(dbArr) : viewer.hide(dbArr);
+        }
+      }
+
+      function remove_group_bim(viewer, mode) {
+        if (mode == "material") {
+          bimDefaultView(viewer);
+        } else if (mode == "visibility") {
+          viewer.showAll();
+        }
+      }
+
+      function locate(viewer) {
+        let camObject;
+        if (viewer.customtype == "potree") {
+          let pos = viewer.scene.view.position.toArray();
+          let tar = viewer.scene.view.getPivot().toArray();
+          let offset = viewer.globalOffset;
+          camObject = {
+            position: [
+              pos[0] + offset[0],
+              pos[1] + offset[1],
+              pos[2] + offset[2],
+            ],
+            target: [
+              tar[0] + offset[0],
+              tar[1] + offset[1],
+              tar[2] + offset[2],
+            ],
+            pitch: viewer.scene.view.pitch,
+            yaw: viewer.scene.view.yaw,
+          };
+        } else if (viewer.customtype == "forge") {
+          const state = viewer.getState({ viewport: true }).viewport;
+          let offset = viewer.globalOffset;
+          camObject = {
+            position: [
+              state.eye[0] + offset[0],
+              state.eye[1] + offset[1],
+              state.eye[2] + offset[2],
+            ],
+            target: [
+              state.target[0] + offset[0],
+              state.target[1] + offset[1],
+              state.target[2] + offset[2],
+            ],
+          };
+        }
+        console.log("Camera : ", camObject);
+        return camObject;
+      }
+
+      function getInverse(org_mat) {
+        var m4 = new THREE.Matrix4();
+        m4.getInverse(org_mat);
+        m4.transpose();
+        return m4.toArray();
+      }
+
+      function flyToContext(info) {
+        let viewer = viewer_1;
+        let offset = viewer.globalOffset;
+        let inCamera_withOffset = {
+          position: new THREE.Vector3().fromArray([
+            info.position[0] - offset[0],
+            info.position[1] - offset[1],
+            info.position[2] - offset[2],
+          ]),
+          target: new THREE.Vector3().fromArray([
+            info.target[0] - offset[0],
+            info.target[1] - offset[1],
+            info.target[2] - offset[2],
+          ]),
+          pitch: info.pitch ? info.pitch : null,
+          yaw: info.yaw ? info.yaw : null,
+        };
+        let inCamera = {
+          position: new THREE.Vector3().fromArray([
+            info.position[0],
+            info.position[1],
+            info.position[2],
+          ]),
+          target: new THREE.Vector3().fromArray([
+            info.target[0],
+            info.target[1],
+            info.target[2],
+          ]),
+        };
+        if (viewerMode == "image") {
+          getNearestImage(viewer, inCamera_withOffset, "image");
+        } else if (viewerMode == "panorama") {
+          getNearestImage(viewer, inCamera_withOffset, "panorama");
+        } else {
+          if (viewer.customtype == "potree") {
+            viewer.scene.view.setView(
+              inCamera_withOffset.position,
+              inCamera_withOffset.target
+            );
+          } else {
+            viewer.navigation.setPosition(inCamera_withOffset.position);
+            viewer.navigation.setTarget(inCamera_withOffset.target);
+          }
+          if (isCompareMode) {
+            isMouseOnV1 = true;
+            syncViewers();
+          }
+        }
+      }
+
+      function flyToImage(viewer, imageName, inCamera) {
+        if (viewerMode == "panorama") {
+          viewer.scene.images360[0].images.forEach((image) => {
+            if (image.file.split("/").pop() == imageName) {
+              viewer.scene.images360[0].focus(image, true, inCamera);
+            }
+          });
+        } else {
+          viewer.scene.orientedImages[0].images.forEach((image) => {
+            if (image.id == imageName) {
+              viewer.scene.orientedImages[0].moveToImage(image);
+            }
+          });
+        }
+      }
+
+      function flyToTagContext(info) {
+        let offset = viewer_1.globalOffset;
+        let inCamera_withOffset = {
+          position: new THREE.Vector3().fromArray([
+            info.camera.position[0] - offset[0],
+            info.camera.position[1] - offset[1],
+            info.camera.position[2] - offset[2],
+          ]),
+          target: new THREE.Vector3().fromArray([
+            info.camera.target[0] - offset[0],
+            info.camera.target[1] - offset[1],
+            info.camera.target[2] - offset[2],
+          ]),
+          pitch: info.camera.pitch ? info.camera.pitch : null,
+          yaw: info.camera.yaw ? info.camera.yaw : null,
+        };
+
+        // if (info.image) {
+        // 	flyToImage_AddTag(viewer_1, info.image, inCamera_withOffset, info)
+        // 	if (isCompareMode) {
+        // 		flyToImage_AddTag(viewer_2, info.image, inCamera_withOffset, info)
+        // 	}
+        // } else {
+        // 	console.log('No Tag Support in 3d')
+        // }
+        if (info.image) {
+          if (viewer_1.tileset == info.tileset) {
+            isMouseOnV1 = true;
+
+            tagToAddOnImageLoad = {
+              info: info,
+              viewer: viewer_1,
+            };
+
+            flyToImage(viewer_1, info.image, inCamera_withOffset);
+            // addTag(info, viewer_1)
+            isMouseOnV1 = true;
+          } else if (isCompareMode && viewer_2.tileset == info.tileset) {
+            isMouseOnV1 = false;
+            // addTag(info, viewer_2)
+            tagToAddOnImageLoad = {
+              info: info,
+              viewer: viewer_2,
+            };
+            flyToImage(viewer_2, info.image, inCamera_withOffset);
+            isMouseOnV1 = false;
+          } else {
+            window.location.href =
+              "https://internal.constructn.ai/tour1?project=" +
+              mainProjectID +
+              "&structure=" +
+              structure_id +
+              "&snapshot1=" +
+              info.tileset +
+              "&snapshot2=" +
+              inTilesetID2 +
+              "&mode=" +
+              mode +
+              "&tag=" +
+              JSON.stringify(info) +
+              "&token=" +
+              token;
+          }
+        } else if (isExterior) {
+          console.log("Load 3d tags");
+          // viewer_1.controls.elExit.click();
+          if (viewer_1.cur_loaded_image) {
+            viewer_1.controls.elExit.click();
+          }
+          // if (isCompareMode) {
+          // 	viewer_2.scene.orientedImages[0].release()
+          // }
+
+          setTimeout(() => {
+            if (viewer_1.tileset == info.tileset) {
+              isMouseOnV1 = true;
+              flyToContext(info.camera);
+              addTag(info, viewer_1);
+              isMouseOnV1 = true;
+            } else if (isCompareMode && viewer_2.tileset == info.tileset) {
+              isMouseOnV1 = false;
+              flyToContext(info.camera);
+              addTag(info, viewer_2);
+              isMouseOnV1 = false;
+            } else {
+              window.location.href =
+                "https://internal.constructn.ai/tour1?project=" +
+                mainProjectID +
+                "&structure=" +
+                structure_id +
+                "&snapshot1=" +
+                info.tileset +
+                "&snapshot2=" +
+                inTilesetID2 +
+                "&mode=" +
+                mode +
+                "&tag=" +
+                JSON.stringify(info) +
+                "&token=" +
+                token;
+            }
+          }, 1000);
+        }
+
+        // if (viewerMode == 'image') {
+        // 	getNearestImage(viewer_1,inCamera_withOffset, 'image')
+        // } else if (viewerMode == 'panorama') {
+        // 	getNearestImage(viewer_1,inCamera_withOffset, 'panorama')
+        // } else {
+        // 	if (viewer_1.customtype == 'potree') {
+        // 		viewer.scene.view.setView(inCamera_withOffset.position, inCamera_withOffset.target)
+        // 	} else {
+        // 		viewer_1.navigation.setPosition(inCamera_withOffset.position);
+        // 		viewer_1.navigation.setTarget(inCamera_withOffset.target);
+        // 	}
+        // 	if (isCompareMode) {
+        // 		isMouseOnV1 = true
+        // 		syncViewers();
+        // 	}
+        // }
+      }
+
+      function addTag(inData, viewer) {
+        if (inData.type == "Point") {
+          let measure = new Potree.Measure();
+          measure.showDistances = false;
+          measure.showCoordinates = true;
+          measure.maxMarkers = 1;
+          measure.addMarker(new THREE.Vector3().fromArray(inData.points[0]));
+          viewer.scene.addMeasurement(measure);
+        } else if (inData.type == "Distance") {
+          let measure = new Potree.Measure();
+          measure.closed = false;
+          inData.points.forEach((point) => {
+            measure.addMarker(new THREE.Vector3().fromArray(point));
+          });
+          viewer.scene.addMeasurement(measure);
+        } else if (inData.type == "Area") {
+          let measure = new Potree.Measure();
+          measure.name = "Area";
+          measure.closed = true;
+          measure.showArea = true;
+          inData.points.forEach((point) => {
+            measure.addMarker(new THREE.Vector3().fromArray(point));
+          });
+          viewer.scene.addMeasurement(measure);
+        } else if (inData.type == "Height") {
+          let measure = new Potree.Measure();
+          measure.name = "Tree Height";
+          measure.closed = false;
+          measure.showDistances = false;
+          measure.showHeight = true;
+          inData.points.forEach((point) => {
+            measure.addMarker(new THREE.Vector3().fromArray(point));
+          });
+          viewer.scene.addMeasurement(measure);
+        }
+      }
+
+      requestAnimationFrame(loop);
+
+      var datesIdMapRight = {};
+      var datesIdMapLeft = {};
+      getDate("#datepickerLeft", datesIdMapLeft, 0, 1);
+      getDate("#datepickerRight", datesIdMapRight, 1, 2);
+
+      function getDate(dateObject, datesMap, defaultValue, snapshotNo) {
+        return new Promise((resolve, reject) => {
+          $.ajax({
+            url: `https://api.dev.constructn.ai/api/v1/snapshots?structure=${structure_id}`,
+            method: "GET",
+            headers: {
+              "Content-Type": "application/json",
+              Authorization: `Bearer ${token}`,
+            },
+            success: (rawData) => {
+              console.log(rawData);
+              if (rawData.result[defaultValue]) {
+                updateDateObject(
+                  rawData,
+                  dateObject,
+                  datesMap,
+                  defaultValue,
+                  snapshotNo
+                );
+              } else if (
+                defaultValue === 1 &&
+                rawData.records[defaultValue - 1]
+              ) {
+                updateDateObject(
+                  rawData,
+                  dateObject,
+                  datesMap,
+                  defaultValue - 1,
+                  snapshotNo
+                );
+              } else {
+                console.log("No records found for Snapshot " + defaultValue);
+              }
+            },
+            error: (e) => {
+              resolve(null);
+            },
+          });
+        });
+      }
+
+      function updateDateObject(
+        rawData,
+        dateObject,
+        datesMap,
+        defaultValue,
+        snapshotNo
+      ) {
+        rawData.result.forEach((record) => {
+          const date = new Date(record["date"]).toISOString().split("T")[0];
+          datesMap[date] = record._id;
+        });
+        console.log(window.location.host);
+        const snapshot = snapshotNo === 1 ? inTilesetID : inTilesetID2;
+        const defaultDate = getValue(datesMap, snapshot)
+          ? getValue(datesMap, snapshot)
+          : new Date(rawData.result[defaultValue]["date"])
+              .toISOString()
+              .split("T")[0];
+        $(dateObject)
+          .datepicker({
+            showOn: "button",
+            buttonImage:
+              "https://dtwin-viewers.s3.ap-south-1.amazonaws.com/icons/calendar.svg",
+            buttonImageOnly: true,
+            buttonText: "Select date",
+            dateFormat: "yy-mm-dd",
+            changeMonth: true,
+            changeYear: true,
+            beforeShowDay: function (date) {
+              var string = jQuery.datepicker.formatDate("yy-mm-dd", date);
+              return [Object.keys(datesMap).indexOf(string) > -1];
+            },
+            onSelect: function (dateText, inst) {
+              let cam = locate(viewer_1);
+              if (snapshotNo === 1) {
+                window.location.href =
+                  "https://internal.constructn.ai/tour1?project=" +
+                  mainProjectID +
+                  "&structure=" +
+                  structure_id +
+                  "&snapshot1=" +
+                  datesMap[dateText] +
+                  "&snapshot2=" +
+                  inTilesetID2 +
+                  "&mode=" +
+                  mode +
+                  "&camera=" +
+                  JSON.stringify(cam) +
+                  "&token=" +
+                  token;
+              } else {
+                window.location.href =
+                  "https://internal.constructn.ai/tour1?project=" +
+                  mainProjectID +
+                  "&structure=" +
+                  structure_id +
+                  "&snapshot1=" +
+                  inTilesetID +
+                  "&snapshot2=" +
+                  datesMap[dateText] +
+                  "&mode=" +
+                  mode +
+                  "&camera=" +
+                  JSON.stringify(cam) +
+                  "&token=" +
+                  token;
+              }
+              // window.location.href = 'https://'+ window.location.host + '/tour?project=' + inProjectID + '&snapshot1=' + datesMap[dateText] + '&snapshot2=' + inTilesetID2 + '&isExterior=0&isFM=1&mode=3d'
+            },
+          })
+          .datepicker("setDate", new Date(defaultDate));
+      }
+
+      function updateIconsDisplay() {
+        Array.from(
+          document.getElementsByClassName("actionButtonsTest")
+        ).forEach((ele) => {
+          $(ele).show();
+          if ($(ele).children(":visible").length === 0) {
+            $(ele).hide();
+          }
+        });
+      }
+
+      function getValue(datesMap, value) {
+        for (let key of Object.keys(datesMap)) {
+          if (datesMap[key] === value) return key;
+        }
+      }
+
+      function takeScreenshot(uploadPath, viewer) {
+        return new Promise((resolve, reject) => {
+          viewer.renderer.domElement.toBlob(function (blob) {
+            // saveAs(blob, "wholePage.png");
+            let file = new File([blob], "task.png");
+            let bodyData = {
+              paths: [uploadPath],
+            };
+
+            $.ajax({
+              url: `https://internal.constructn.ai/api/v1/aws/put-signed-url?bucket=${s3_bucket}`,
+              method: "POST",
+              crossDomain: true,
+              data: JSON.stringify(bodyData),
+              processData: false,
+              contentType: "application/json",
+              success: (reqUrl) => {
+                console.log(reqUrl);
+                $.ajax({
+                  url: reqUrl[0],
+                  method: "PUT",
+                  processData: false,
+                  contentType: false,
+                  data: blob,
+                  success: (reqUrl) => {
+                    console.log("Uploaded Screenshot to S3");
+                    resolve(
+                      `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${uploadPath}`
+                    );
+                  },
+                  error: (e) => {
+                    console.log(e);
+                  },
+                });
+              },
+              error: (e) => {
+                console.log(e);
+              },
+            });
+          });
+          // let div =
+          //     document.getElementById('fpContainer_1');
+
+          // 	return new Promise(resolve => {
+
+          // 		html2canvas(div, {
+          // 			dpi: 200,
+          // 			onrendered: function (canvas) {
+          // 				canvas.toBlob(function(blob) {
+          // 					// saveAs(blob, "wholePage.png");
+          // 					let file = new File([blob], 'task.png')
+        });
+      }
+
+      function fly_progress_walk(in_guid, viewer) {
+        console.log("Progress Walk : Flying to ", in_guid);
+        let db_ids = bimProgressData[viewer.canvasId]["mapping"][in_guid];
+        console.log("DB ID : ", db_ids);
+        viewer.isolate(db_ids);
+        viewer.fitToView(db_ids);
+      }
+
+      function exit_progress_walk(viewer) {
+        viewer.showAll();
+        viewer.fitToView();
+        progress_walk_index = 0;
+      }
+
+      function update_progress_walk(viewer, direction) {
+        if (direction == "next") {
+          progress_walk_index += 1;
+        } else if (direction == "prev") {
+          progress_walk_index -= 1;
+        }
+
+        if (progress_walk_index < 0) {
+          progress_walk_index =
+            bimProgressData[viewer.canvasId]["progress_delta"].length - 1;
+        } else if (
+          progress_walk_index >=
+          bimProgressData[viewer.canvasId]["progress_delta"].length
+        ) {
+          progress_walk_index = 0;
+        }
+
+        fly_progress_walk(
+          bimProgressData[viewer.canvasId]["progress_delta"][
+            progress_walk_index
+          ],
+          viewer
+        );
+      }
+
+      function addProgressWalkButtons(viewer) {
+        // let group = new Autodesk.Viewing.UI.ControlGroup('BimProgress');
+        // viewer.toolbar.addControl(group);
+
+        let group = viewer.toolbar.getControl("BimProgress");
+
+        // Add a new button to the toolbar group
+        let button_walk = new Autodesk.Viewing.UI.Button("progress_walk");
+        let icon_walk =
+          "https://dtwin-viewers.s3.ap-south-1.amazonaws.com/icons/progress_walk.png";
+        button_walk.icon.style = `background-image: url(${icon_walk}); background-size: 24px 24px;`;
+        button_walk.setToolTip("Progress Walk");
+        button_walk.onClick = function (e) {
+          if (progress_walk_mode) {
+            exit_progress_walk(viewer);
+          } else {
+            update_progress_walk(viewer);
+          }
+          progress_walk_mode = !progress_walk_mode;
+        };
+
+        group.addControl(button_walk);
+
+        let button_next = new Autodesk.Viewing.UI.Button("progress_next");
+        let icon_next =
+          "https://dtwin-viewers.s3.ap-south-1.amazonaws.com/icons/progress_walk_next.png";
+        button_next.icon.style = `background-image: url(${icon_next}); background-size: 24px 24px;`;
+        button_next.setToolTip("Next");
+        button_next.onClick = function (e) {
+          if (progress_walk_mode) {
+            update_progress_walk(viewer, "next");
+          }
+        };
+
+        group.addControl(button_next);
+
+        let button_prev = new Autodesk.Viewing.UI.Button("progress_prev");
+        let icon_prev =
+          "https://dtwin-viewers.s3.ap-south-1.amazonaws.com/icons/progress_walk_prev.png";
+        button_prev.icon.style = `background-image: url(${icon_prev}); background-size: 24px 24px;`;
+        button_prev.setToolTip("Prev");
+        button_prev.onClick = function (e) {
+          if (progress_walk_mode) {
+            update_progress_walk(viewer, "prev");
+          }
+        };
+
+        group.addControl(button_prev);
+      }
+
+      async function start_progress_delta_walk(viewer) {
+        // const progress_delta_raw = await fetch(`http://localhost:4200/progress_delta.json`);
+        // if (progress_delta_raw.status == 200) {
+        // const progress_delta = JSON.parse(await progress_delta_raw.text())['delta_elements'];
+        // console.log(progress_delta);
+        // bimProgressData[viewer.canvasId]['progress_delta'] = progress_delta;
+        // fly_progress_walk(bimProgressData[viewer.canvasId]['progress_delta'][progress_walk_index], viewer)
+        // }
+      }
+
+      async function loadProgressWalk(viewer, projectID, tilesetID) {
+        // const progress_delta_raw = await fetch(`http://localhost:4200/progress_delta.json`);
+        const progress_delta_raw = await fetch(
+          `https://${s3_bucket}.s3.ap-south-1.amazonaws.com/${mainProjectID}/structures/${projectID}/snapshots/${tilesetID}/bim_progress_delta.json`
+        );
+        if (progress_delta_raw.status == 200) {
+          const progress_delta = JSON.parse(await progress_delta_raw.text())[
+            "delta_elements"
+          ];
+          bimProgressData[viewer.canvasId]["progress_delta"] = progress_delta;
+          addProgressWalkButtons(viewer);
+          console.log("Progress Walk Loaded");
+        }
+      }
+    </script>
+  </body>
+</html>
diff --git a/examples/lion_las.html b/examples/lion_las.html
index 1907e7d8..fe233423 100644
--- a/examples/lion_las.html
+++ b/examples/lion_las.html
@@ -1,77 +1,376 @@
 <!DOCTYPE html>
 <html lang="en">
-<head>
-	<meta charset="utf-8">
-	<meta name="description" content="">
-	<meta name="author" content="">
-	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
-	<title>Potree Viewer</title>
-
-	<link rel="stylesheet" type="text/css" href="../build/potree/potree.css">
-	<link rel="stylesheet" type="text/css" href="../libs/jquery-ui/jquery-ui.min.css">
-	<link rel="stylesheet" type="text/css" href="../libs/openlayers3/ol.css">
-	<link rel="stylesheet" type="text/css" href="../libs/spectrum/spectrum.css">
-	<link rel="stylesheet" type="text/css" href="../libs/jstree/themes/mixed/style.css">
-</head>
-
-<body>
-	<script src="../libs/jquery/jquery-3.1.1.min.js"></script>
-	<script src="../libs/spectrum/spectrum.js"></script>
-	<script src="../libs/jquery-ui/jquery-ui.min.js"></script>
-	<script src="../libs/other/BinaryHeap.js"></script>
-	<script src="../libs/tween/tween.min.js"></script>
-	<script src="../libs/d3/d3.js"></script>
-	<script src="../libs/proj4/proj4.js"></script>
-	<script src="../libs/openlayers3/ol.js"></script>
-	<script src="../libs/i18next/i18next.js"></script>
-	<script src="../libs/jstree/jstree.js"></script>
-	<script src="../build/potree/potree.js"></script>
-	<script src="../libs/plasio/js/laslaz.js"></script>
-	
-	<!-- INCLUDE ADDITIONAL DEPENDENCIES HERE -->
-	<!-- INCLUDE SETTINGS HERE -->
-	
-	<div class="potree_container" style="position: absolute; width: 100%; height: 100%; left: 0px; top: 0px; ">
-		<div id="potree_render_area" style="background-image: url('../build/potree/resources/images/background.jpg');"></div>
-		<div id="potree_sidebar_container"> </div>
-	</div>
-	
-	<script type="module">
-
-	import * as THREE from "../libs/three.js/build/three.module.js";
-	
-		window.viewer = new Potree.Viewer(document.getElementById("potree_render_area"));
-		
-		viewer.setEDLEnabled(true);
-		viewer.setFOV(60);
-		viewer.setPointBudget(1_000_000);
-		viewer.loadSettingsFromURL();
-		
-		viewer.setDescription("Loading Octree of LAS files");
-		
-		viewer.loadGUI(() => {
-			viewer.setLanguage('en');
-			$("#menu_appearance").next().show();
-			//viewer.toggleSidebar();
-		});
-		
-		// Sigeom
-		Potree.loadPointCloud("../pointclouds/lion_takanawa_las/cloud.js", "lion", function(e){
-			viewer.scene.addPointCloud(e.pointcloud);
-			
-			let material = e.pointcloud.material;
-			material.size = 1;
-			material.pointSizeType = Potree.PointSizeType.ADAPTIVE;
-			
-			e.pointcloud.position.x += 3;
-			e.pointcloud.position.y -= 3;
-			e.pointcloud.position.z += 4;
-			
-			viewer.fitToScreen();
-		});
-		
-	</script>
-	
-	
+  <head>
+    <meta charset="utf-8" />
+    <meta name="description" content="" />
+    <meta name="author" content="" />
+    <meta
+      name="viewport"
+      content="width=device-width, initial-scale=1.0, user-scalable=no"
+    />
+    <title>Potree Viewer</title>
+
+    <link rel="stylesheet" type="text/css" href="../build/potree/potree.css" />
+    <link
+      rel="stylesheet"
+      type="text/css"
+      href="../libs/jquery-ui/jquery-ui.min.css"
+    />
+    <link rel="stylesheet" type="text/css" href="../libs/openlayers3/ol.css" />
+    <link
+      rel="stylesheet"
+      type="text/css"
+      href="../libs/spectrum/spectrum.css"
+    />
+    <link
+      rel="stylesheet"
+      type="text/css"
+      href="../libs/jstree/themes/mixed/style.css"
+    />
+  </head>
+
+  <body>
+    <script src="../libs/jquery/jquery-3.1.1.min.js"></script>
+    <script src="../libs/spectrum/spectrum.js"></script>
+    <script src="../libs/jquery-ui/jquery-ui.min.js"></script>
+    <script src="../libs/other/BinaryHeap.js"></script>
+    <script src="../libs/tween/tween.min.js"></script>
+    <script src="../libs/d3/d3.js"></script>
+    <script src="../libs/proj4/proj4.js"></script>
+    <script src="../libs/openlayers3/ol.js"></script>
+    <script src="../libs/i18next/i18next.js"></script>
+    <script src="../libs/jstree/jstree.js"></script>
+    <script src="../build/potree/potree.js"></script>
+    <script src="../libs/plasio/js/laslaz.js"></script>
+
+    <!-- INCLUDE ADDITIONAL DEPENDENCIES HERE -->
+    <!-- INCLUDE SETTINGS HERE -->
+
+    <div
+      class="potree_container"
+      style="position: absolute; width: 100%; height: 100%; left: 0px; top: 0px"
+    >
+      <div
+        id="potree_render_area"
+        style="
+          background-image: url('../build/potree/resources/images/background.jpg');
+        "
+      ></div>
+      <div id="potree_sidebar_container"></div>
+    </div>
+
+    <script type="module">
+      import * as THREE from "../libs/three.js/build/three.module.js";
+      let i = 0;
+      window.viewer = new Potree.Viewer(
+        document.getElementById("potree_render_area")
+      );
+      //viewer.setDescription(`<button id="myButton">Next Image</button> `);
+      viewer.setEDLEnabled(true);
+      viewer.setFOV(60);
+      viewer.setPointBudget(1_000_000);
+      viewer.loadSettingsFromURL();
+      viewer.loadGUI(() => {
+        viewer.setLanguage("en");
+        $("#menu_appearance").next().show();
+      });
+
+      function isMobileDevice() {
+        // Check for a specific mobile user agent string or screen size
+        // Modify this condition based on your requirements
+        console.log("fduihsdfju8iyshdfgyusifdhkjsdfhyuik", navigator.userAgent);
+        return (
+          /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
+            navigator.userAgent
+          ) || window.innerWidth <= 768
+        );
+      }
+
+      // Execute code only for the mobile version
+      if (isMobileDevice()) {
+        // Your mobile-specific code here
+        console.log("Running on a mobile device");
+        viewer.setDescription(`<button id="myButton">Next Image</button> `);
+        var button = document.getElementById("myButton");
+        button.addEventListener("click", function () {
+          i++;
+          console.log("sdujksdn", i);
+          //   viewer.scene.orientedImages[0].moveToImage(
+          //     viewer.scene.orientedImages[0].images[i]
+          //   );
+          viewer.scene.images360[0].focus(viewer.scene.images360[0].images[i]);
+          //removeAssets(viewer);
+        });
+      } else {
+        // Your web-specific code here
+        console.log("Running on the web", navigator.userAgent);
+      }
+      // Add a click event listener to the button
+      //   button.addEventListener("click", function () {
+      //     i++;
+      //     nextPanoImage(viewer);
+      //     // viewer.scene.orientedImages[0].moveToImage(
+      //     //   viewer.scene.orientedImages[0].images[i]
+      //     // );
+      //     //viewer.scene.images360[0].focus(viewer.scene.images360[0].images[i]);
+      //     //removeAssets(viewer);
+      //   });
+      let viewerMode = "image";
+      // Sigeom
+      Potree.loadPointCloud(
+        "https://constructn-projects-us.s3.us-west-2.amazonaws.com/PRJ957090/structures/STR527991/snapshots/SNP153355/reality/RLT166449/pointcloud/cloud.js",
+        "lion",
+        function (e) {
+          viewer.scene.addPointCloud(e.pointcloud);
+
+          let scene = viewer.scene;
+          let pointcloud = e.pointcloud;
+
+          let material = pointcloud.material;
+          material.size = 0.5;
+          material.minSize = 2.0;
+          material.pointSizeType = Potree.PointSizeType.ADAPTIVE;
+          material.shape = Potree.PointShape.SQUARE;
+          material.activeAttributeName = "rgba";
+          let pcMatrix = new THREE.Matrix4().set(
+            1,
+            0,
+            0,
+            0,
+            0,
+            1,
+            0,
+            0,
+            0,
+            0,
+            1,
+            0,
+            0,
+            0,
+            0,
+            1
+          );
+          let pcOffset = [0, 0, 0];
+          pcMatrix = new THREE.Matrix4()
+            .fromArray([
+              1.000465, 0.003179, 0.000021, -10232.804688, -0.003179, 1.000465,
+              0.000031, -231.655838, -0.000021, -0.000031, 1.00047, -1272.54834,
+              0.0, 0.0, 0.0, 1.0,
+            ])
+            .transpose();
+          pointcloud.applyMatrix(pcMatrix);
+          const assetPosition = pointcloud.position.clone();
+          pointcloud.position.set(
+            assetPosition.x - pcOffset[0],
+            assetPosition.y - pcOffset[1],
+            assetPosition.z - pcOffset[2]
+          );
+          scene.addPointCloud(pointcloud);
+          viewer.fitToScreen();
+          run();
+        }
+      );
+      //   async function run() {
+      //     viewerMode = "image";
+      //     let pcOffset = [0, 0, 0];
+      //     Potree.OrientedImageLoader.load(
+      //       "https://constructn-projects.s3.ap-south-1.amazonaws.com/PRJ156801/structures/STR238477/snapshots/SNP076949/images.json",
+      //       "https://constructn-projects.s3.ap-south-1.amazonaws.com/PRJ156801/structures/STR238477/snapshots/SNP076949/images",
+      //       viewer,
+      //       { tm: new THREE.Matrix4(), offset: pcOffset }
+      //     ).then((images) => {
+      //       console.log("images", images);
+      //       viewer.scene.addOrientedImages(images);
+      //       viewer.scene.orientedImages[0].moveToImage(
+      //         viewer.scene.orientedImages[0].images[i]
+      //       );
+      //     });
+
+      //viewer.mapView.showSources(false);
+      //}
+      //360 images loading
+      async function run() {
+        let pcOffset = [0, 0, 0];
+        Potree.Images360Loader.load(
+          "https://constructn-projects-us.s3.us-west-2.amazonaws.com/PRJ957090/structures/STR527991/snapshots/SNP153355/reality/RLT166449/images.json",
+          "https://constructn-projects-us.s3.us-west-2.amazonaws.com/PRJ957090/structures/STR527991/snapshots/SNP153355/reality/RLT166449/images",
+          viewer,
+          { tm: new THREE.Matrix4(), offset: pcOffset }
+        ).then((images) => {
+          viewer.scene.add360Images(images);
+          viewer.scene.images360[0].focus(viewer.scene.images360[0].images[i]);
+        });
+
+        //viewer.mapView.showSources(false);
+      }
+
+      //   function removeAssets(viewer) {
+      //     viewer.scene.scenePointCloud.remove(viewer.scene.pointclouds[0]);
+      //     viewer.scene.pointclouds = [];
+      //     if (viewer.scene.orientedImages.length) {
+      //       viewer.scene.orientedImages[0].release();
+      //       viewer.scene.orientedImages[0].images.forEach((image) => {
+      //         viewer.scene.scene.children[0].remove(image.mesh);
+      //         viewer.scene.scene.children[0].remove(image.line);
+      //       });
+      //       viewer.scene.scene.remove(viewer.scene.scene.children[0]);
+      //       viewer.scene.removeOrientedImages(viewer.scene.orientedImages[0]);
+      //     }
+
+      //     if (viewer.scene.images360.length) {
+      //       viewer.scene.images360[0].unfocus(false);
+      //       viewer.scene.images360[0].images.forEach((image) => {
+      //         viewer.scene.scene.children[0].remove(image.mesh);
+      //       });
+      //       viewer.scene.scene.children[0].remove(
+      //         viewer.scene.images360[0].sphere
+      //       );
+      //       viewer.scene.scene.remove(viewer.scene.scene.children[0]);
+      //       viewer.scene.remove360Images(viewer.scene.images360[0]);
+      //     }
+      //     if (viewer.isFloorMap) {
+      //       removeFloorMap(viewer);
+      //     }
+      //   }
+      document.addEventListener("keydown", (event) => {
+        if (event.key === "Escape") {
+          // Exit in viewer 2 is already handled in contex maintanance
+          if (viewerMode == "image") {
+            viewer.controls.elExit.click();
+          }
+          // else if (viewerMode == 'panorama') {
+          //     viewer.scene.images360[0].unfocus();
+          // }
+        } else if (event.key === "ArrowUp") {
+          // up arrow
+          if (viewerMode == "image") {
+            viewer.controls.elUp.click();
+            // if (isCompareMode && compareType == "potree") {
+            //   viewer_2.controls.elUp.click();
+            // }
+          } else if (viewerMode == "panorama") {
+            if (event.ctrlKey) {
+              setPitch(viewer, 0.5);
+              //   if (isCompareMode && compareType == "potree") {
+              //     setPitch(viewer_2, 0.5);
+              //   }
+            } else {
+              nextPanoImage(viewer);
+            }
+          }
+        } else if (event.key === "ArrowDown") {
+          // down arrow
+          if (viewerMode == "image") {
+            viewer.controls.elDown.click();
+            if (isCompareMode && compareType == "potree") {
+              viewer_2.controls.elDown.click();
+            }
+          } else if (viewerMode == "panorama") {
+            if (event.ctrlKey) {
+              setPitch(viewer, -0.5);
+              if (isCompareMode && compareType == "potree") {
+                setPitch(viewer_2, -0.5);
+              }
+            }
+          }
+        } else if (event.key === "ArrowLeft") {
+          // left arrow
+          if (viewerMode == "image") {
+            viewer.controls.elLeft.click();
+            if (isCompareMode && compareType == "potree") {
+              viewer_2.controls.elLeft.click();
+            }
+          } else if (viewerMode == "panorama") {
+            setYaw(viewer, 0.5);
+            if (isCompareMode && compareType == "potree") {
+              setYaw(viewer_2, 0.5);
+            }
+          }
+        } else if (event.key === "ArrowRight") {
+          // right arrow
+          if (viewerMode == "image") {
+            viewer.controls.elRight.click();
+            if (isCompareMode && compareType == "potree") {
+              viewer_2.controls.elRight.click();
+            }
+          } else if (viewerMode == "panorama") {
+            setYaw(viewer, -0.5);
+            if (isCompareMode && compareType == "potree") {
+              setYaw(viewer_2, -0.5);
+            }
+          }
+        }
+      });
+      //   function nextPanoImage(viewer) {
+      //     let cameraInstance = viewer.scene.cameraP;
+      //     const camDir = new THREE.Vector3();
+      //     cameraInstance.getWorldDirection(camDir);
+      //     camDir.normalize();
+      //     const camPos = cameraInstance.position;
+      //     const weightages = { angle: 0.5, distance: 0.5 };
+      //     let totalSum = 10000;
+      //     let curSum;
+      //     let selectedPanoImageId;
+      //     let cameraViewProjectionMatrix;
+      //     let imgPos;
+      //     let dist;
+      //     let angle;
+      //     let frustum;
+      //     const camToImgDir = new THREE.Vector3();
+      //     const maxDist = 10;
+      //     const panoImgs = viewer.scene.images360[0].images;
+
+      //     for (let i = 0; i < panoImgs.length; i++) {
+      //       if (panoImgs[i].file == viewer.scene.images360[0].focusedImage.file) {
+      //         continue;
+      //       }
+      //       imgPos = new THREE.Vector3().fromArray(panoImgs[i].position);
+      //       frustum = new THREE.Frustum();
+      //       cameraViewProjectionMatrix = new THREE.Matrix4();
+      //       cameraInstance.updateMatrixWorld(); // make sure the camera matrix is updated
+      //       // cameraInstance.matrixWorldInverse.getInverse(cameraInstance.matrixWorld);
+      //       cameraInstance.matrixWorldInverse
+      //         .copy(cameraInstance.matrixWorld)
+      //         .invert();
+      //       cameraViewProjectionMatrix.multiplyMatrices(
+      //         cameraInstance.projectionMatrix,
+      //         cameraInstance.matrixWorldInverse
+      //       );
+      //       frustum.setFromMatrix(cameraViewProjectionMatrix);
+
+      //       // // if (frustum.containsPoint(imgPos)) {
+      //       dist = imgPos.distanceTo(camPos);
+      //       if (dist < maxDist) {
+      //         camToImgDir.subVectors(imgPos, camPos).normalize();
+      //         angle = Math.abs(camToImgDir.angleTo(camDir));
+      //         // tslint:disable-next-line: no-string-literal
+      //         curSum =
+      //           weightages["angle"] * angle + weightages["distance"] * dist;
+      //         if (curSum < totalSum) {
+      //           selectedPanoImageId = i;
+      //           totalSum = curSum;
+      //         }
+      //       }
+      //       // // }
+
+      //       // dist = imgPos.distanceTo(camPos);
+      //       // if (dist < maxDist) {
+      //       //     camToImgDir.subVectors(imgPos, camPos).normalize();
+      //       //     angle = Math.abs(camToImgDir.angleTo(camDir));
+      //       //     // tslint:disable-next-line: no-string-literal
+      //       //     // curSum = (weightages['angle'] * angle) + (weightages['distance'] * dist);
+      //       //     if (angle < totalSum) {
+      //       //         selectedPanoImageId = i;
+      //       //         totalSum = angle;
+      //       //     }
+      //       // }
+      //     }
+      //     if (selectedPanoImageId != undefined) {
+      //       viewer.scene.images360[0].focus(panoImgs[selectedPanoImageId]);
+      //     } else {
+      //       console.warn("No Nearest 360 Images");
+      //     }
+      //   }
+    </script>
   </body>
 </html>
diff --git a/src/modules/Images360/Images360.js b/src/modules/Images360/Images360.js
index 02026fd0..669de80b 100644
--- a/src/modules/Images360/Images360.js
+++ b/src/modules/Images360/Images360.js
@@ -1,344 +1,305 @@
-
 import * as THREE from "../../../libs/three.js/build/three.module.js";
 import { EventDispatcher } from "../../EventDispatcher.js";
-import {TextSprite} from "../../TextSprite.js";
-
-let sg = new THREE.SphereGeometry(1, 8, 8);
-let sgHigh = new THREE.SphereGeometry(1, 128, 128);
-
-let sm = new THREE.MeshBasicMaterial({side: THREE.BackSide});
-let smHovered = new THREE.MeshBasicMaterial({side: THREE.BackSide, color: 0xff0000});
-
-let raycaster = new THREE.Raycaster();
-let currentlyHovered = null;
-
-let previousView = {
-	controls: null,
-	position: null,
-	target: null,
-};
-
-class Image360{
-
-	constructor(file, time, longitude, latitude, altitude, course, pitch, roll){
-		this.file = file;
-		this.time = time;
-		this.longitude = longitude;
-		this.latitude = latitude;
-		this.altitude = altitude;
-		this.course = course;
-		this.pitch = pitch;
-		this.roll = roll;
-		this.mesh = null;
-	}
-};
-
-export class Images360 extends EventDispatcher{
-
-	constructor(viewer){
-		super();
-
-		this.viewer = viewer;
-
-		this.selectingEnabled = true;
-
-		this.images = [];
-		this.node = new THREE.Object3D();
-
-		this.sphere = new THREE.Mesh(sgHigh, sm);
-		this.sphere.visible = false;
-		this.sphere.scale.set(1000, 1000, 1000);
-		this.node.add(this.sphere);
-		this._visible = true;
-		// this.node.add(label);
-
-		this.focusedImage = null;
-
-		let elUnfocus = document.createElement("input");
-		elUnfocus.type = "button";
-		elUnfocus.value = "unfocus";
-		elUnfocus.style.position = "absolute";
-		elUnfocus.style.right = "10px";
-		elUnfocus.style.bottom = "10px";
-		elUnfocus.style.zIndex = "10000";
-		elUnfocus.style.fontSize = "2em";
-		elUnfocus.addEventListener("click", () => this.unfocus());
-		this.elUnfocus = elUnfocus;
-
-		this.domRoot = viewer.renderer.domElement.parentElement;
-		this.domRoot.appendChild(elUnfocus);
-		this.elUnfocus.style.display = "none";
-
-		viewer.addEventListener("update", () => {
-			this.update(viewer);
-		});
-		viewer.inputHandler.addInputListener(this);
-
-		this.addEventListener("mousedown", () => {
-			if(currentlyHovered && currentlyHovered.image360){
-				this.focus(currentlyHovered.image360);
-			}
-		});
-		
-	};
-
-	set visible(visible){
-		if(this._visible === visible){
-			return;
-		}
-
-
-		for(const image of this.images){
-			image.mesh.visible = visible && (this.focusedImage == null);
-		}
-
-		this.sphere.visible = visible && (this.focusedImage != null);
-		this._visible = visible;
-		this.dispatchEvent({
-			type: "visibility_changed",
-			images: this,
-		});
-	}
-
-	get visible(){
-		return this._visible;
-	}
-
-	focus(image360){
-		if(this.focusedImage !== null){
-			this.unfocus();
-		}
-
-		previousView = {
-			controls: this.viewer.controls,
-			position: this.viewer.scene.view.position.clone(),
-			target: viewer.scene.view.getPivot(),
-		};
-
-		this.viewer.setControls(this.viewer.orbitControls);
-		this.viewer.orbitControls.doubleClockZoomEnabled = false;
-
-		for(let image of this.images){
-			image.mesh.visible = false;
-		}
-
-		this.selectingEnabled = false;
-
-		this.sphere.visible = false;
-
-		this.load(image360).then( () => {
-			this.sphere.visible = true;
-			this.sphere.material.map = image360.texture;
-			this.sphere.material.needsUpdate = true;
-		});
-
-		{ // orientation
-			let {course, pitch, roll} = image360;
-			this.sphere.rotation.set(
-				THREE.Math.degToRad(+roll + 90),
-				THREE.Math.degToRad(-pitch),
-				THREE.Math.degToRad(-course + 90),
-				"ZYX"
-			);
-		}
-
-		this.sphere.position.set(...image360.position);
-
-		let target = new THREE.Vector3(...image360.position);
-		let dir = target.clone().sub(viewer.scene.view.position).normalize();
-		let move = dir.multiplyScalar(0.000001);
-		let newCamPos = target.clone().sub(move);
-
-		viewer.scene.view.setView(
-			newCamPos, 
-			target,
-			500
-		);
-
-		this.focusedImage = image360;
-
-		this.elUnfocus.style.display = "";
-	}
-
-	unfocus(){
-		this.selectingEnabled = true;
-
-		for(let image of this.images){
-			image.mesh.visible = true;
-		}
-
-		let image = this.focusedImage;
-
-		if(image === null){
-			return;
-		}
-
-
-		this.sphere.material.map = null;
-		this.sphere.material.needsUpdate = true;
-		this.sphere.visible = false;
-
-		let pos = viewer.scene.view.position;
-		let target = viewer.scene.view.getPivot();
-		let dir = target.clone().sub(pos).normalize();
-		let move = dir.multiplyScalar(10);
-		let newCamPos = target.clone().sub(move);
-
-		viewer.orbitControls.doubleClockZoomEnabled = true;
-		viewer.setControls(previousView.controls);
-
-		viewer.scene.view.setView(
-			previousView.position, 
-			previousView.target,
-			500
-		);
-
-
-		this.focusedImage = null;
-
-		this.elUnfocus.style.display = "none";
-	}
-
-	load(image360){
-
-		return new Promise(resolve => {
-			let texture = new THREE.TextureLoader().load(image360.file, resolve);
-			texture.wrapS = THREE.RepeatWrapping;
-			texture.repeat.x = -1;
-
-			image360.texture = texture;
-		});
-
-	}
-
-	handleHovering(){
-		let mouse = viewer.inputHandler.mouse;
-		let camera = viewer.scene.getActiveCamera();
-		let domElement = viewer.renderer.domElement;
-
-		let ray = Potree.Utils.mouseToRay(mouse, camera, domElement.clientWidth, domElement.clientHeight);
-
-		// let tStart = performance.now();
-		raycaster.ray.copy(ray);
-		let intersections = raycaster.intersectObjects(this.node.children);
-
-		if(intersections.length === 0){
-			// label.visible = false;
-
-			return;
-		}
-
-		let intersection = intersections[0];
-		currentlyHovered = intersection.object;
-		currentlyHovered.material = smHovered;
-
-		//label.visible = true;
-		//label.setText(currentlyHovered.image360.file);
-		//currentlyHovered.getWorldPosition(label.position);
-	}
-
-	update(){
-
-		let {viewer} = this;
-
-		if(currentlyHovered){
-			currentlyHovered.material = sm;
-			currentlyHovered = null;
-		}
-
-		if(this.selectingEnabled){
-			this.handleHovering();
-		}
-
-	}
-
-};
-
-
-export class Images360Loader{
-
-	static async load(url, viewer, params = {}){
-
-		if(!params.transform){
-			params.transform = {
-				forward: a => a,
-			};
-		}
-		
-		let response = await fetch(`${url}/coordinates.txt`);
-		let text = await response.text();
-
-		let lines = text.split(/\r?\n/);
-		let coordinateLines = lines.slice(1);
-
-		let images360 = new Images360(viewer);
-
-		for(let line of coordinateLines){
-
-			if(line.trim().length === 0){
-				continue;
-			}
-
-			let tokens = line.split(/\t/);
-
-			let [filename, time, long, lat, alt, course, pitch, roll] = tokens;
-			time = parseFloat(time);
-			long = parseFloat(long);
-			lat = parseFloat(lat);
-			alt = parseFloat(alt);
-			course = parseFloat(course);
-			pitch = parseFloat(pitch);
-			roll = parseFloat(roll);
-
-			filename = filename.replace(/"/g, "");
-			let file = `${url}/${filename}`;
-
-			let image360 = new Image360(file, time, long, lat, alt, course, pitch, roll);
-
-			let xy = params.transform.forward([long, lat]);
-			let position = [...xy, alt];
-			image360.position = position;
-
-			images360.images.push(image360);
-		}
-
-		Images360Loader.createSceneNodes(images360, params.transform);
-
-		return images360;
-
-	}
-
-	static createSceneNodes(images360, transform){
-
-		for(let image360 of images360.images){
-			let {longitude, latitude, altitude} = image360;
-			let xy = transform.forward([longitude, latitude]);
-
-			let mesh = new THREE.Mesh(sg, sm);
-			mesh.position.set(...xy, altitude);
-			mesh.scale.set(1, 1, 1);
-			mesh.material.transparent = true;
-			mesh.material.opacity = 0.75;
-			mesh.image360 = image360;
-
-			{ // orientation
-				var {course, pitch, roll} = image360;
-				mesh.rotation.set(
-					THREE.Math.degToRad(+roll + 90),
-					THREE.Math.degToRad(-pitch),
-					THREE.Math.degToRad(-course + 90),
-					"ZYX"
-				);
-			}
-
-			images360.node.add(mesh);
-
-			image360.mesh = mesh;
-		}
-	}
-
-	
-
-};
-
 
+class Image360 {
+  constructor(
+    file,
+    thumbnail,
+    longitude,
+    latitude,
+    altitude,
+    course,
+    pitch,
+    roll
+  ) {
+    this.file = file;
+    this.thumbnail = thumbnail;
+    this.longitude = longitude;
+    this.latitude = latitude;
+    this.altitude = altitude;
+    this.course = course;
+    this.pitch = pitch;
+    this.roll = roll;
+  }
+}
+
+export class Images360 extends EventDispatcher {
+  constructor(viewer) {
+    super();
+
+    this.viewer = viewer;
+
+    this.selectingEnabled = true;
+
+    this.images = [];
+    this.node = new THREE.Object3D();
+
+    this.sphere = new THREE.Mesh(
+      new THREE.SphereGeometry(1, 128, 128),
+      new THREE.MeshBasicMaterial({ side: THREE.BackSide })
+    );
+    this.sphere.visible = false;
+    this.sphere.scale.set(-1000, 1000, 1000);
+
+    this.focus = this.focus.bind(this);
+    this.unfocus = this.unfocus.bind(this);
+    this.node.add(this.sphere);
+    this._visible = true;
+
+    this.focusedImage = null;
+    this.currentlyHovered = null;
+    this.previousView = {
+      controls: null,
+      position: null,
+      target: null,
+    };
+    this.raycaster = new THREE.Raycaster();
+    this.hoverMaterial = new THREE.MeshBasicMaterial({
+      side: THREE.BackSide,
+      color: 0xff0000,
+    });
+    this.sm = new THREE.MeshBasicMaterial({ side: THREE.BackSide });
+
+    // viewer.addEventListener("update", () => {
+    //   this.update(viewer);
+    // });
+    viewer.inputHandler.addInputListener(this);
+
+    this.addEventListener("mousedown", () => {
+      if (this.currentlyHovered && this.currentlyHovered.image360) {
+        this.focus(this.currentlyHovered.image360);
+      }
+    });
+  }
+
+  set visible(visible) {
+    if (this._visible === visible) {
+      return;
+    }
+    this.sphere.visible = visible && this.focusedImage != null;
+    this._visible = visible;
+    this.dispatchEvent({
+      type: "visibility_changed",
+      images: this,
+    });
+  }
+
+  get visible() {
+    return this._visible;
+  }
+
+  focus(image360, sendEvent = true, inTarget = null) {
+    if (this.focusedImage !== null) {
+      this.unfocus();
+    }
+    this.viewer.setEDLOpacity(0);
+    if (sendEvent) {
+      const event = new CustomEvent("panoLoad", {
+        detail: {
+          viewer: this.viewer.canvasId,
+          image: image360,
+        },
+      });
+      document.dispatchEvent(event);
+    }
+
+    this.previousView = {
+      controls: this.viewer.controls,
+      position: this.viewer.scene.view.position.clone(),
+      target: this.viewer.scene.view.getPivot(),
+    };
+
+    this.viewer.setControls(this.viewer.orbitControls);
+    this.viewer.orbitControls.doubleClockZoomEnabled = false;
+
+    this.selectingEnabled = false;
+
+    this.sphere.visible = false;
+
+    this.load(image360).then(() => {
+      this.sphere.visible = true;
+      this.sphere.material.map = image360.texture;
+      this.sphere.material.needsUpdate = true;
+    });
+
+    // orientation
+    let { course, pitch, roll } = image360;
+
+    this.sphere.rotation.set(
+      THREE.Math.degToRad(course),
+      THREE.Math.degToRad(pitch),
+      THREE.Math.degToRad(roll),
+      "XYZ"
+    );
+
+    this.sphere.position.set(...image360.position);
+
+    let target = new THREE.Vector3(...image360.position);
+    let dir = target.clone().sub(this.viewer.scene.view.position).normalize();
+    let move = dir.multiplyScalar(0.000001);
+    let newCamPos = target.clone().sub(move);
+
+    this.viewer.scene.view.setView(newCamPos, target, 500, () => {
+      if (inTarget && inTarget.pitch) {
+        this.viewer.scene.view.pitch = inTarget.pitch;
+        this.viewer.scene.view.yaw = inTarget.yaw;
+      }
+    });
+
+    this.focusedImage = image360;
+  }
+
+  unfocus(sendEvent = true) {
+    this.selectingEnabled = true;
+    this.viewer.setEDLOpacity(1);
+
+    let image = this.focusedImage;
+
+    if (image === null) {
+      return;
+    }
+    delete image.texture;
+    this.sphere.material.map = null;
+    this.sphere.material.needsUpdate = true;
+    this.sphere.visible = false;
+    this.viewer.orbitControls.doubleClockZoomEnabled = true;
+    this.viewer.setControls(this.previousView.controls);
+
+    this.focusedImage = null;
+
+    if (sendEvent) {
+      const event = new CustomEvent("panoUnload", {
+        detail: {
+          viewer: this.viewer.canvasId,
+        },
+      });
+      document.dispatchEvent(event);
+    }
+  }
+
+  load(image360) {
+    let resolved = false;
+    return new Promise((resolve) => {
+      if (image360.texture) {
+        resolve(null);
+      } else {
+        new THREE.TextureLoader().load(
+          image360.thumbnail,
+          (texture) => {
+            image360.texture = texture;
+            resolved = true;
+            resolve(null);
+            loadOrgImage.bind(this)();
+          },
+          undefined,
+          (err) => {
+            loadOrgImage.bind(this)();
+          }
+        );
+        let loadOrgImage = function () {
+          new THREE.TextureLoader().load(image360.file, (texture) => {
+            image360.texture = texture;
+            this.sphere.visible = true;
+            this.sphere.material.map = image360.texture;
+            this.sphere.material.needsUpdate = true;
+            if (!resolved) {
+              resolve(null);
+            }
+            // }
+          });
+        };
+      }
+    });
+  }
+
+  //   handleHovering() {
+  //     let mouse = this.viewer.inputHandler.mouse;
+  //     let camera = this.viewer.scene.getActiveCamera();
+  //     let domElement = this.viewer.renderer.domElement;
+
+  //     let ray = Potree.Utils.mouseToRay(
+  //       mouse,
+  //       camera,
+  //       domElement.clientWidth,
+  //       domElement.clientHeight
+  //     );
+
+  //     this.raycaster.ray.copy(ray);
+  //     let intersections = this.raycaster.intersectObjects(this.node.children);
+
+  //     if (intersections.length === 0) {
+  //       return;
+  //     }
+
+  //     let intersection = intersections[0];
+  //     this.currentlyHovered = intersection.object;
+  //     this.currentlyHovered.material = this.hoverMaterial;
+  //   }
+
+  //   update() {
+  //     let { viewer } = this;
+
+  //     if (this.currentlyHovered) {
+  //       this.currentlyHovered.material = this.sm;
+  //       this.currentlyHovered = null;
+  //     }
+
+  //     if (this.selectingEnabled) {
+  //       // this.handleHovering();
+  //     }
+  //   }
+}
+
+export class Images360Loader {
+  static async load(url, imgsUrl, viewer, tm_data) {
+    let tmatrix, toffset;
+
+    tmatrix = tm_data.tm;
+    toffset = tm_data.offset;
+
+    let response = await fetch(url);
+    let text = await response.text();
+    let imgData = JSON.parse(text);
+
+    let images360 = new Images360(viewer);
+    Object.keys(imgData).forEach((imgName) => {
+      let raw_position = imgData[imgName].position;
+      let rotation = imgData[imgName].rotation;
+
+      const pos = new THREE.Vector4(
+        raw_position[0],
+        raw_position[1],
+        raw_position[2],
+        1
+      );
+      pos.applyMatrix4(tmatrix);
+
+      const long = parseFloat(pos.x - toffset[0]);
+      const lat = parseFloat(pos.y - toffset[1]);
+      const alt = parseFloat(pos.z - toffset[2]);
+      const course = parseFloat(rotation[0]);
+      const pitch = parseFloat(rotation[1]);
+      const roll = parseFloat(rotation[2]);
+
+      let file = `${imgsUrl}/${imgName}`;
+      let thumbnail = `${imgsUrl}/thumbnails/${imgName}`;
+      let image360 = new Image360(
+        file,
+        thumbnail,
+        long,
+        lat,
+        alt,
+        course,
+        pitch,
+        roll
+      );
+
+      let position = [long, lat, alt];
+      image360.position = position;
+
+      images360.images.push(image360);
+    });
+
+    return images360;
+  }
+}
diff --git a/src/modules/OrientedImages/OrientedImageControls.js b/src/modules/OrientedImages/OrientedImageControls.js
index 26ac322d..5b43c6ca 100644
--- a/src/modules/OrientedImages/OrientedImageControls.js
+++ b/src/modules/OrientedImages/OrientedImageControls.js
@@ -29,15 +29,24 @@ export class OrientedImageControls extends EventDispatcher{
 
 		this.shear = [0, 0];
 
+		this.changeEvent = new CustomEvent("camerachange");
+
+
 		// const style = ``;
-		this.elUp =    $(`<input type="button" value="🡅" style="position: absolute; top: 10px; left: calc(50%); z-index: 1000" />`);
-		this.elRight = $(`<input type="button" value="🡆" style="position: absolute; top: calc(50%); right: 10px; z-index: 1000" />`);
-		this.elDown =  $(`<input type="button" value="🡇" style="position: absolute; bottom: 10px; left: calc(50%); z-index: 1000" />`);
-		this.elLeft =  $(`<input type="button" value="🡄" style="position: absolute; top: calc(50%); left: 10px; z-index: 1000" />`);
-		this.elExit = $(`<input type="button" value="Back to 3D view" style="position: absolute; bottom: 10px; right: 10px; z-index: 1000" />`);
+		this.elUp =    $(`<input type="button" value="🡅" style="position: absolute; top: 10px; left: calc(50%); z-index: 1000; display: none" />`);
+		this.elRight = $(`<input type="button" value="🡆" style="position: absolute; top: calc(50%); right: 10px; z-index: 1000; display: none" />`);
+		this.elDown =  $(`<input type="button" value="🡇" style="position: absolute; bottom: 10px; left: calc(50%); z-index: 1000; display: none" />`);
+		this.elLeft =  $(`<input type="button" value="🡄" style="position: absolute; top: calc(50%); left: 10px; z-index: 1000; display: none" />`);
+		this.elExit = $(`<input type="button" value="Back to 3D view" style="position: absolute; bottom: 10px; right: 10px; z-index: 1000; display: none" />`);
 
 		this.elExit.click( () => {
 			this.release();
+			const event = new CustomEvent("imageUnload", {
+				detail: {
+					viewer: this.viewer.canvasId
+				}
+			});
+			document.dispatchEvent(event);
 		});
 
 		this.elUp.click(() => {
@@ -68,7 +77,13 @@ export class OrientedImageControls extends EventDispatcher{
 		this.sceneControls = new THREE.Scene();
 
 		let scroll = (e) => {
-			this.fovDelta += -e.delta * 1.0;
+			// this.fovDelta += -e.delta * 1.0;
+			this.shear = [0, 0];
+			let fov = this.viewer.getFOV() + (-e.delta * 5);
+			if (fov > 10 && fov < 100) {
+				this.viewer.setFOV(fov);
+				document.dispatchEvent(this.changeEvent)
+			}
 		};
 
 		this.addEventListener('mousewheel', scroll);
@@ -103,9 +118,13 @@ export class OrientedImageControls extends EventDispatcher{
 		elRoot.append(this.elDown);
 		elRoot.append(this.elLeft);
 		elRoot.append(this.elExit);
+
+		this.viewer.setFOV(30);
+
 	}
 
 	release(){
+
 		this.image = null;
 
 		this.viewer.scene.overrideCamera = null;
@@ -117,7 +136,13 @@ export class OrientedImageControls extends EventDispatcher{
 		this.elExit.detach();
 
 		this.viewer.setFOV(this.originalFOV);
+		this.viewer.scene.cameraP.fov = this.originalFOV;
 		this.viewer.setControls(this.originalControls);
+		this.viewer.controls.enabled = true;
+	}
+
+	stop() {
+		this.release();
 	}
 
 	setScene (scene) {
diff --git a/src/modules/OrientedImages/OrientedImages.js b/src/modules/OrientedImages/OrientedImages.js
index ce7a650d..0d95c86e 100644
--- a/src/modules/OrientedImages/OrientedImages.js
+++ b/src/modules/OrientedImages/OrientedImages.js
@@ -1,14 +1,9 @@
-
 import * as THREE from "../../../libs/three.js/build/three.module.js";
-import {OrientedImageControls} from "./OrientedImageControls.js";
+import { OrientedImageControls } from "./OrientedImageControls.js";
 import { EventDispatcher } from "../../EventDispatcher.js";
 
-// https://support.pix4d.com/hc/en-us/articles/205675256-How-are-yaw-pitch-roll-defined
-// https://support.pix4d.com/hc/en-us/articles/202558969-How-are-omega-phi-kappa-defined
-
-function createMaterial(){
-
-	let vertexShader = `
+function createMaterial() {
+  let vertexShader = `
 	uniform float uNear;
 	varying vec2 vUV;
 	varying vec4 vDebug;
@@ -23,7 +18,7 @@ function createMaterial(){
 	}
 	`;
 
-	let fragmentShader = `
+  let fragmentShader = `
 	uniform sampler2D tColor;
 	uniform float uOpacity;
 	varying vec2 vUV;
@@ -34,457 +29,460 @@ function createMaterial(){
 		gl_FragColor.a = uOpacity;
 	}
 	`;
-	const material = new THREE.ShaderMaterial( {
-		uniforms: {
-			// time: { value: 1.0 },
-			// resolution: { value: new THREE.Vector2() }
-			tColor: {value: new THREE.Texture() },
-			uNear: {value: 0.0},
-			uOpacity: {value: 1.0},
-		},
-		vertexShader: vertexShader,
-		fragmentShader: fragmentShader,
-		side: THREE.DoubleSide,
-	} );
-
-	material.side = THREE.DoubleSide;
-
-	return material;
+  const material = new THREE.ShaderMaterial({
+    uniforms: {
+      tColor: { value: new THREE.Texture() },
+      uNear: { value: 0.0 },
+      uOpacity: { value: 1.0 },
+    },
+    vertexShader: vertexShader,
+    fragmentShader: fragmentShader,
+    side: THREE.DoubleSide,
+  });
+
+  material.side = THREE.DoubleSide;
+
+  return material;
 }
 
 const planeGeometry = new THREE.PlaneGeometry(1, 1);
 const lineGeometry = new THREE.Geometry();
 
 lineGeometry.vertices.push(
-	new THREE.Vector3(-0.5, -0.5, 0),
-	new THREE.Vector3( 0.5, -0.5, 0),
-	new THREE.Vector3( 0.5,  0.5, 0),
-	new THREE.Vector3(-0.5,  0.5, 0),
-	new THREE.Vector3(-0.5, -0.5, 0),
+  new THREE.Vector3(-0.5, -0.5, 0),
+  new THREE.Vector3(0.5, -0.5, 0),
+  new THREE.Vector3(0.5, 0.5, 0),
+  new THREE.Vector3(-0.5, 0.5, 0),
+  new THREE.Vector3(-0.5, -0.5, 0)
 );
 
-export class OrientedImage{
-
-	constructor(id){
-
-		this.id = id;
-		this.fov = 1.0;
-		this.position = new THREE.Vector3();
-		this.rotation = new THREE.Vector3();
-		this.width = 0;
-		this.height = 0;
-		this.fov = 1.0;
-
-		const material = createMaterial();
-		const lineMaterial = new THREE.LineBasicMaterial( { color: 0x00ff00 } );
-		this.mesh = new THREE.Mesh(planeGeometry, material);
-		this.line = new THREE.Line(lineGeometry, lineMaterial);
-		this.texture = null;
-
-		this.mesh.orientedImage = this;
-	}
-
-	set(position, rotation, dimension, fov){
-
-		let radians = rotation.map(THREE.Math.degToRad);
-
-		this.position.set(...position);
-		this.mesh.position.set(...position);
-
-		this.rotation.set(...radians);
-		this.mesh.rotation.set(...radians);
-
-		[this.width, this.height] = dimension;
-		this.mesh.scale.set(this.width / this.height, 1, 1);
-
-		this.fov = fov;
-
-		this.updateTransform();
-	}
-
-	updateTransform(){
-		let {mesh, line, fov} = this;
-
-		mesh.updateMatrixWorld();
-		const dir = mesh.getWorldDirection();
-		const alpha = THREE.Math.degToRad(fov / 2);
-		const d = -0.5 / Math.tan(alpha);
-		const move = dir.clone().multiplyScalar(d);
-		mesh.position.add(move);
-
-		line.position.copy(mesh.position);
-		line.scale.copy(mesh.scale);
-		line.rotation.copy(mesh.rotation);
-	}
-
-};
-
-export class OrientedImages extends EventDispatcher{
-
-	constructor(){
-		super();
-
-		this.node = null;
-		this.cameraParams = null;
-		this.imageParams = null;
-		this.images = null;
-		this._visible = true;
-	}
-
-	set visible(visible){
-		if(this._visible === visible){
-			return;
-		}
-
-		for(const image of this.images){
-			image.mesh.visible = visible;
-			image.line.visible = visible;
-		}
-
-		this._visible = visible;
-		this.dispatchEvent({
-			type: "visibility_changed",
-			images: this,
-		});
-	}
-
-	get visible(){
-		return this._visible;
-	}
-
-
-};
-
-export class OrientedImageLoader{
-
-	static async loadCameraParams(path){
-		const res = await fetch(path);
-		const text = await res.text();
-
-		const parser = new DOMParser();
-		const doc = parser.parseFromString(text, "application/xml");
-
-		const width = parseInt(doc.getElementsByTagName("width")[0].textContent);
-		const height = parseInt(doc.getElementsByTagName("height")[0].textContent);
-		const f = parseFloat(doc.getElementsByTagName("f")[0].textContent);
-
-		let a = (height / 2)  / f;
-		let fov = 2 * THREE.Math.radToDeg(Math.atan(a));
-
-		const params = {
-			path: path,
-			width: width,
-			height: height,
-			f: f,
-			fov: fov,
-		};
-
-		return params;
-	}
-
-	static async loadImageParams(path){
-
-		const response = await fetch(path);
-		if(!response.ok){
-			console.error(`failed to load ${path}`);
-			return;
-		}
-
-		const content = await response.text();
-		const lines = content.split(/\r?\n/);
-		const imageParams = [];
-
-		for(let i = 1; i < lines.length; i++){
-			const line = lines[i];
-
-			if(line.startsWith("#")){
-				continue;
-			}
-
-			const tokens = line.split(/\s+/);
-
-			if(tokens.length < 6){
-				continue;
-			}
-
-			const params = {
-				id: tokens[0],
-				x: Number.parseFloat(tokens[1]),
-				y: Number.parseFloat(tokens[2]),
-				z: Number.parseFloat(tokens[3]),
-				omega: Number.parseFloat(tokens[4]),
-				phi: Number.parseFloat(tokens[5]),
-				kappa: Number.parseFloat(tokens[6]),
-			};
-
-			// const whitelist = ["47518.jpg"];
-			// if(whitelist.includes(params.id)){
-			// 	imageParams.push(params);
-			// }
-			imageParams.push(params);
-		}
-
-		// debug
-		//return [imageParams[50]];
-
-		return imageParams;
-	}
+export class OrientedImage {
+  constructor(id) {
+    this.id = id;
+    this.fov = 1.0;
+    this.position = new THREE.Vector3();
+    this.rotation = new THREE.Vector3();
+    this.width = 0;
+    this.height = 0;
+    this.fov = 1.0;
+
+    const material = createMaterial();
+    const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
+    this.mesh = new THREE.Mesh(planeGeometry, material);
+    this.line = new THREE.Line(lineGeometry, lineMaterial);
+    this.texture = null;
+
+    this.mesh.orientedImage = this;
+  }
+
+  set(position, rotation, dimension, fov) {
+    let radians = rotation.map(THREE.Math.degToRad);
+
+    this.position.set(...position);
+    this.mesh.position.set(...position);
+
+    this.rotation.set(...radians);
+    this.mesh.rotation.set(...radians);
+
+    [this.width, this.height] = dimension;
+    this.mesh.scale.set(this.width / this.height, 1, 1);
+
+    this.fov = fov;
+
+    this.updateTransform();
+  }
+
+  updateTransform() {
+    let { mesh, line, fov } = this;
+
+    mesh.updateMatrixWorld();
+    var dir = new THREE.Vector3();
+    mesh.getWorldDirection(dir);
+    const alpha = THREE.Math.degToRad(fov / 2);
+    const d = -0.5 / Math.tan(alpha);
+    const move = dir.clone().multiplyScalar(d);
+    mesh.position.add(move);
+
+    line.position.copy(mesh.position);
+    line.scale.copy(mesh.scale);
+    line.rotation.copy(mesh.rotation);
+  }
+}
 
-	static async load(cameraParamsPath, imageParamsPath, viewer){
-
-		const tStart = performance.now();
-
-		const [cameraParams, imageParams] = await Promise.all([
-			OrientedImageLoader.loadCameraParams(cameraParamsPath),
-			OrientedImageLoader.loadImageParams(imageParamsPath),
-		]);
-
-		const orientedImageControls = new OrientedImageControls(viewer);
-		const raycaster = new THREE.Raycaster();
-
-		const tEnd = performance.now();
-		console.log(tEnd - tStart);
-
-		// const sp = new THREE.PlaneGeometry(1, 1);
-		// const lg = new THREE.Geometry();
-
-		// lg.vertices.push(
-		// 	new THREE.Vector3(-0.5, -0.5, 0),
-		// 	new THREE.Vector3( 0.5, -0.5, 0),
-		// 	new THREE.Vector3( 0.5,  0.5, 0),
-		// 	new THREE.Vector3(-0.5,  0.5, 0),
-		// 	new THREE.Vector3(-0.5, -0.5, 0),
-		// );
-
-		const {width, height} = cameraParams;
-		const orientedImages = [];
-		const sceneNode = new THREE.Object3D();
-		sceneNode.name = "oriented_images";
-
-		for(const params of imageParams){
-
-			// const material = createMaterial();
-			// const lm = new THREE.LineBasicMaterial( { color: 0x00ff00 } );
-			// const mesh = new THREE.Mesh(sp, material);
-
-			const {x, y, z, omega, phi, kappa} = params;
-			// const [rx, ry, rz] = [omega, phi, kappa]
-			// 	.map(THREE.Math.degToRad);
-			
-			// mesh.position.set(x, y, z);
-			// mesh.scale.set(width / height, 1, 1);
-			// mesh.rotation.set(rx, ry, rz);
-			// {
-			// 	mesh.updateMatrixWorld();
-			// 	const dir = mesh.getWorldDirection();
-			// 	const alpha = THREE.Math.degToRad(cameraParams.fov / 2);
-			// 	const d = -0.5 / Math.tan(alpha);
-			// 	const move = dir.clone().multiplyScalar(d);
-			// 	mesh.position.add(move);
-			// }
-			// sceneNode.add(mesh);
-
-			// const line = new THREE.Line(lg, lm);
-			// line.position.copy(mesh.position);
-			// line.scale.copy(mesh.scale);
-			// line.rotation.copy(mesh.rotation);
-			// sceneNode.add(line);
-
-			let orientedImage = new OrientedImage(params.id);
-			// orientedImage.setPosition(x, y, z);
-			// orientedImage.setRotation(omega, phi, kappa);
-			// orientedImage.setDimension(width, height);
-			let position = [x, y, z];
-			let rotation = [omega, phi, kappa];
-			let dimension = [width, height];
-			orientedImage.set(position, rotation, dimension, cameraParams.fov);
-
-			sceneNode.add(orientedImage.mesh);
-			sceneNode.add(orientedImage.line);
-			
-			orientedImages.push(orientedImage);
-		}
-
-		let hoveredElement = null;
-		let clipVolume = null;
-
-		const onMouseMove = (evt) => {
-			const tStart = performance.now();
-			if(hoveredElement){
-				hoveredElement.line.material.color.setRGB(0, 1, 0);
-			}
-			evt.preventDefault();
-
-			//var array = getMousePosition( container, evt.clientX, evt.clientY );
-			const rect = viewer.renderer.domElement.getBoundingClientRect();
-			const [x, y] = [evt.clientX, evt.clientY];
-			const array = [ 
-				( x - rect.left ) / rect.width, 
-				( y - rect.top ) / rect.height 
-			];
-			const onClickPosition = new THREE.Vector2(...array);
-			//const intersects = getIntersects(onClickPosition, scene.children);
-			const camera = viewer.scene.getActiveCamera();
-			const mouse = new THREE.Vector3(
-				+ ( onClickPosition.x * 2 ) - 1, 
-				- ( onClickPosition.y * 2 ) + 1 );
-			const objects = orientedImages.map(i => i.mesh);
-			raycaster.setFromCamera( mouse, camera );
-			const intersects = raycaster.intersectObjects( objects );
-			let selectionChanged = false;
-
-			if ( intersects.length > 0){
-				//console.log(intersects);
-				const intersection = intersects[0];
-				const orientedImage = intersection.object.orientedImage;
-				orientedImage.line.material.color.setRGB(1, 0, 0);
-				selectionChanged = hoveredElement !== orientedImage;
-				hoveredElement = orientedImage;
-			}else{
-				hoveredElement = null;
-			}
-
-			let shouldRemoveClipVolume = clipVolume !== null && hoveredElement === null;
-			let shouldAddClipVolume = clipVolume === null && hoveredElement !== null;
-
-			if(clipVolume !== null && (hoveredElement === null || selectionChanged)){
-				// remove existing
-				viewer.scene.removePolygonClipVolume(clipVolume);
-				clipVolume = null;
-			}
-			
-			if(shouldAddClipVolume || selectionChanged){
-				const img = hoveredElement;
-				const fov = cameraParams.fov;
-				const aspect  = cameraParams.width / cameraParams.height;
-				const near = 1.0;
-				const far = 1000 * 1000;
-				const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
-				camera.rotation.order = viewer.scene.getActiveCamera().rotation.order;
-				camera.rotation.copy(img.mesh.rotation);
-				{
-					const mesh = img.mesh;
-					const dir = mesh.getWorldDirection();
-					const pos = mesh.position;
-					const alpha = THREE.Math.degToRad(fov / 2);
-					const d = 0.5 / Math.tan(alpha);
-					const newCamPos = pos.clone().add(dir.clone().multiplyScalar(d));
-					const newCamDir = pos.clone().sub(newCamPos);
-					const newCamTarget = new THREE.Vector3().addVectors(
-						newCamPos,
-						newCamDir.clone().multiplyScalar(viewer.getMoveSpeed()));
-					camera.position.copy(newCamPos);
-				}
-				let volume = new Potree.PolygonClipVolume(camera);
-				let m0 = new THREE.Mesh();
-				let m1 = new THREE.Mesh();
-				let m2 = new THREE.Mesh();
-				let m3 = new THREE.Mesh();
-				m0.position.set(-1, -1, 0);
-				m1.position.set( 1, -1, 0);
-				m2.position.set( 1,  1, 0);
-				m3.position.set(-1,  1, 0);
-				volume.markers.push(m0, m1, m2, m3);
-				volume.initialized = true;
-				
-				viewer.scene.addPolygonClipVolume(volume);
-				clipVolume = volume;
-			}
-			const tEnd = performance.now();
-			//console.log(tEnd - tStart);
-		};
-
-		const moveToImage = (image) => {
-			console.log("move to image " + image.id);
-
-			const mesh = image.mesh;
-			const newCamPos = image.position.clone();
-			const newCamTarget = mesh.position.clone();
-
-			viewer.scene.view.setView(newCamPos, newCamTarget, 500, () => {
-				orientedImageControls.capture(image);
-			});
-
-			if(image.texture === null){
-
-				const target = image;
-
-				const tmpImagePath = `${Potree.resourcePath}/images/loading.jpg`;
-				new THREE.TextureLoader().load(tmpImagePath,
-					(texture) => {
-						if(target.texture === null){
-							target.texture = texture;
-							target.mesh.material.uniforms.tColor.value = texture;
-							mesh.material.needsUpdate = true;
-						}
-					}
-				);
-
-				const imagePath = `${imageParamsPath}/../${target.id}`;
-				new THREE.TextureLoader().load(imagePath,
-					(texture) => {
-						target.texture = texture;
-						target.mesh.material.uniforms.tColor.value = texture;
-						mesh.material.needsUpdate = true;
-					}
-				);
-				
-
-			}
-		};
-
-		const onMouseClick = (evt) => {
-
-			if(orientedImageControls.hasSomethingCaptured()){
-				return;
-			}
-
-			if(hoveredElement){
-				moveToImage(hoveredElement);
-			}
-		};
-		viewer.renderer.domElement.addEventListener( 'mousemove', onMouseMove, false );
-		viewer.renderer.domElement.addEventListener( 'mousedown', onMouseClick, false );
-
-		viewer.addEventListener("update", () => {
-
-			for(const image of orientedImages){
-				const world = image.mesh.matrixWorld;
-				const {width, height} = image;
-				const aspect = width / height;
-
-				const camera = viewer.scene.getActiveCamera();
-
-				const imgPos = image.mesh.getWorldPosition(new THREE.Vector3());
-				const camPos = camera.position;
-				const d = camPos.distanceTo(imgPos);
-
-				const minSize = 1; // in degrees of fov
-				const a = THREE.Math.degToRad(minSize);
-				let r = d * Math.tan(a);
-				r = Math.max(r, 1);
-
-
-				image.mesh.scale.set(r * aspect, r, 1);
-				image.line.scale.set(r * aspect, r, 1);
-
-				image.mesh.material.uniforms.uNear.value = camera.near;
-
-			}
-
-		});
-
-		const images = new OrientedImages();
-		images.node = sceneNode;
-		images.cameraParamsPath = cameraParamsPath;
-		images.imageParamsPath = imageParamsPath;
-		images.cameraParams = cameraParams;
-		images.imageParams = imageParams;
-		images.images = orientedImages;
-
-		Potree.debug.moveToImage = moveToImage;
-
-		return images;
-	}
+export class OrientedImages extends EventDispatcher {
+  constructor() {
+    super();
+
+    this.node = null;
+    this.cameraParams = null;
+    this.imageParams = null;
+    this.images = null;
+    this._visible = true;
+    this.focused = null;
+  }
+
+  set visible(visible) {
+    if (this._visible === visible) {
+      return;
+    }
+
+    for (const image of this.images) {
+      image.mesh.visible = visible;
+      image.line.visible = visible;
+    }
+
+    this._visible = visible;
+    this.dispatchEvent({
+      type: "visibility_changed",
+      images: this,
+    });
+  }
+
+  get visible() {
+    return this._visible;
+  }
 }
 
+export class OrientedImageLoader {
+  static async loadCameraParams(path) {
+    const res = await fetch(path);
+    const text = await res.text();
+
+    const parser = new DOMParser();
+    const doc = parser.parseFromString(text, "application/xml");
+
+    const width = parseInt(doc.getElementsByTagName("width")[0].textContent);
+    const height = parseInt(doc.getElementsByTagName("height")[0].textContent);
+    const f = parseFloat(doc.getElementsByTagName("f")[0].textContent);
+
+    let a = height / 2 / f;
+    let fov = 2 * THREE.Math.radToDeg(Math.atan(a));
+
+    const params = {
+      path: path,
+      width: width,
+      height: height,
+      f: f,
+      fov: fov,
+    };
+
+    return params;
+  }
+
+  static async loadImageParams(path, tm) {
+    const response = await fetch(path);
+    if (!response.ok) {
+      console.error(`failed to load ${path}`);
+      return;
+    }
+
+    const content = await response.text();
+
+    const imageParams = [];
+
+    const imgData = JSON.parse(content);
+
+    imgData.camname.forEach((imgName, index) => {
+      const rawPos = new THREE.Vector4(
+        Number.parseFloat(imgData.camX[index]),
+        Number.parseFloat(imgData.camY[index]),
+        Number.parseFloat(imgData.camZ[index]),
+        1
+      );
+      rawPos.applyMatrix4(tm);
+
+      const params = {
+        id: imgData.camname[index],
+        x: Number.parseFloat(imgData.camX[index]),
+        y: Number.parseFloat(imgData.camY[index]),
+        z: Number.parseFloat(imgData.camZ[index]),
+        x_tm: rawPos.x,
+        y_tm: rawPos.y,
+        z_tm: rawPos.z,
+        omega: Number.parseFloat(imgData.camRoll[index]),
+        phi: Number.parseFloat(imgData.camPitch[index]),
+        kappa: Number.parseFloat(imgData.camYaw[index]),
+      };
+
+      imageParams.push(params);
+    });
+
+    const width = parseInt(imgData.camPix[0]);
+    const height = parseInt(imgData.camPix[1]);
+    const f = parseFloat(imgData.camFocal);
+
+    let a = height / 2 / f;
+    let fov = 2 * THREE.Math.radToDeg(Math.atan(a));
+
+    const params = {
+      path: path,
+      width: width,
+      height: height,
+      f: f,
+      fov: fov,
+    };
+
+    return [params, imageParams];
+  }
+
+  static async load(imageParamsPath, imagesPath, viewer, tm_data) {
+    const tStart = performance.now();
+
+    let tmatrix, toffset;
+
+    tmatrix = tm_data.tm;
+    toffset = tm_data.offset;
+
+    const [cameraParams, imageParams] =
+      await OrientedImageLoader.loadImageParams(imageParamsPath, tmatrix);
+
+    const orientedImageControls = new OrientedImageControls(viewer);
+    const raycaster = new THREE.Raycaster();
+
+    const tEnd = performance.now();
+    console.log(tEnd - tStart);
+
+    const { width, height } = cameraParams;
+    const orientedImages = [];
+    const sceneNode = new THREE.Object3D();
+    sceneNode.name = "oriented_images";
+
+    for (const params of imageParams) {
+      const { x, y, z, x_tm, y_tm, z_tm, omega, phi, kappa } = params;
+      let orientedImage = new OrientedImage(params.id);
+      let position = [x, y, z];
+      let rotation = [omega, phi, kappa];
+      let dimension = [width, height];
+      orientedImage.set(position, rotation, dimension, cameraParams.fov);
+      orientedImage.mesh.applyMatrix4(tmatrix);
+      let curMeshPos = orientedImage.mesh.position.clone();
+      orientedImage.mesh.position.set(
+        curMeshPos.x - toffset[0],
+        curMeshPos.y - toffset[1],
+        curMeshPos.z - toffset[2]
+      );
+      orientedImage.line.applyMatrix4(tmatrix);
+      let curLinePos = orientedImage.line.position.clone();
+      orientedImage.line.position.set(
+        curLinePos.x - toffset[0],
+        curLinePos.y - toffset[1],
+        curLinePos.z - toffset[2]
+      );
+      orientedImage.position.set(
+        x_tm - toffset[0],
+        y_tm - toffset[1],
+        z_tm - toffset[2]
+      );
+      sceneNode.add(orientedImage.mesh);
+      sceneNode.add(orientedImage.line);
+
+      orientedImages.push(orientedImage);
+    }
+
+    let hoveredElement = null;
+    let clipVolume = null;
+
+    const images = new OrientedImages();
+    images.node = sceneNode;
+    images.imageParamsPath = imageParamsPath;
+    images.cameraParams = cameraParams;
+    images.imageParams = imageParams;
+    images.images = orientedImages;
+    images.hovered = hoveredElement;
+
+    const onMouseMove = (evt) => {
+      const tStart = performance.now();
+      if (hoveredElement) {
+        hoveredElement.line.material.color.setRGB(0, 1, 0);
+      }
+      evt.preventDefault();
+      if (images.visible) {
+        const rect = viewer.renderer.domElement.getBoundingClientRect();
+        const [x, y] = [evt.clientX, evt.clientY];
+        const array = [
+          (x - rect.left) / rect.width,
+          (y - rect.top) / rect.height,
+        ];
+        const onClickPosition = new THREE.Vector2(...array);
+        const camera = viewer.scene.getActiveCamera();
+        const mouse = new THREE.Vector3(
+          +(onClickPosition.x * 2) - 1,
+          -(onClickPosition.y * 2) + 1
+        );
+        const objects = orientedImages.map((i) => i.mesh);
+        raycaster.setFromCamera(mouse, camera);
+        const intersects = raycaster.intersectObjects(objects);
+        let selectionChanged = false;
+
+        if (intersects.length > 0) {
+          const intersection = intersects[0];
+          const orientedImage = intersection.object.orientedImage;
+          orientedImage.line.material.color.setRGB(1, 0, 0);
+          selectionChanged = hoveredElement !== orientedImage;
+          hoveredElement = orientedImage;
+        } else {
+          hoveredElement = null;
+        }
+
+        let shouldRemoveClipVolume =
+          clipVolume !== null && hoveredElement === null;
+        let shouldAddClipVolume =
+          clipVolume === null && hoveredElement !== null;
+
+        if (
+          clipVolume !== null &&
+          (hoveredElement === null || selectionChanged)
+        ) {
+          // remove existing
+          viewer.scene.removePolygonClipVolume(clipVolume);
+          clipVolume = null;
+        }
+
+        if (shouldAddClipVolume || selectionChanged) {
+          const img = hoveredElement;
+          const fov = cameraParams.fov;
+          const aspect = cameraParams.width / cameraParams.height;
+          const near = 1.0;
+          const far = 1000 * 1000;
+          const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
+          camera.rotation.order = viewer.scene.getActiveCamera().rotation.order;
+          camera.rotation.copy(img.mesh.rotation);
+          {
+            const mesh = img.mesh;
+            const dir = mesh.getWorldDirection();
+            const pos = mesh.position;
+            const alpha = THREE.Math.degToRad(fov / 2);
+            const d = 0.5 / Math.tan(alpha);
+            const newCamPos = pos.clone().add(dir.clone().multiplyScalar(d));
+            const newCamDir = pos.clone().sub(newCamPos);
+            const newCamTarget = new THREE.Vector3().addVectors(
+              newCamPos,
+              newCamDir.clone().multiplyScalar(viewer.getMoveSpeed())
+            );
+            camera.position.copy(newCamPos);
+          }
+          let volume = new Potree.PolygonClipVolume(camera);
+          let m0 = new THREE.Mesh();
+          let m1 = new THREE.Mesh();
+          let m2 = new THREE.Mesh();
+          let m3 = new THREE.Mesh();
+          m0.position.set(-1, -1, 0);
+          m1.position.set(1, -1, 0);
+          m2.position.set(1, 1, 0);
+          m3.position.set(-1, 1, 0);
+          volume.markers.push(m0, m1, m2, m3);
+          volume.initialized = true;
+
+          viewer.scene.addPolygonClipVolume(volume);
+          clipVolume = volume;
+        }
+        const tEnd = performance.now();
+        //console.log(tEnd - tStart);
+      } else {
+        hoveredElement = null;
+        if (clipVolume) {
+          viewer.scene.removePolygonClipVolume(clipVolume);
+          clipVolume = null;
+        }
+      }
+    };
+
+    const moveToImage = async (image, sendEvent = true) => {
+      viewer.controls.enabled = false;
+
+      if (sendEvent) {
+        const event = new CustomEvent("imageLoad", {
+          detail: {
+            viewer: viewer.canvasId,
+            image,
+          },
+        });
+        document.dispatchEvent(event);
+      }
+
+      const mesh = image.mesh;
+      const target = image;
+
+      const newCamPos = image.position.clone();
+      const newCamTarget = mesh.position.clone();
+
+      viewer.scene.view.setView(newCamPos, newCamTarget);
+
+      function loadImageTexture(path) {
+        return new Promise((resolve, reject) => {
+          new THREE.TextureLoader().load(path, (texture) => {
+            resolve(texture);
+          });
+        });
+      }
+
+      function updateTexture(texture) {
+        target.texture = texture;
+        target.mesh.material.uniforms.tColor.value = texture;
+        mesh.material.needsUpdate = true;
+      }
+
+      viewer.scene.orientedImages[0].focused = image;
+      const tmpImagePath = `${imagesPath}/thumbnails/${target.id}`;
+      let texture = await loadImageTexture(tmpImagePath);
+      updateTexture(texture);
+      setTimeout(() => {
+        orientedImageControls.capture(image);
+      }, 100);
+      const imagePath = `${imagesPath}/${target.id}`;
+      let texture_org = await loadImageTexture(imagePath);
+      updateTexture(texture_org);
+      image.texture = texture_org;
+    };
+
+    const onMouseClick = (evt) => {
+      if (orientedImageControls.hasSomethingCaptured()) {
+        return;
+      }
+
+      if (hoveredElement) {
+        moveToImage(hoveredElement);
+      }
+    };
+    viewer.renderer.domElement.addEventListener(
+      "mousemove",
+      onMouseMove,
+      false
+    );
+    viewer.renderer.domElement.addEventListener(
+      "mousedown",
+      onMouseClick,
+      false
+    );
+
+    viewer.addEventListener("update", () => {
+      for (const image of orientedImages) {
+        const world = image.mesh.matrixWorld;
+        const { width, height } = image;
+        const aspect = width / height;
+
+        const camera = viewer.scene.getActiveCamera();
+
+        const imgPos = image.mesh.getWorldPosition(new THREE.Vector3());
+        const camPos = camera.position;
+        const d = camPos.distanceTo(imgPos);
+
+        const minSize = 1; // in degrees of fov
+        const a = THREE.Math.degToRad(minSize);
+        let r = d * Math.tan(a);
+        r = Math.max(r, 1);
+
+        image.mesh.scale.set(r * aspect, r, 1);
+        image.line.scale.set(r * aspect, r, 1);
+
+        image.mesh.material.uniforms.uNear.value = camera.near;
+      }
+    });
+
+    images.moveToImage = moveToImage;
+    images.release = function () {
+      orientedImageControls.release();
+    };
+    return images;
+  }
+}
diff --git a/src/navigation/OrbitControls.js b/src/navigation/OrbitControls.js
index 520a11b3..1d21da93 100644
--- a/src/navigation/OrbitControls.js
+++ b/src/navigation/OrbitControls.js
@@ -14,281 +14,317 @@
  */
 
 import * as THREE from "../../libs/three.js/build/three.module.js";
-import {MOUSE} from "../defines.js";
-import {Utils} from "../utils.js";
-import {EventDispatcher} from "../EventDispatcher.js";
-
- 
-export class OrbitControls extends EventDispatcher{
-	
-	constructor(viewer){
-		super();
-		
-		this.viewer = viewer;
-		this.renderer = viewer.renderer;
+import { MOUSE } from "../defines.js";
+import { Utils } from "../utils.js";
+import { EventDispatcher } from "../EventDispatcher.js";
 
-		this.scene = null;
-		this.sceneControls = new THREE.Scene();
-
-		this.rotationSpeed = 5;
+export class OrbitControls extends EventDispatcher {
+  constructor(viewer) {
+    super();
 
-		this.fadeFactor = 20;
-		this.yawDelta = 0;
-		this.pitchDelta = 0;
-		this.panDelta = new THREE.Vector2(0, 0);
-		this.radiusDelta = 0;
+    this.viewer = viewer;
+    this.renderer = viewer.renderer;
 
-		this.doubleClockZoomEnabled = true;
+    this.scene = null;
+    this.sceneControls = new THREE.Scene();
 
-		this.tweens = [];
+    this.rotationSpeed = 5;
 
-		let drag = (e) => {
-			if (e.drag.object !== null) {
-				return;
-			}
-
-			if (e.drag.startHandled === undefined) {
-				e.drag.startHandled = true;
-
-				this.dispatchEvent({type: 'start'});
-			}
-
-			let ndrag = {
-				x: e.drag.lastDrag.x / this.renderer.domElement.clientWidth,
-				y: e.drag.lastDrag.y / this.renderer.domElement.clientHeight
-			};
-
-			if (e.drag.mouse === MOUSE.LEFT) {
-				this.yawDelta += ndrag.x * this.rotationSpeed;
-				this.pitchDelta += ndrag.y * this.rotationSpeed;
-
-				this.stopTweens();
-			} else if (e.drag.mouse === MOUSE.RIGHT) {
-				this.panDelta.x += ndrag.x;
-				this.panDelta.y += ndrag.y;
-
-				this.stopTweens();
-			}
-		};
-
-		let drop = e => {
-			this.dispatchEvent({type: 'end'});
-		};
-
-		let scroll = (e) => {
-			let resolvedRadius = this.scene.view.radius + this.radiusDelta;
-
-			this.radiusDelta += -e.delta * resolvedRadius * 0.1;
-
-			this.stopTweens();
-		};
-
-		let dblclick = (e) => {
-			if(this.doubleClockZoomEnabled){
-				this.zoomToLocation(e.mouse);
-			}
-		};
-
-		let previousTouch = null;
-		let touchStart = e => {
-			previousTouch = e;
-		};
-
-		let touchEnd = e => {
-			previousTouch = e;
-		};
-
-		let touchMove = e => {
-			if (e.touches.length === 2 && previousTouch.touches.length === 2){
-				let prev = previousTouch;
-				let curr = e;
-
-				let prevDX = prev.touches[0].pageX - prev.touches[1].pageX;
-				let prevDY = prev.touches[0].pageY - prev.touches[1].pageY;
-				let prevDist = Math.sqrt(prevDX * prevDX + prevDY * prevDY);
-
-				let currDX = curr.touches[0].pageX - curr.touches[1].pageX;
-				let currDY = curr.touches[0].pageY - curr.touches[1].pageY;
-				let currDist = Math.sqrt(currDX * currDX + currDY * currDY);
-
-				let delta = currDist / prevDist;
-				let resolvedRadius = this.scene.view.radius + this.radiusDelta;
-				let newRadius = resolvedRadius / delta;
-				this.radiusDelta = newRadius - resolvedRadius;
-
-				this.stopTweens();
-			}else if(e.touches.length === 3 && previousTouch.touches.length === 3){
-				let prev = previousTouch;
-				let curr = e;
-
-				let prevMeanX = (prev.touches[0].pageX + prev.touches[1].pageX + prev.touches[2].pageX) / 3;
-				let prevMeanY = (prev.touches[0].pageY + prev.touches[1].pageY + prev.touches[2].pageY) / 3;
-
-				let currMeanX = (curr.touches[0].pageX + curr.touches[1].pageX + curr.touches[2].pageX) / 3;
-				let currMeanY = (curr.touches[0].pageY + curr.touches[1].pageY + curr.touches[2].pageY) / 3;
-
-				let delta = {
-					x: (currMeanX - prevMeanX) / this.renderer.domElement.clientWidth,
-					y: (currMeanY - prevMeanY) / this.renderer.domElement.clientHeight
-				};
-
-				this.panDelta.x += delta.x;
-				this.panDelta.y += delta.y;
-
-				this.stopTweens();
-			}
-
-			previousTouch = e;
-		};
-
-		this.addEventListener('touchstart', touchStart);
-		this.addEventListener('touchend', touchEnd);
-		this.addEventListener('touchmove', touchMove);
-		this.addEventListener('drag', drag);
-		this.addEventListener('drop', drop);
-		this.addEventListener('mousewheel', scroll);
-		this.addEventListener('dblclick', dblclick);
-	}
-
-	setScene (scene) {
-		this.scene = scene;
-	}
-
-	stop(){
-		this.yawDelta = 0;
-		this.pitchDelta = 0;
-		this.radiusDelta = 0;
-		this.panDelta.set(0, 0);
-	}
-	
-	zoomToLocation(mouse){
-		let camera = this.scene.getActiveCamera();
-		
-		let I = Utils.getMousePointCloudIntersection(
-			mouse,
-			camera,
-			this.viewer,
-			this.scene.pointclouds,
-			{pickClipped: true});
-
-		if (I === null) {
-			return;
-		}
-
-		let targetRadius = 0;
-		{
-			let minimumJumpDistance = 0.2;
-
-			let domElement = this.renderer.domElement;
-			let ray = Utils.mouseToRay(mouse, camera, domElement.clientWidth, domElement.clientHeight);
-
-			let nodes = I.pointcloud.nodesOnRay(I.pointcloud.visibleNodes, ray);
-			let lastNode = nodes[nodes.length - 1];
-			let radius = lastNode.getBoundingSphere(new THREE.Sphere()).radius;
-			targetRadius = Math.min(this.scene.view.radius, radius);
-			targetRadius = Math.max(minimumJumpDistance, targetRadius);
-		}
-
-		let d = this.scene.view.direction.multiplyScalar(-1);
-		let cameraTargetPosition = new THREE.Vector3().addVectors(I.location, d.multiplyScalar(targetRadius));
-		// TODO Unused: let controlsTargetPosition = I.location;
-
-		let animationDuration = 600;
-		let easing = TWEEN.Easing.Quartic.Out;
-
-		{ // animate
-			let value = {x: 0};
-			let tween = new TWEEN.Tween(value).to({x: 1}, animationDuration);
-			tween.easing(easing);
-			this.tweens.push(tween);
-
-			let startPos = this.scene.view.position.clone();
-			let targetPos = cameraTargetPosition.clone();
-			let startRadius = this.scene.view.radius;
-			let targetRadius = cameraTargetPosition.distanceTo(I.location);
-
-			tween.onUpdate(() => {
-				let t = value.x;
-				this.scene.view.position.x = (1 - t) * startPos.x + t * targetPos.x;
-				this.scene.view.position.y = (1 - t) * startPos.y + t * targetPos.y;
-				this.scene.view.position.z = (1 - t) * startPos.z + t * targetPos.z;
-
-				this.scene.view.radius = (1 - t) * startRadius + t * targetRadius;
-				this.viewer.setMoveSpeed(this.scene.view.radius);
-			});
-
-			tween.onComplete(() => {
-				this.tweens = this.tweens.filter(e => e !== tween);
-			});
-
-			tween.start();
-		}
-	}
-
-	stopTweens () {
-		this.tweens.forEach(e => e.stop());
-		this.tweens = [];
-	}
-
-	update (delta) {
-		let view = this.scene.view;
-
-		{ // apply rotation
-			let progression = Math.min(1, this.fadeFactor * delta);
-
-			let yaw = view.yaw;
-			let pitch = view.pitch;
-			let pivot = view.getPivot();
-
-			yaw -= progression * this.yawDelta;
-			pitch -= progression * this.pitchDelta;
-
-			view.yaw = yaw;
-			view.pitch = pitch;
-
-			let V = this.scene.view.direction.multiplyScalar(-view.radius);
-			let position = new THREE.Vector3().addVectors(pivot, V);
-
-			view.position.copy(position);
-		}
-
-		{ // apply pan
-			let progression = Math.min(1, this.fadeFactor * delta);
-			let panDistance = progression * view.radius * 3;
-
-			let px = -this.panDelta.x * panDistance;
-			let py = this.panDelta.y * panDistance;
-
-			view.pan(px, py);
-		}
-
-		{ // apply zoom
-			let progression = Math.min(1, this.fadeFactor * delta);
-
-			// let radius = view.radius + progression * this.radiusDelta * view.radius * 0.1;
-			let radius = view.radius + progression * this.radiusDelta;
-
-			let V = view.direction.multiplyScalar(-radius);
-			let position = new THREE.Vector3().addVectors(view.getPivot(), V);
-			view.radius = radius;
-
-			view.position.copy(position);
-		}
+    this.fadeFactor = 20;
+    this.yawDelta = 0;
+    this.pitchDelta = 0;
+    this.panDelta = new THREE.Vector2(0, 0);
+    this.radiusDelta = 0;
 
-		{
-			let speed = view.radius;
-			this.viewer.setMoveSpeed(speed);
-		}
-
-		{ // decelerate over time
-			let progression = Math.min(1, this.fadeFactor * delta);
-			let attenuation = Math.max(0, 1 - this.fadeFactor * delta);
-
-			this.yawDelta *= attenuation;
-			this.pitchDelta *= attenuation;
-			this.panDelta.multiplyScalar(attenuation);
-			// this.radiusDelta *= attenuation;
-			this.radiusDelta -= progression * this.radiusDelta;
-		}
-	}
-};
+    this.doubleClockZoomEnabled = true;
+
+    this.tweens = [];
+
+    this.changeEvent = new CustomEvent("camerachange");
+
+    let drag = (e) => {
+      if (e.drag.object !== null) {
+        return;
+      }
+
+      if (e.drag.startHandled === undefined) {
+        e.drag.startHandled = true;
+
+        this.dispatchEvent({ type: "start" });
+      }
+
+      let ndrag = {
+        x: e.drag.lastDrag.x / this.renderer.domElement.clientWidth,
+        y: e.drag.lastDrag.y / this.renderer.domElement.clientHeight,
+      };
+
+      if (e.drag.mouse === MOUSE.LEFT) {
+        this.yawDelta += ndrag.x * this.rotationSpeed;
+        this.pitchDelta += ndrag.y * this.rotationSpeed;
+
+        this.stopTweens();
+      } else if (e.drag.mouse === MOUSE.RIGHT) {
+        this.panDelta.x += ndrag.x;
+        this.panDelta.y += ndrag.y;
+
+        this.stopTweens();
+      }
+
+      document.dispatchEvent(this.changeEvent);
+    };
+
+    let drop = (e) => {
+      this.dispatchEvent({ type: "end" });
+      document.dispatchEvent(this.changeEvent);
+    };
+
+    let scroll = (e) => {
+      let resolvedRadius = this.scene.view.radius + this.radiusDelta;
+
+      this.radiusDelta += -e.delta * resolvedRadius * 0.1;
+
+      this.stopTweens();
+      document.dispatchEvent(this.changeEvent);
+    };
+
+    let dblclick = (e) => {
+      if (this.doubleClockZoomEnabled) {
+        this.zoomToLocation(e.mouse);
+      }
+    };
+
+    let previousTouch = null;
+    let touchStart = (e) => {
+      previousTouch = e;
+    };
+
+    let touchEnd = (e) => {
+      previousTouch = e;
+    };
+
+    let touchMove = (e) => {
+      if (e.touches.length === 2 && previousTouch.touches.length === 2) {
+        let prev = previousTouch;
+        let curr = e;
+
+        let prevDX = prev.touches[0].pageX - prev.touches[1].pageX;
+        let prevDY = prev.touches[0].pageY - prev.touches[1].pageY;
+        let prevDist = Math.sqrt(prevDX * prevDX + prevDY * prevDY);
+
+        let currDX = curr.touches[0].pageX - curr.touches[1].pageX;
+        let currDY = curr.touches[0].pageY - curr.touches[1].pageY;
+        let currDist = Math.sqrt(currDX * currDX + currDY * currDY);
+
+        let delta = currDist / prevDist;
+        let resolvedRadius = this.scene.view.radius + this.radiusDelta;
+        let newRadius = resolvedRadius / delta;
+        this.radiusDelta = newRadius - resolvedRadius;
+
+        this.stopTweens();
+      } else if (e.touches.length === 3 && previousTouch.touches.length === 3) {
+        let prev = previousTouch;
+        let curr = e;
+
+        let prevMeanX =
+          (prev.touches[0].pageX +
+            prev.touches[1].pageX +
+            prev.touches[2].pageX) /
+          3;
+        let prevMeanY =
+          (prev.touches[0].pageY +
+            prev.touches[1].pageY +
+            prev.touches[2].pageY) /
+          3;
+
+        let currMeanX =
+          (curr.touches[0].pageX +
+            curr.touches[1].pageX +
+            curr.touches[2].pageX) /
+          3;
+        let currMeanY =
+          (curr.touches[0].pageY +
+            curr.touches[1].pageY +
+            curr.touches[2].pageY) /
+          3;
+
+        let delta = {
+          x: (currMeanX - prevMeanX) / this.renderer.domElement.clientWidth,
+          y: (currMeanY - prevMeanY) / this.renderer.domElement.clientHeight,
+        };
+
+        this.panDelta.x += delta.x;
+        this.panDelta.y += delta.y;
+
+        this.stopTweens();
+      }
+
+      previousTouch = e;
+    };
+
+    this.addEventListener("touchstart", touchStart);
+    this.addEventListener("touchend", touchEnd);
+    this.addEventListener("touchmove", touchMove);
+    this.addEventListener("drag", drag);
+    this.addEventListener("drop", drop);
+    this.addEventListener("mousewheel", scroll);
+    this.addEventListener("dblclick", dblclick);
+  }
+
+  setScene(scene) {
+    this.scene = scene;
+  }
+
+  stop() {
+    this.yawDelta = 0;
+    this.pitchDelta = 0;
+    this.radiusDelta = 0;
+    this.panDelta.set(0, 0);
+  }
+
+  zoomToLocation(mouse) {
+    let camera = this.scene.getActiveCamera();
+
+    let I = Utils.getMousePointCloudIntersection(
+      mouse,
+      camera,
+      this.viewer,
+      this.scene.pointclouds,
+      { pickClipped: true }
+    );
+
+    if (I === null) {
+      return;
+    }
+
+    let targetRadius = 0;
+    {
+      let minimumJumpDistance = 0.2;
+
+      let domElement = this.renderer.domElement;
+      let ray = Utils.mouseToRay(
+        mouse,
+        camera,
+        domElement.clientWidth,
+        domElement.clientHeight
+      );
+
+      let nodes = I.pointcloud.nodesOnRay(I.pointcloud.visibleNodes, ray);
+      let lastNode = nodes[nodes.length - 1];
+      let radius = lastNode.getBoundingSphere(new THREE.Sphere()).radius;
+      targetRadius = Math.min(this.scene.view.radius, radius);
+      targetRadius = Math.max(minimumJumpDistance, targetRadius);
+    }
+
+    let d = this.scene.view.direction.multiplyScalar(-1);
+    let cameraTargetPosition = new THREE.Vector3().addVectors(
+      I.location,
+      d.multiplyScalar(targetRadius)
+    );
+    // TODO Unused: let controlsTargetPosition = I.location;
+
+    let animationDuration = 600;
+    let easing = TWEEN.Easing.Quartic.Out;
+
+    {
+      // animate
+      let value = { x: 0 };
+      let tween = new TWEEN.Tween(value).to({ x: 1 }, animationDuration);
+      tween.easing(easing);
+      this.tweens.push(tween);
+
+      let startPos = this.scene.view.position.clone();
+      let targetPos = cameraTargetPosition.clone();
+      let startRadius = this.scene.view.radius;
+      let targetRadius = cameraTargetPosition.distanceTo(I.location);
+
+      tween.onUpdate(() => {
+        let t = value.x;
+        this.scene.view.position.x = (1 - t) * startPos.x + t * targetPos.x;
+        this.scene.view.position.y = (1 - t) * startPos.y + t * targetPos.y;
+        this.scene.view.position.z = (1 - t) * startPos.z + t * targetPos.z;
+
+        this.scene.view.radius = (1 - t) * startRadius + t * targetRadius;
+        this.viewer.setMoveSpeed(this.scene.view.radius);
+        document.dispatchEvent(this.changeEvent);
+      });
+
+      tween.onComplete(() => {
+        this.tweens = this.tweens.filter((e) => e !== tween);
+        document.dispatchEvent(this.changeEvent);
+      });
+
+      tween.start();
+    }
+  }
+
+  stopTweens() {
+    this.tweens.forEach((e) => e.stop());
+    this.tweens = [];
+  }
+
+  update(delta) {
+    let view = this.scene.view;
+
+    {
+      // apply rotation
+      let progression = Math.min(1, this.fadeFactor * delta);
+
+      let yaw = view.yaw;
+      let pitch = view.pitch;
+      let pivot = view.getPivot();
+
+      yaw -= progression * this.yawDelta;
+      pitch -= progression * this.pitchDelta;
+
+      view.yaw = yaw;
+      view.pitch = pitch;
+
+      let V = this.scene.view.direction.multiplyScalar(-view.radius);
+      let position = new THREE.Vector3().addVectors(pivot, V);
+
+      view.position.copy(position);
+    }
+
+    {
+      // apply pan
+      let progression = Math.min(1, this.fadeFactor * delta);
+      let panDistance = progression * view.radius * 3;
+
+      let px = -this.panDelta.x * panDistance;
+      let py = this.panDelta.y * panDistance;
+
+      view.pan(px, py);
+    }
+
+    {
+      // apply zoom
+      let progression = Math.min(1, this.fadeFactor * delta);
+
+      // let radius = view.radius + progression * this.radiusDelta * view.radius * 0.1;
+      let radius = view.radius + progression * this.radiusDelta;
+
+      let V = view.direction.multiplyScalar(-radius);
+      let position = new THREE.Vector3().addVectors(view.getPivot(), V);
+      view.radius = radius;
+
+      view.position.copy(position);
+    }
+
+    {
+      let speed = view.radius;
+      this.viewer.setMoveSpeed(speed);
+    }
+
+    {
+      // decelerate over time
+      let progression = Math.min(1, this.fadeFactor * delta);
+      let attenuation = Math.max(0, 1 - this.fadeFactor * delta);
+
+      this.yawDelta *= attenuation;
+      this.pitchDelta *= attenuation;
+      this.panDelta.multiplyScalar(attenuation);
+      // this.radiusDelta *= attenuation;
+      this.radiusDelta -= progression * this.radiusDelta;
+    }
+  }
+}
diff --git a/src/viewer/Scene.js b/src/viewer/Scene.js
index d0008ac8..f656bf6a 100644
--- a/src/viewer/Scene.js
+++ b/src/viewer/Scene.js
@@ -1,437 +1,450 @@
-
 import * as THREE from "../../libs/three.js/build/three.module.js";
-import {Annotation} from "../Annotation.js";
-import {CameraMode} from "../defines.js";
-import {View} from "./View.js";
-import {Utils} from "../utils.js";
-import {EventDispatcher} from "../EventDispatcher.js";
-
-
-export class Scene extends EventDispatcher{
-
-	constructor(){
-		super();
-
-		this.annotations = new Annotation();
-		
-		this.scene = new THREE.Scene();
-		this.sceneBG = new THREE.Scene();
-		this.scenePointCloud = new THREE.Scene();
-
-		this.cameraP = new THREE.PerspectiveCamera(this.fov, 1, 0.1, 1000*1000);
-		this.cameraO = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 1000*1000);
-		this.cameraVR = new THREE.PerspectiveCamera();
-		this.cameraBG = new THREE.Camera();
-		this.cameraScreenSpace = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
-		this.cameraMode = CameraMode.PERSPECTIVE;
-		this.overrideCamera = null;
-		this.pointclouds = [];
-
-		this.measurements = [];
-		this.profiles = [];
-		this.volumes = [];
-		this.polygonClipVolumes = [];
-		this.cameraAnimations = [];
-		this.orientedImages = [];
-		this.images360 = [];
-		this.geopackages = [];
-		
-		this.fpControls = null;
-		this.orbitControls = null;
-		this.earthControls = null;
-		this.geoControls = null;
-		this.deviceControls = null;
-		this.inputHandler = null;
-
-		this.view = new View();
-
-		this.directionalLight = null;
-
-		this.initialize();
-	}
-
-	estimateHeightAt (position) {
-		let height = null;
-		let fromSpacing = Infinity;
-
-		for (let pointcloud of this.pointclouds) {
-			if (pointcloud.root.geometryNode === undefined) {
-				continue;
-			}
-
-			let pHeight = null;
-			let pFromSpacing = Infinity;
-
-			let lpos = position.clone().sub(pointcloud.position);
-			lpos.z = 0;
-			let ray = new THREE.Ray(lpos, new THREE.Vector3(0, 0, 1));
-
-			let stack = [pointcloud.root];
-			while (stack.length > 0) {
-				let node = stack.pop();
-				let box = node.getBoundingBox();
-
-				let inside = ray.intersectBox(box);
-
-				if (!inside) {
-					continue;
-				}
-
-				let h = node.geometryNode.mean.z +
-					pointcloud.position.z +
-					node.geometryNode.boundingBox.min.z;
-
-				if (node.geometryNode.spacing <= pFromSpacing) {
-					pHeight = h;
-					pFromSpacing = node.geometryNode.spacing;
-				}
-
-				for (let index of Object.keys(node.children)) {
-					let child = node.children[index];
-					if (child.geometryNode) {
-						stack.push(node.children[index]);
-					}
-				}
-			}
-
-			if (height === null || pFromSpacing < fromSpacing) {
-				height = pHeight;
-				fromSpacing = pFromSpacing;
-			}
-		}
-
-		return height;
-	}
-	
-	getBoundingBox(pointclouds = this.pointclouds){
-		let box = new THREE.Box3();
-
-		this.scenePointCloud.updateMatrixWorld(true);
-		this.referenceFrame.updateMatrixWorld(true);
-
-		for (let pointcloud of pointclouds) {
-			pointcloud.updateMatrixWorld(true);
-
-			let pointcloudBox = pointcloud.pcoGeometry.tightBoundingBox ? pointcloud.pcoGeometry.tightBoundingBox : pointcloud.boundingBox;
-			let boxWorld = Utils.computeTransformedBoundingBox(pointcloudBox, pointcloud.matrixWorld);
-			box.union(boxWorld);
-		}
-
-		return box;
-	}
-
-	addPointCloud (pointcloud) {
-		this.pointclouds.push(pointcloud);
-		this.scenePointCloud.add(pointcloud);
-
-		this.dispatchEvent({
-			type: 'pointcloud_added',
-			pointcloud: pointcloud
-		});
-	}
-
-	addVolume (volume) {
-		this.volumes.push(volume);
-		this.dispatchEvent({
-			'type': 'volume_added',
-			'scene': this,
-			'volume': volume
-		});
-	}
-
-	addOrientedImages(images){
-		this.orientedImages.push(images);
-		this.scene.add(images.node);
-
-		this.dispatchEvent({
-			'type': 'oriented_images_added',
-			'scene': this,
-			'images': images
-		});
-	};
-
-	removeOrientedImages(images){
-		let index = this.orientedImages.indexOf(images);
-		if (index > -1) {
-			this.orientedImages.splice(index, 1);
-
-			this.dispatchEvent({
-				'type': 'oriented_images_removed',
-				'scene': this,
-				'images': images
-			});
-		}
-	};
-
-	add360Images(images){
-		this.images360.push(images);
-		this.scene.add(images.node);
-
-		this.dispatchEvent({
-			'type': '360_images_added',
-			'scene': this,
-			'images': images
-		});
-	}
-
-	remove360Images(images){
-		let index = this.images360.indexOf(images);
-		if (index > -1) {
-			this.images360.splice(index, 1);
-
-			this.dispatchEvent({
-				'type': '360_images_removed',
-				'scene': this,
-				'images': images
-			});
-		}
-	}
-
-	addGeopackage(geopackage){
-		this.geopackages.push(geopackage);
-		this.scene.add(geopackage.node);
-
-		this.dispatchEvent({
-			'type': 'geopackage_added',
-			'scene': this,
-			'geopackage': geopackage
-		});
-	};
-
-	removeGeopackage(geopackage){
-		let index = this.geopackages.indexOf(geopackage);
-		if (index > -1) {
-			this.geopackages.splice(index, 1);
-
-			this.dispatchEvent({
-				'type': 'geopackage_removed',
-				'scene': this,
-				'geopackage': geopackage
-			});
-		}
-	};
-
-	removeVolume (volume) {
-		let index = this.volumes.indexOf(volume);
-		if (index > -1) {
-			this.volumes.splice(index, 1);
-
-			this.dispatchEvent({
-				'type': 'volume_removed',
-				'scene': this,
-				'volume': volume
-			});
-		}
-	};
-
-	addCameraAnimation(animation) {
-		this.cameraAnimations.push(animation);
-		this.dispatchEvent({
-			'type': 'camera_animation_added',
-			'scene': this,
-			'animation': animation
-		});
-	};
-
-	removeCameraAnimation(animation){
-		let index = this.cameraAnimations.indexOf(volume);
-		if (index > -1) {
-			this.cameraAnimations.splice(index, 1);
-
-			this.dispatchEvent({
-				'type': 'camera_animation_removed',
-				'scene': this,
-				'animation': animation
-			});
-		}
-	};
-
-	addPolygonClipVolume(volume){
-		this.polygonClipVolumes.push(volume);
-		this.dispatchEvent({
-			"type": "polygon_clip_volume_added",
-			"scene": this,
-			"volume": volume
-		});
-	};
-	
-	removePolygonClipVolume(volume){
-		let index = this.polygonClipVolumes.indexOf(volume);
-		if (index > -1) {
-			this.polygonClipVolumes.splice(index, 1);
-			this.dispatchEvent({
-				"type": "polygon_clip_volume_removed",
-				"scene": this,
-				"volume": volume
-			});
-		}
-	};
-	
-	addMeasurement(measurement){
-		measurement.lengthUnit = this.lengthUnit;
-		measurement.lengthUnitDisplay = this.lengthUnitDisplay;
-		this.measurements.push(measurement);
-		this.dispatchEvent({
-			'type': 'measurement_added',
-			'scene': this,
-			'measurement': measurement
-		});
-	};
-
-	removeMeasurement (measurement) {
-		let index = this.measurements.indexOf(measurement);
-		if (index > -1) {
-			this.measurements.splice(index, 1);
-			this.dispatchEvent({
-				'type': 'measurement_removed',
-				'scene': this,
-				'measurement': measurement
-			});
-		}
-	}
-
-	addProfile (profile) {
-		this.profiles.push(profile);
-		this.dispatchEvent({
-			'type': 'profile_added',
-			'scene': this,
-			'profile': profile
-		});
-	}
-
-	removeProfile (profile) {
-		let index = this.profiles.indexOf(profile);
-		if (index > -1) {
-			this.profiles.splice(index, 1);
-			this.dispatchEvent({
-				'type': 'profile_removed',
-				'scene': this,
-				'profile': profile
-			});
-		}
-	}
-
-	removeAllMeasurements () {
-		while (this.measurements.length > 0) {
-			this.removeMeasurement(this.measurements[0]);
-		}
-
-		while (this.profiles.length > 0) {
-			this.removeProfile(this.profiles[0]);
-		}
-
-		while (this.volumes.length > 0) {
-			this.removeVolume(this.volumes[0]);
-		}
-	}
-
-	removeAllClipVolumes(){
-		let clipVolumes = this.volumes.filter(volume => volume.clip === true);
-		for(let clipVolume of clipVolumes){
-			this.removeVolume(clipVolume);
-		}
-
-		while(this.polygonClipVolumes.length > 0){
-			this.removePolygonClipVolume(this.polygonClipVolumes[0]);
-		}
-	}
-
-	getActiveCamera() {
-
-		if(this.overrideCamera){
-			return this.overrideCamera;
-		}
-
-		if(this.cameraMode === CameraMode.PERSPECTIVE){
-			return this.cameraP;
-		}else if(this.cameraMode === CameraMode.ORTHOGRAPHIC){
-			return this.cameraO;
-		}else if(this.cameraMode === CameraMode.VR){
-			return this.cameraVR;
-		}
-
-		return null;
-	}
-	
-	initialize(){
-		
-		this.referenceFrame = new THREE.Object3D();
-		this.referenceFrame.matrixAutoUpdate = false;
-		this.scenePointCloud.add(this.referenceFrame);
-
-		this.cameraP.up.set(0, 0, 1);
-		this.cameraP.position.set(1000, 1000, 1000);
-		this.cameraO.up.set(0, 0, 1);
-		this.cameraO.position.set(1000, 1000, 1000);
-		//this.camera.rotation.y = -Math.PI / 4;
-		//this.camera.rotation.x = -Math.PI / 6;
-		this.cameraScreenSpace.lookAt(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, 1, 0));
-		
-		this.directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
-		this.directionalLight.position.set( 10, 10, 10 );
-		this.directionalLight.lookAt( new THREE.Vector3(0, 0, 0));
-		this.scenePointCloud.add( this.directionalLight );
-		
-		let light = new THREE.AmbientLight( 0x555555 ); // soft white light
-		this.scenePointCloud.add( light );
-
-		{ // background
-			let texture = Utils.createBackgroundTexture(512, 512);
-
-			texture.minFilter = texture.magFilter = THREE.NearestFilter;
-			texture.minFilter = texture.magFilter = THREE.LinearFilter;
-			let bg = new THREE.Mesh(
-				new THREE.PlaneBufferGeometry(2, 2, 1),
-				new THREE.MeshBasicMaterial({
-					map: texture
-				})
-			);
-			bg.material.depthTest = false;
-			bg.material.depthWrite = false;
-			this.sceneBG.add(bg);
-		}
-
-		// { // lights
-		// 	{
-		// 		let light = new THREE.DirectionalLight(0xffffff);
-		// 		light.position.set(10, 10, 1);
-		// 		light.target.position.set(0, 0, 0);
-		// 		this.scene.add(light);
-		// 	}
-
-		// 	{
-		// 		let light = new THREE.DirectionalLight(0xffffff);
-		// 		light.position.set(-10, 10, 1);
-		// 		light.target.position.set(0, 0, 0);
-		// 		this.scene.add(light);
-		// 	}
-
-		// 	{
-		// 		let light = new THREE.DirectionalLight(0xffffff);
-		// 		light.position.set(0, -10, 20);
-		// 		light.target.position.set(0, 0, 0);
-		// 		this.scene.add(light);
-		// 	}
-		// }
-	}
-	
-	addAnnotation(position, args = {}){		
-		if(position instanceof Array){
-			args.position = new THREE.Vector3().fromArray(position);
-		} else if (position.x != null) {
-			args.position = position;
-		}
-		let annotation = new Annotation(args);
-		this.annotations.add(annotation);
-
-		return annotation;
-	}
-
-	getAnnotations () {
-		return this.annotations;
-	};
-
-	removeAnnotation(annotationToRemove) {
-		this.annotations.remove(annotationToRemove);
-	}
-};
+import { Annotation } from "../Annotation.js";
+import { CameraMode } from "../defines.js";
+import { View } from "./View.js";
+import { Utils } from "../utils.js";
+import { EventDispatcher } from "../EventDispatcher.js";
+
+export class Scene extends EventDispatcher {
+  constructor() {
+    super();
+
+    this.annotations = new Annotation();
+
+    this.scene = new THREE.Scene();
+    this.sceneBG = new THREE.Scene();
+    this.scenePointCloud = new THREE.Scene();
+
+    this.cameraP = new THREE.PerspectiveCamera(this.fov, 1, 0.1, 1000 * 1000);
+    this.cameraO = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 1000 * 1000);
+    this.cameraVR = new THREE.PerspectiveCamera();
+    this.cameraBG = new THREE.Camera();
+    this.cameraScreenSpace = new THREE.OrthographicCamera(
+      -1,
+      1,
+      1,
+      -1,
+      0.1,
+      10
+    );
+    this.cameraMode = CameraMode.PERSPECTIVE;
+    this.overrideCamera = null;
+    this.pointclouds = [];
+
+    this.measurements = [];
+    this.profiles = [];
+    this.volumes = [];
+    this.polygonClipVolumes = [];
+    this.cameraAnimations = [];
+    this.orientedImages = [];
+    this.images360 = [];
+    this.geopackages = [];
+
+    this.fpControls = null;
+    this.orbitControls = null;
+    this.earthControls = null;
+    this.geoControls = null;
+    this.deviceControls = null;
+    this.inputHandler = null;
+
+    this.view = new View();
+
+    this.directionalLight = null;
+
+    this.initialize();
+  }
+
+  estimateHeightAt(position) {
+    let height = null;
+    let fromSpacing = Infinity;
+
+    for (let pointcloud of this.pointclouds) {
+      if (pointcloud.root.geometryNode === undefined) {
+        continue;
+      }
+
+      let pHeight = null;
+      let pFromSpacing = Infinity;
+
+      let lpos = position.clone().sub(pointcloud.position);
+      lpos.z = 0;
+      let ray = new THREE.Ray(lpos, new THREE.Vector3(0, 0, 1));
+
+      let stack = [pointcloud.root];
+      while (stack.length > 0) {
+        let node = stack.pop();
+        let box = node.getBoundingBox();
+
+        let inside = ray.intersectBox(box);
+
+        if (!inside) {
+          continue;
+        }
+
+        let h =
+          node.geometryNode.mean.z +
+          pointcloud.position.z +
+          node.geometryNode.boundingBox.min.z;
+
+        if (node.geometryNode.spacing <= pFromSpacing) {
+          pHeight = h;
+          pFromSpacing = node.geometryNode.spacing;
+        }
+
+        for (let index of Object.keys(node.children)) {
+          let child = node.children[index];
+          if (child.geometryNode) {
+            stack.push(node.children[index]);
+          }
+        }
+      }
+
+      if (height === null || pFromSpacing < fromSpacing) {
+        height = pHeight;
+        fromSpacing = pFromSpacing;
+      }
+    }
+
+    return height;
+  }
+
+  getBoundingBox(pointclouds = this.pointclouds) {
+    let box = new THREE.Box3();
+
+    this.scenePointCloud.updateMatrixWorld(true);
+    this.referenceFrame.updateMatrixWorld(true);
+
+    for (let pointcloud of pointclouds) {
+      pointcloud.updateMatrixWorld(true);
+
+      let pointcloudBox = pointcloud.pcoGeometry.tightBoundingBox
+        ? pointcloud.pcoGeometry.tightBoundingBox
+        : pointcloud.boundingBox;
+      let boxWorld = Utils.computeTransformedBoundingBox(
+        pointcloudBox,
+        pointcloud.matrixWorld
+      );
+      box.union(boxWorld);
+    }
+
+    return box;
+  }
+
+  addPointCloud(pointcloud) {
+    this.pointclouds.push(pointcloud);
+    this.scenePointCloud.add(pointcloud);
+
+    this.dispatchEvent({
+      type: "pointcloud_added",
+      pointcloud: pointcloud,
+    });
+  }
+
+  addVolume(volume) {
+    this.volumes.push(volume);
+    this.dispatchEvent({
+      type: "volume_added",
+      scene: this,
+      volume: volume,
+    });
+  }
+
+  addOrientedImages(images) {
+    this.orientedImages.push(images);
+    this.scene.add(images.node);
+
+    this.dispatchEvent({
+      type: "oriented_images_added",
+      scene: this,
+      images: images,
+    });
+  }
+
+  removeOrientedImages(images) {
+    let index = this.orientedImages.indexOf(images);
+    if (index > -1) {
+      this.orientedImages.splice(index, 1);
+
+      this.dispatchEvent({
+        type: "oriented_images_removed",
+        scene: this,
+        images: images,
+      });
+    }
+  }
+
+  add360Images(images) {
+    this.images360.push(images);
+    this.scene.add(images.node);
+
+    this.dispatchEvent({
+      type: "360_images_added",
+      scene: this,
+      images: images,
+    });
+  }
+
+  remove360Images(images) {
+    let index = this.images360.indexOf(images);
+    if (index > -1) {
+      this.images360.splice(index, 1);
+
+      this.dispatchEvent({
+        type: "360_images_removed",
+        scene: this,
+        images: images,
+      });
+    }
+  }
+
+  addGeopackage(geopackage) {
+    this.geopackages.push(geopackage);
+    this.scene.add(geopackage.node);
+
+    this.dispatchEvent({
+      type: "geopackage_added",
+      scene: this,
+      geopackage: geopackage,
+    });
+  }
+
+  removeGeopackage(geopackage) {
+    let index = this.geopackages.indexOf(geopackage);
+    if (index > -1) {
+      this.geopackages.splice(index, 1);
+
+      this.dispatchEvent({
+        type: "geopackage_removed",
+        scene: this,
+        geopackage: geopackage,
+      });
+    }
+  }
+
+  removeVolume(volume) {
+    let index = this.volumes.indexOf(volume);
+    if (index > -1) {
+      this.volumes.splice(index, 1);
+
+      this.dispatchEvent({
+        type: "volume_removed",
+        scene: this,
+        volume: volume,
+      });
+    }
+  }
+
+  addCameraAnimation(animation) {
+    this.cameraAnimations.push(animation);
+    this.dispatchEvent({
+      type: "camera_animation_added",
+      scene: this,
+      animation: animation,
+    });
+  }
+
+  removeCameraAnimation(animation) {
+    let index = this.cameraAnimations.indexOf(volume);
+    if (index > -1) {
+      this.cameraAnimations.splice(index, 1);
+
+      this.dispatchEvent({
+        type: "camera_animation_removed",
+        scene: this,
+        animation: animation,
+      });
+    }
+  }
+
+  addPolygonClipVolume(volume) {
+    this.polygonClipVolumes.push(volume);
+    this.dispatchEvent({
+      type: "polygon_clip_volume_added",
+      scene: this,
+      volume: volume,
+    });
+  }
+
+  removePolygonClipVolume(volume) {
+    let index = this.polygonClipVolumes.indexOf(volume);
+    if (index > -1) {
+      this.polygonClipVolumes.splice(index, 1);
+      this.dispatchEvent({
+        type: "polygon_clip_volume_removed",
+        scene: this,
+        volume: volume,
+      });
+    }
+  }
+
+  addMeasurement(measurement) {
+    measurement.lengthUnit = this.lengthUnit;
+    measurement.lengthUnitDisplay = this.lengthUnitDisplay;
+    this.measurements.push(measurement);
+    this.dispatchEvent({
+      type: "measurement_added",
+      scene: this,
+      measurement: measurement,
+    });
+  }
+
+  removeMeasurement(measurement) {
+    let index = this.measurements.indexOf(measurement);
+    if (index > -1) {
+      this.measurements.splice(index, 1);
+      this.dispatchEvent({
+        type: "measurement_removed",
+        scene: this,
+        measurement: measurement,
+      });
+    }
+  }
+
+  addProfile(profile) {
+    this.profiles.push(profile);
+    this.dispatchEvent({
+      type: "profile_added",
+      scene: this,
+      profile: profile,
+    });
+  }
+
+  removeProfile(profile) {
+    let index = this.profiles.indexOf(profile);
+    if (index > -1) {
+      this.profiles.splice(index, 1);
+      this.dispatchEvent({
+        type: "profile_removed",
+        scene: this,
+        profile: profile,
+      });
+    }
+  }
+
+  removeAllMeasurements() {
+    while (this.measurements.length > 0) {
+      this.removeMeasurement(this.measurements[0]);
+    }
+
+    while (this.profiles.length > 0) {
+      this.removeProfile(this.profiles[0]);
+    }
+
+    while (this.volumes.length > 0) {
+      this.removeVolume(this.volumes[0]);
+    }
+  }
+
+  removeAllClipVolumes() {
+    let clipVolumes = this.volumes.filter((volume) => volume.clip === true);
+    for (let clipVolume of clipVolumes) {
+      this.removeVolume(clipVolume);
+    }
+
+    while (this.polygonClipVolumes.length > 0) {
+      this.removePolygonClipVolume(this.polygonClipVolumes[0]);
+    }
+  }
+
+  getActiveCamera() {
+    if (this.overrideCamera) {
+      return this.overrideCamera;
+    }
+
+    if (this.cameraMode === CameraMode.PERSPECTIVE) {
+      return this.cameraP;
+    } else if (this.cameraMode === CameraMode.ORTHOGRAPHIC) {
+      return this.cameraO;
+    } else if (this.cameraMode === CameraMode.VR) {
+      return this.cameraVR;
+    }
+
+    return null;
+  }
+
+  initialize() {
+    this.referenceFrame = new THREE.Object3D();
+    this.referenceFrame.matrixAutoUpdate = false;
+    this.scenePointCloud.add(this.referenceFrame);
+
+    this.cameraP.up.set(0, 0, 1);
+    this.cameraP.position.set(1000, 1000, 1000);
+    this.cameraO.up.set(0, 0, 1);
+    this.cameraO.position.set(1000, 1000, 1000);
+    //this.camera.rotation.y = -Math.PI / 4;
+    //this.camera.rotation.x = -Math.PI / 6;
+    this.cameraScreenSpace.lookAt(
+      new THREE.Vector3(0, 0, 0),
+      new THREE.Vector3(0, 0, -1),
+      new THREE.Vector3(0, 1, 0)
+    );
+
+    this.directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
+    this.directionalLight.position.set(10, 10, 10);
+    this.directionalLight.lookAt(new THREE.Vector3(0, 0, 0));
+    this.scenePointCloud.add(this.directionalLight);
+
+    let light = new THREE.AmbientLight(0x555555); // soft white light
+    this.scenePointCloud.add(light);
+
+    {
+      // background
+      let texture = Utils.createBackgroundTexture(512, 512);
+
+      texture.minFilter = texture.magFilter = THREE.NearestFilter;
+      texture.minFilter = texture.magFilter = THREE.LinearFilter;
+      let bg = new THREE.Mesh(
+        new THREE.PlaneBufferGeometry(2, 2, 1),
+        new THREE.MeshBasicMaterial({
+          map: texture,
+        })
+      );
+      bg.material.depthTest = false;
+      bg.material.depthWrite = false;
+      this.sceneBG.add(bg);
+    }
+
+    // { // lights
+    // 	{
+    // 		let light = new THREE.DirectionalLight(0xffffff);
+    // 		light.position.set(10, 10, 1);
+    // 		light.target.position.set(0, 0, 0);
+    // 		this.scene.add(light);
+    // 	}
+
+    // 	{
+    // 		let light = new THREE.DirectionalLight(0xffffff);
+    // 		light.position.set(-10, 10, 1);
+    // 		light.target.position.set(0, 0, 0);
+    // 		this.scene.add(light);
+    // 	}
+
+    // 	{
+    // 		let light = new THREE.DirectionalLight(0xffffff);
+    // 		light.position.set(0, -10, 20);
+    // 		light.target.position.set(0, 0, 0);
+    // 		this.scene.add(light);
+    // 	}
+    // }
+  }
+
+  addAnnotation(position, args = {}) {
+    if (position instanceof Array) {
+      args.position = new THREE.Vector3().fromArray(position);
+    } else if (position.x != null) {
+      args.position = position;
+    }
+    let annotation = new Annotation(args);
+    this.annotations.add(annotation);
+
+    return annotation;
+  }
+
+  getAnnotations() {
+    return this.annotations;
+  }
+
+  removeAnnotation(annotationToRemove) {
+    this.annotations.remove(annotationToRemove);
+  }
+}
diff --git a/src/viewer/map.js b/src/viewer/map.js
index 0979c607..314ac1e5 100644
--- a/src/viewer/map.js
+++ b/src/viewer/map.js
@@ -305,7 +305,7 @@ export class MapView{
 		};
 
 		this.on360ImagesAdded = e => {
-			this.addImages360(e.images);
+			// this.addImages360(e.images);
 		};
 
 		this.onAnnotationAdded = e => {
diff --git a/src/viewer/viewer.js b/src/viewer/viewer.js
index baf1fb1b..bb07592d 100644
--- a/src/viewer/viewer.js
+++ b/src/viewer/viewer.js
@@ -788,6 +788,7 @@ export class Viewer extends EventDispatcher{
 	};
 
 	zoomTo(node, factor, animationDuration = 0){
+		let changeEvent = new CustomEvent("camerachange");
 		let view = this.scene.view;
 
 		let camera = this.scene.cameraP.clone();
@@ -825,6 +826,7 @@ export class Viewer extends EventDispatcher{
 
 			tween.onUpdate(() => {
 				view.position.copy(pos);
+				document.dispatchEvent(changeEvent);
 			});
 
 			tween.start();
@@ -836,10 +838,12 @@ export class Viewer extends EventDispatcher{
 			tween.easing(easing);
 			tween.onUpdate(() => {
 				view.lookAt(target);
+				document.dispatchEvent(changeEvent);
 			});
 			tween.onComplete(() => {
 				view.lookAt(target);
 				this.dispatchEvent({type: 'focusing_finished', target: this});
+				document.dispatchEvent(changeEvent);
 			});
 
 			this.dispatchEvent({type: 'focusing_started', target: this});
@@ -1205,118 +1209,118 @@ export class Viewer extends EventDispatcher{
 		}
 
 		let viewer = this;
-		let sidebarContainer = $('#potree_sidebar_container');
-		sidebarContainer.load(new URL(Potree.scriptPath + '/sidebar.html').href, () => {
-			sidebarContainer.css('width', '300px');
-			sidebarContainer.css('height', '100%');
-
-			let imgMenuToggle = document.createElement('img');
-			imgMenuToggle.src = new URL(Potree.resourcePath + '/icons/menu_button.svg').href;
-			imgMenuToggle.onclick = this.toggleSidebar;
-			imgMenuToggle.classList.add('potree_menu_toggle');
-
-			let imgMapToggle = document.createElement('img');
-			imgMapToggle.src = new URL(Potree.resourcePath + '/icons/map_icon.png').href;
-			imgMapToggle.style.display = 'none';
-			imgMapToggle.onclick = e => { this.toggleMap(); };
-			imgMapToggle.id = 'potree_map_toggle';
+		// let sidebarContainer = $('#potree_sidebar_container');
+		// sidebarContainer.load(new URL(Potree.scriptPath + '/sidebar.html').href, () => {
+		// 	sidebarContainer.css('width', '300px');
+		// 	sidebarContainer.css('height', '100%');
+
+		// 	let imgMenuToggle = document.createElement('img');
+		// 	imgMenuToggle.src = new URL(Potree.resourcePath + '/icons/menu_button.svg').href;
+		// 	imgMenuToggle.onclick = this.toggleSidebar;
+		// 	imgMenuToggle.classList.add('potree_menu_toggle');
+
+		// 	let imgMapToggle = document.createElement('img');
+		// 	imgMapToggle.src = new URL(Potree.resourcePath + '/icons/map_icon.png').href;
+		// 	imgMapToggle.style.display = 'none';
+		// 	imgMapToggle.onclick = e => { this.toggleMap(); };
+		// 	imgMapToggle.id = 'potree_map_toggle';
 
 			
 
-			let elButtons = $("#potree_quick_buttons").get(0);
+		// 	let elButtons = $("#potree_quick_buttons").get(0);
 
-			elButtons.append(imgMenuToggle);
-			elButtons.append(imgMapToggle);
+		// 	elButtons.append(imgMenuToggle);
+		// 	elButtons.append(imgMapToggle);
 
 
-			VRButton.createButton(this.renderer).then(vrButton => {
+		// 	VRButton.createButton(this.renderer).then(vrButton => {
 
-				if(vrButton == null){
-					console.log("VR not supported or active.");
+		// 		if(vrButton == null){
+		// 			console.log("VR not supported or active.");
 
-					return;
-				}
+		// 			return;
+		// 		}
 
-				this.renderer.xr.enabled = true;
+		// 		this.renderer.xr.enabled = true;
 
-				let element = vrButton.element;
+		// 		let element = vrButton.element;
 
-				element.style.position = "";
-				element.style.bottom = "";
-				element.style.left = "";
-				element.style.margin = "4px";
-				element.style.fontSize = "100%";
-				element.style.width = "2.5em";
-				element.style.height = "2.5em";
-				element.style.padding = "0";
-				element.style.textShadow = "black 2px 2px 2px";
-				element.style.display = "block";
+		// 		element.style.position = "";
+		// 		element.style.bottom = "";
+		// 		element.style.left = "";
+		// 		element.style.margin = "4px";
+		// 		element.style.fontSize = "100%";
+		// 		element.style.width = "2.5em";
+		// 		element.style.height = "2.5em";
+		// 		element.style.padding = "0";
+		// 		element.style.textShadow = "black 2px 2px 2px";
+		// 		element.style.display = "block";
 
-				elButtons.append(element);
+		// 		elButtons.append(element);
 
-				vrButton.onStart(() => {
-					this.dispatchEvent({type: "vr_start"});
-				});
+		// 		vrButton.onStart(() => {
+		// 			this.dispatchEvent({type: "vr_start"});
+		// 		});
 
-				vrButton.onEnd(() => {
-					this.dispatchEvent({type: "vr_end"});
-				});
-			});
+		// 		vrButton.onEnd(() => {
+		// 			this.dispatchEvent({type: "vr_end"});
+		// 		});
+		// 	});
 
-			this.mapView = new MapView(this);
-			this.mapView.init();
-
-			i18n.init({
-				lng: 'en',
-				resGetPath: Potree.resourcePath + '/lang/__lng__/__ns__.json',
-				preload: ['en', 'fr', 'de', 'jp', 'se', 'es', 'zh', 'it','ca'],
-				getAsync: true,
-				debug: false
-			}, function (t) {
-				// Start translation once everything is loaded
-				$('body').i18n();
-			});
+		// 	this.mapView = new MapView(this);
+		// 	this.mapView.init();
 
-			$(() => {
-				//initSidebar(this);
-				let sidebar = new Sidebar(this);
-				sidebar.init();
+		// 	i18n.init({
+		// 		lng: 'en',
+		// 		resGetPath: Potree.resourcePath + '/lang/__lng__/__ns__.json',
+		// 		preload: ['en', 'fr', 'de', 'jp', 'se', 'es'],
+		// 		getAsync: true,
+		// 		debug: false
+		// 	}, function (t) {
+		// 		// Start translation once everything is loaded
+		// 		$('body').i18n();
+		// 	});
 
-				this.sidebar = sidebar;
+		// 	$(() => {
+		// 		//initSidebar(this);
+		// 		let sidebar = new Sidebar(this);
+		// 		sidebar.init();
 
-				//if (callback) {
-				//	$(callback);
-				//}
+		// 		this.sidebar = sidebar;
 
-				let elProfile = $('<div>').load(new URL(Potree.scriptPath + '/profile.html').href, () => {
-					$(document.body).append(elProfile.children());
-					this.profileWindow = new ProfileWindow(this);
-					this.profileWindowController = new ProfileWindowController(this);
+		// 		//if (callback) {
+		// 		//	$(callback);
+		// 		//}
 
-					$('#profile_window').draggable({
-						handle: $('#profile_titlebar'),
-						containment: $(document.body)
-					});
-					$('#profile_window').resizable({
-						containment: $(document.body),
-						handles: 'n, e, s, w'
-					});
+		// 		let elProfile = $('<div>').load(new URL(Potree.scriptPath + '/profile.html').href, () => {
+		// 			$(document.body).append(elProfile.children());
+		// 			this.profileWindow = new ProfileWindow(this);
+		// 			this.profileWindowController = new ProfileWindowController(this);
+
+		// 			$('#profile_window').draggable({
+		// 				handle: $('#profile_titlebar'),
+		// 				containment: $(document.body)
+		// 			});
+		// 			$('#profile_window').resizable({
+		// 				containment: $(document.body),
+		// 				handles: 'n, e, s, w'
+		// 			});
 
-					$(() => {
+		// 			$(() => {
 						this.guiLoaded = true;
 						for(let task of this.guiLoadTasks){
 							task();
 						}
 
-					});
-				});
+		// 			});
+		// 		});
 
 				
 
-			});
+		// 	});
 
 			
-		});
+		// });
 
 		return this.promiseGuiLoaded();
 	}
@@ -1349,14 +1353,14 @@ export class Viewer extends EventDispatcher{
 
 				const file = item.getAsFile();
 
-				const isJson5 = file.name.toLowerCase().endsWith(".json5");
+				const isJson = file.name.toLowerCase().endsWith(".json");
 				const isGeoPackage = file.name.toLowerCase().endsWith(".gpkg");
 
-				if(isJson5){
+				if(isJson){
 					try{
 
 						const text = await file.text();
-						const json = JSON5.parse(text);
+						const json = JSON.parse(text);
 
 						if(json.type === "Potree"){
 							Potree.loadProject(viewer, json);
-- 
2.38.1.windows.1


From 08c0fbff3c3ffae93ac75c328506e9ce3465b316 Mon Sep 17 00:00:00 2001
From: SathyaKrishna Vanama <sathyakrishna.vanama@constructn.ai>
Date: Wed, 28 Jun 2023 16:40:38 +0530
Subject: [PATCH 02/11] ring geometry added to the potree and pitch correction
 also done

---
 src/modules/Images360/Images360.js           | 672 ++++++++++---------
 src/modules/OrientedImages/OrientedImages.js |  21 +-
 src/navigation/OrbitControls.js              |   9 +
 3 files changed, 390 insertions(+), 312 deletions(-)

diff --git a/src/modules/Images360/Images360.js b/src/modules/Images360/Images360.js
index 669de80b..0db1c26d 100644
--- a/src/modules/Images360/Images360.js
+++ b/src/modules/Images360/Images360.js
@@ -1,305 +1,373 @@
+
 import * as THREE from "../../../libs/three.js/build/three.module.js";
 import { EventDispatcher } from "../../EventDispatcher.js";
+class Image360{
+
+	constructor(file, thumbnail, longitude, latitude, altitude, course, pitch, roll){
+		this.file = file;
+		this.thumbnail = thumbnail;
+		this.longitude = longitude;
+		this.latitude = latitude;
+		this.altitude = altitude;
+		this.course = course;
+		this.pitch = pitch;
+		this.roll = roll;
+		this.mesh = null;
+	}
+};
+
+export class Images360 extends EventDispatcher{
+
+	constructor(viewer){
+		super();
+
+		this.viewer = viewer;
+
+		this.selectingEnabled = true;
+
+		this.images = [];
+		this.node = new THREE.Object3D();
+
+		this.sphere = new THREE.Mesh(new THREE.SphereGeometry(1, 128, 128), new THREE.MeshBasicMaterial({side: THREE.BackSide}));
+		this.sphere.visible = false;
+		this.sphere.scale.set(-1000, 1000, 1000);
+		this.focus = this.focus.bind(this);
+		this.unfocus = this.unfocus.bind(this);
+		this.node.add(this.sphere);
+		this._visible = true;
+		this.focusedImage = null;
+		this.currentlyHovered = null;
+		this.previousView = {
+			controls: null,
+			position: null,
+			target: null,
+		};
+		this.raycaster = new THREE.Raycaster();
+		this.hoverMaterial = new THREE.MeshBasicMaterial({side: THREE.DoubleSide});
+		this.sm = new THREE.MeshBasicMaterial({side: THREE.DoubleSide,color:'#FF843F'});
+		
+		viewer.addEventListener("update", () => {
+			this.update(viewer);
+		});
+		viewer.inputHandler.addInputListener(this);
+
+		this.addEventListener("mousedown", () => {
+			if(this.currentlyHovered && this.currentlyHovered.image360){
+				this.focus(this.currentlyHovered.image360);
+			}
+		});
+		this.addEventListener("touchend", () => {
+			if(this.currentlyHovered && this.currentlyHovered.image360){
+				this.focus(this.currentlyHovered.image360);
+			}
+		});
+	};
+
+	set visible(visible){
+		if(this._visible === visible){
+			return;
+		}
+
+
+		for(const image of this.images){
+			image.mesh.visible = visible && (this.focusedImage == null);
+		}
+
+		this.sphere.visible = visible && (this.focusedImage != null);
+		this._visible = visible;
+		this.dispatchEvent({
+			type: "visibility_changed",
+			images: this,
+		});
+	}
+
+	get visible(){
+		return this._visible;
+	}
+
+	focus(image360, sendEvent = true, inTarget = null){
+		if(this.focusedImage !== null){
+			this.unfocus();
+		}
+		this.viewer.setEDLOpacity(0);
+		if (sendEvent) {
+			const event = new CustomEvent("panoLoad", {
+				detail: {
+					viewer: this.viewer.canvasId,
+					image: image360
+				}
+			});
+			document.dispatchEvent(event);
+		}
+
+		this.previousView = {
+			controls: this.viewer.controls,
+			position: this.viewer.scene.view.position.clone(),
+			target: this.viewer.scene.view.getPivot(),
+		};
+		this.viewer.setControls(this.viewer.orbitControls);
+		this.viewer.orbitControls.doubleClockZoomEnabled = false;
+		let index = this.images.findIndex( element => {
+		if (element.file === image360.file) {
+		return true;
+		}
+		});
+		
+		for(let image of this.images){
+			
+			image.mesh.visible = false;
+		}
+		
+		if(index != 0)
+		{
+
+			let i = index - 1
+			let current = new THREE.Vector3(this.images[index].position[0], this.images[index].position[1], this.images[index].position[2])
+			let next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
+			let dist = current.distanceTo(next)
+			while(dist < 0.5 && i > 0) {
+				i--
+				next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
+				dist = current.distanceTo(next)
+			}
+			this.images[i].mesh.visible = true
+			
+		}
+			let i = index + 1
+			let current = new THREE.Vector3(this.images[index].position[0], this.images[index].position[1], this.images[index].position[2])
+			let next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
+			let dist = current.distanceTo(next)
+			while(dist < 0.5) {
+				i++
+				next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
+				dist = current.distanceTo(next)
+			}
+			this.images[i].mesh.visible = true
+		
+		this.selectingEnabled = true;
+		this.sphere.visible = false;
+		this.load(image360).then( () => {
+			this.sphere.visible = true;
+			this.sphere.material.map = image360.texture;
+			this.sphere.material.needsUpdate = true;
+		});
+			let {course, pitch, roll} = image360;
+			this.sphere.rotation.set(
+			THREE.Math.degToRad(course),
+			THREE.Math.degToRad(pitch),
+			THREE.Math.degToRad(roll),
+			"XYZ"
+		);
+		this.sphere.position.set(...image360.position);
+		let target = new THREE.Vector3(...image360.position);
+		let dir = target.clone().sub(this.viewer.scene.view.position).normalize();
+		let move = dir.multiplyScalar(0.000001);
+		let newCamPos = target.clone().sub(move);
+		this.viewer.scene.view.setView(
+			newCamPos, 
+			target,
+			500,
+			() => {
+				if (inTarget && inTarget.pitch) {
+					this.viewer.scene.view.pitch = inTarget.pitch
+					this.viewer.scene.view.yaw = inTarget.yaw
+				}
+			}
+		);
+
+		this.focusedImage = image360;
+
+	}
+
+	unfocus(sendEvent = true){
+		this.selectingEnabled = true;
+		this.viewer.setEDLOpacity(1);
+		let image = this.focusedImage;
+		if(image === null){
+			return;
+		}
+		this.sphere.material.map = null;
+		this.sphere.material.needsUpdate = true;
+		this.sphere.visible = false;
+		this.sphere.position.set(this.sphere.position - [...this.images[0].position]);
+
+		let pos = this.viewer.scene.view.position;
+		let target = this.viewer.scene.view.getPivot();
+		let dir = target.clone().sub(pos).normalize();
+		let move = dir.multiplyScalar(10);
+		let newCamPos = target.clone().sub(move);
+
+		this.viewer.orbitControls.doubleClockZoomEnabled = true;
+		this.viewer.setControls(this.previousView.controls);
+		this.focusedImage = null;
+		
+		if (sendEvent) {
+			const event = new CustomEvent("panoUnload", {
+				detail: {
+					viewer: this.viewer.canvasId
+				}
+			});
+			document.dispatchEvent(event);
+		}
+
+	}
+
+	load(image360){
+		let resolved = false;
+		return new Promise(resolve => {
+			if (image360.texture) {
+				resolve(null);
+			} else {
+				new THREE.TextureLoader().load(image360.thumbnail,
+					texture => {
+							//var sphereMaterial = new MeshBasicMaterial({ map: texture, side: DoubleSide });
+                            //image360.texture = sphereMaterial;
+							image360.texture = texture;
+							resolved = true;
+							resolve(null);
+							loadOrgImage.bind(this)();
+						},
+					undefined,
+					err => {
+						loadOrgImage.bind(this)();
+					});
+				let loadOrgImage = function () {
+
+					new THREE.TextureLoader().load(image360.file,
+						texture => {
+								//var sphereMaterial = new MeshBasicMaterial({ map: texture, side: DoubleSide });
+                            	//image360.texture = sphereMaterial;
+								image360.texture = texture;
+								this.sphere.visible = true;
+								this.sphere.material.map = image360.texture;
+								this.sphere.material.needsUpdate = true;
+								if (!resolved) {
+									resolve(null);
+								}
+							});
+				}
+
+			}
+		});
+
+	}
+
+	handleHovering(){
+		let mouse = this.viewer.inputHandler.mouse;
+		let camera = this.viewer.scene.getActiveCamera();
+		let domElement = this.viewer.renderer.domElement;
+		let ray = Potree.Utils.mouseToRay(mouse, camera, domElement.clientWidth, domElement.clientHeight);
+		this.raycaster.ray.copy(ray);
+		let intersections = this.raycaster.intersectObjects(this.images.map(image=>{
+			return image.mesh}));
+		if(intersections.length === 0){
+			return;
+		}
+		let intersection = intersections[0];
+		if(intersection.object.image360.mesh.visible===true)
+		{
+		this.currentlyHovered = intersection.object;
+		this.currentlyHovered.material = this.hoverMaterial;
+		}
+		
+	}
+
+	update(){
+
+		let {viewer} = this;
+
+		if(this.currentlyHovered){
+			this.currentlyHovered.material = this.sm;
+			this.currentlyHovered = null;
+		}
+
+		if(this.selectingEnabled){
+			this.handleHovering();
+		}
+
+	}
+};
+
+
+export class Images360Loader{
+
+	static async load(url, imgsUrl, viewer, tm_data, params = {}){
+
+		if(!params.transform){
+			params.transform = {
+				forward: a => a,
+			};
+		}
+
+		let tmatrix, toffset;
+		
+		tmatrix = tm_data.tm;
+		toffset = tm_data.offset;
+		
+		let response = await fetch(url);
+		let text = await response.text();
+		let imgData = JSON.parse(text);
+
+		let images360 = new Images360(viewer);
+
+		Object.keys(imgData).forEach(imgName => {
+			let raw_position = imgData[imgName].position;
+			let rotation = imgData[imgName].rotation;
+			
+			const pos = new THREE.Vector4(raw_position[0], raw_position[1], raw_position[2], 1);
+			pos.applyMatrix4(tmatrix);
+			const long = parseFloat(pos.x - toffset[0]);
+			const lat = parseFloat(pos.y - toffset[1]);
+			const alt = parseFloat((pos.z - toffset[2]));
+			const course = parseFloat(rotation[0]);
+			const pitch = parseFloat(rotation[1]);
+			const roll = parseFloat(rotation[2]);
+
+			let file = `${imgsUrl}/${imgName}`;
+			let thumbnail = `${imgsUrl}/thumbnails/${imgName}`;
+			let image360 = new Image360(file, thumbnail, long, lat, alt, course, pitch, roll);
+
+			let position = [long, lat, alt];
+			image360.position = position;
+
+			images360.images.push(image360);
+		});
+
+		images360.images.sort(function (a, b) {
+			const getFileNumber = (file) => {
+				const numberPattern = /\d+/g;
+				const numbers = file.match(numberPattern);
+				if (numbers) {
+				return numbers.map((num) => num.padStart(10, '0')).join('');
+				}
+				return file;
+			};
+
+			const fileANumber = getFileNumber(a.file);
+			const fileBNumber = getFileNumber(b.file);
+			return fileANumber.localeCompare(fileBNumber);
+		});
+		
+		Images360Loader.createSceneNodes(images360, params.transform);
+
+		return images360;
+
+	}
+
+	static createSceneNodes(images360){
+
+		for(let image360 of images360.images){
+			let {longitude, latitude, altitude} = image360;
+			let mesh = new THREE.Mesh(new THREE.RingGeometry( 0.5, 1, 32 ), new THREE.MeshBasicMaterial({side: THREE.DoubleSide, color:'#FF843F'}));
+			mesh.position.set(longitude, latitude, altitude - 2.0);
+			mesh.scale.set(1, 1, 1);
+			mesh.material.transparent = true;
+			mesh.material.opacity = 0.75;
+			mesh.image360 = image360;
+			images360.node.add(mesh);
+			image360.mesh = mesh;
+		}
+	}
+};
+
 
-class Image360 {
-  constructor(
-    file,
-    thumbnail,
-    longitude,
-    latitude,
-    altitude,
-    course,
-    pitch,
-    roll
-  ) {
-    this.file = file;
-    this.thumbnail = thumbnail;
-    this.longitude = longitude;
-    this.latitude = latitude;
-    this.altitude = altitude;
-    this.course = course;
-    this.pitch = pitch;
-    this.roll = roll;
-  }
-}
-
-export class Images360 extends EventDispatcher {
-  constructor(viewer) {
-    super();
-
-    this.viewer = viewer;
-
-    this.selectingEnabled = true;
-
-    this.images = [];
-    this.node = new THREE.Object3D();
-
-    this.sphere = new THREE.Mesh(
-      new THREE.SphereGeometry(1, 128, 128),
-      new THREE.MeshBasicMaterial({ side: THREE.BackSide })
-    );
-    this.sphere.visible = false;
-    this.sphere.scale.set(-1000, 1000, 1000);
-
-    this.focus = this.focus.bind(this);
-    this.unfocus = this.unfocus.bind(this);
-    this.node.add(this.sphere);
-    this._visible = true;
-
-    this.focusedImage = null;
-    this.currentlyHovered = null;
-    this.previousView = {
-      controls: null,
-      position: null,
-      target: null,
-    };
-    this.raycaster = new THREE.Raycaster();
-    this.hoverMaterial = new THREE.MeshBasicMaterial({
-      side: THREE.BackSide,
-      color: 0xff0000,
-    });
-    this.sm = new THREE.MeshBasicMaterial({ side: THREE.BackSide });
-
-    // viewer.addEventListener("update", () => {
-    //   this.update(viewer);
-    // });
-    viewer.inputHandler.addInputListener(this);
-
-    this.addEventListener("mousedown", () => {
-      if (this.currentlyHovered && this.currentlyHovered.image360) {
-        this.focus(this.currentlyHovered.image360);
-      }
-    });
-  }
-
-  set visible(visible) {
-    if (this._visible === visible) {
-      return;
-    }
-    this.sphere.visible = visible && this.focusedImage != null;
-    this._visible = visible;
-    this.dispatchEvent({
-      type: "visibility_changed",
-      images: this,
-    });
-  }
-
-  get visible() {
-    return this._visible;
-  }
-
-  focus(image360, sendEvent = true, inTarget = null) {
-    if (this.focusedImage !== null) {
-      this.unfocus();
-    }
-    this.viewer.setEDLOpacity(0);
-    if (sendEvent) {
-      const event = new CustomEvent("panoLoad", {
-        detail: {
-          viewer: this.viewer.canvasId,
-          image: image360,
-        },
-      });
-      document.dispatchEvent(event);
-    }
-
-    this.previousView = {
-      controls: this.viewer.controls,
-      position: this.viewer.scene.view.position.clone(),
-      target: this.viewer.scene.view.getPivot(),
-    };
-
-    this.viewer.setControls(this.viewer.orbitControls);
-    this.viewer.orbitControls.doubleClockZoomEnabled = false;
-
-    this.selectingEnabled = false;
-
-    this.sphere.visible = false;
-
-    this.load(image360).then(() => {
-      this.sphere.visible = true;
-      this.sphere.material.map = image360.texture;
-      this.sphere.material.needsUpdate = true;
-    });
-
-    // orientation
-    let { course, pitch, roll } = image360;
-
-    this.sphere.rotation.set(
-      THREE.Math.degToRad(course),
-      THREE.Math.degToRad(pitch),
-      THREE.Math.degToRad(roll),
-      "XYZ"
-    );
-
-    this.sphere.position.set(...image360.position);
-
-    let target = new THREE.Vector3(...image360.position);
-    let dir = target.clone().sub(this.viewer.scene.view.position).normalize();
-    let move = dir.multiplyScalar(0.000001);
-    let newCamPos = target.clone().sub(move);
-
-    this.viewer.scene.view.setView(newCamPos, target, 500, () => {
-      if (inTarget && inTarget.pitch) {
-        this.viewer.scene.view.pitch = inTarget.pitch;
-        this.viewer.scene.view.yaw = inTarget.yaw;
-      }
-    });
-
-    this.focusedImage = image360;
-  }
-
-  unfocus(sendEvent = true) {
-    this.selectingEnabled = true;
-    this.viewer.setEDLOpacity(1);
-
-    let image = this.focusedImage;
-
-    if (image === null) {
-      return;
-    }
-    delete image.texture;
-    this.sphere.material.map = null;
-    this.sphere.material.needsUpdate = true;
-    this.sphere.visible = false;
-    this.viewer.orbitControls.doubleClockZoomEnabled = true;
-    this.viewer.setControls(this.previousView.controls);
-
-    this.focusedImage = null;
-
-    if (sendEvent) {
-      const event = new CustomEvent("panoUnload", {
-        detail: {
-          viewer: this.viewer.canvasId,
-        },
-      });
-      document.dispatchEvent(event);
-    }
-  }
-
-  load(image360) {
-    let resolved = false;
-    return new Promise((resolve) => {
-      if (image360.texture) {
-        resolve(null);
-      } else {
-        new THREE.TextureLoader().load(
-          image360.thumbnail,
-          (texture) => {
-            image360.texture = texture;
-            resolved = true;
-            resolve(null);
-            loadOrgImage.bind(this)();
-          },
-          undefined,
-          (err) => {
-            loadOrgImage.bind(this)();
-          }
-        );
-        let loadOrgImage = function () {
-          new THREE.TextureLoader().load(image360.file, (texture) => {
-            image360.texture = texture;
-            this.sphere.visible = true;
-            this.sphere.material.map = image360.texture;
-            this.sphere.material.needsUpdate = true;
-            if (!resolved) {
-              resolve(null);
-            }
-            // }
-          });
-        };
-      }
-    });
-  }
-
-  //   handleHovering() {
-  //     let mouse = this.viewer.inputHandler.mouse;
-  //     let camera = this.viewer.scene.getActiveCamera();
-  //     let domElement = this.viewer.renderer.domElement;
-
-  //     let ray = Potree.Utils.mouseToRay(
-  //       mouse,
-  //       camera,
-  //       domElement.clientWidth,
-  //       domElement.clientHeight
-  //     );
-
-  //     this.raycaster.ray.copy(ray);
-  //     let intersections = this.raycaster.intersectObjects(this.node.children);
-
-  //     if (intersections.length === 0) {
-  //       return;
-  //     }
-
-  //     let intersection = intersections[0];
-  //     this.currentlyHovered = intersection.object;
-  //     this.currentlyHovered.material = this.hoverMaterial;
-  //   }
-
-  //   update() {
-  //     let { viewer } = this;
-
-  //     if (this.currentlyHovered) {
-  //       this.currentlyHovered.material = this.sm;
-  //       this.currentlyHovered = null;
-  //     }
-
-  //     if (this.selectingEnabled) {
-  //       // this.handleHovering();
-  //     }
-  //   }
-}
-
-export class Images360Loader {
-  static async load(url, imgsUrl, viewer, tm_data) {
-    let tmatrix, toffset;
-
-    tmatrix = tm_data.tm;
-    toffset = tm_data.offset;
-
-    let response = await fetch(url);
-    let text = await response.text();
-    let imgData = JSON.parse(text);
-
-    let images360 = new Images360(viewer);
-    Object.keys(imgData).forEach((imgName) => {
-      let raw_position = imgData[imgName].position;
-      let rotation = imgData[imgName].rotation;
-
-      const pos = new THREE.Vector4(
-        raw_position[0],
-        raw_position[1],
-        raw_position[2],
-        1
-      );
-      pos.applyMatrix4(tmatrix);
-
-      const long = parseFloat(pos.x - toffset[0]);
-      const lat = parseFloat(pos.y - toffset[1]);
-      const alt = parseFloat(pos.z - toffset[2]);
-      const course = parseFloat(rotation[0]);
-      const pitch = parseFloat(rotation[1]);
-      const roll = parseFloat(rotation[2]);
-
-      let file = `${imgsUrl}/${imgName}`;
-      let thumbnail = `${imgsUrl}/thumbnails/${imgName}`;
-      let image360 = new Image360(
-        file,
-        thumbnail,
-        long,
-        lat,
-        alt,
-        course,
-        pitch,
-        roll
-      );
-
-      let position = [long, lat, alt];
-      image360.position = position;
-
-      images360.images.push(image360);
-    });
-
-    return images360;
-  }
-}
diff --git a/src/modules/OrientedImages/OrientedImages.js b/src/modules/OrientedImages/OrientedImages.js
index 0d95c86e..4da9cd47 100644
--- a/src/modules/OrientedImages/OrientedImages.js
+++ b/src/modules/OrientedImages/OrientedImages.js
@@ -390,15 +390,7 @@ export class OrientedImageLoader {
     const moveToImage = async (image, sendEvent = true) => {
       viewer.controls.enabled = false;
 
-      if (sendEvent) {
-        const event = new CustomEvent("imageLoad", {
-          detail: {
-            viewer: viewer.canvasId,
-            image,
-          },
-        });
-        document.dispatchEvent(event);
-      }
+      
 
       const mesh = image.mesh;
       const target = image;
@@ -407,7 +399,16 @@ export class OrientedImageLoader {
       const newCamTarget = mesh.position.clone();
 
       viewer.scene.view.setView(newCamPos, newCamTarget);
-
+	if (sendEvent) {
+        const event = new CustomEvent("imageLoad", {
+          detail: {
+            viewer: viewer.canvasId,
+            image,
+          },
+        });
+        document.dispatchEvent(event);
+      }
+	  
       function loadImageTexture(path) {
         return new Promise((resolve, reject) => {
           new THREE.TextureLoader().load(path, (texture) => {
diff --git a/src/navigation/OrbitControls.js b/src/navigation/OrbitControls.js
index 1d21da93..fed504a3 100644
--- a/src/navigation/OrbitControls.js
+++ b/src/navigation/OrbitControls.js
@@ -276,6 +276,15 @@ export class OrbitControls extends EventDispatcher {
       yaw -= progression * this.yawDelta;
       pitch -= progression * this.pitchDelta;
 
+		if(pitch < -1 * 0.3)
+		{
+			pitch= -1 * 0.3
+		}
+		else if(pitch > 1.3)
+		{
+			pitch = 1.3
+		}
+		
       view.yaw = yaw;
       view.pitch = pitch;
 
-- 
2.38.1.windows.1


From a3ca317809eaa9c81648e53b982ff673e8b56fd9 Mon Sep 17 00:00:00 2001
From: SathyaKrishna Vanama <sathyakrishna.vanama@constructn.ai>
Date: Wed, 28 Jun 2023 17:41:49 +0530
Subject: [PATCH 03/11] conditions is added for 360 image   rings visibility

---
 src/modules/Images360/Images360.js | 24 +++++++++++++++++++++---
 1 file changed, 21 insertions(+), 3 deletions(-)

diff --git a/src/modules/Images360/Images360.js b/src/modules/Images360/Images360.js
index 0db1c26d..c7d5403b 100644
--- a/src/modules/Images360/Images360.js
+++ b/src/modules/Images360/Images360.js
@@ -107,7 +107,14 @@ export class Images360 extends EventDispatcher{
 		};
 		this.viewer.setControls(this.viewer.orbitControls);
 		this.viewer.orbitControls.doubleClockZoomEnabled = false;
-		let index = this.images.findIndex( element => {
+		if (
+        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
+          navigator.userAgent
+        ) ||
+        (window.innerWidth <= 768))
+        {
+          
+        let index = this.images.findIndex( element => {
 		if (element.file === image360.file) {
 		return true;
 		}
@@ -145,6 +152,11 @@ export class Images360 extends EventDispatcher{
 			this.images[i].mesh.visible = true
 		
 		this.selectingEnabled = true;
+		}
+		else
+		{
+			this.selectingEnabled = false;
+		}
 		this.sphere.visible = false;
 		this.load(image360).then( () => {
 			this.sphere.visible = true;
@@ -347,9 +359,15 @@ export class Images360Loader{
 			const fileBNumber = getFileNumber(b.file);
 			return fileANumber.localeCompare(fileBNumber);
 		});
-		
-		Images360Loader.createSceneNodes(images360, params.transform);
 
+		if (
+        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
+          navigator.userAgent
+        ) ||
+        (window.innerWidth <= 768))
+        {
+           Images360Loader.createSceneNodes(images360, params.transform);
+        }
 		return images360;
 
 	}
-- 
2.38.1.windows.1


From 1356855bfa2406c97415fa9a0a9be68569c2ae14 Mon Sep 17 00:00:00 2001
From: SathyaKrishna Vanama <sathyakrishna.vanama@constructn.ai>
Date: Wed, 12 Jul 2023 17:37:28 +0530
Subject: [PATCH 04/11] code chnages

---
 src/modules/Images360/Images360.js | 50 ++++++++++++++----------------
 src/navigation/OrbitControls.js    | 19 +++++-------
 2 files changed, 32 insertions(+), 37 deletions(-)

diff --git a/src/modules/Images360/Images360.js b/src/modules/Images360/Images360.js
index c7d5403b..63e92c3d 100644
--- a/src/modules/Images360/Images360.js
+++ b/src/modules/Images360/Images360.js
@@ -54,11 +54,25 @@ export class Images360 extends EventDispatcher{
 		this.addEventListener("mousedown", () => {
 			if(this.currentlyHovered && this.currentlyHovered.image360){
 				this.focus(this.currentlyHovered.image360);
+				const event = new CustomEvent("onRingClick", {
+                    detail: {
+                        viewer: this.viewer.canvasId,
+                        image: this.currentlyHovered.image360
+                    }
+                });
+                document.dispatchEvent(event);
 			}
 		});
 		this.addEventListener("touchend", () => {
 			if(this.currentlyHovered && this.currentlyHovered.image360){
 				this.focus(this.currentlyHovered.image360);
+				const event = new CustomEvent("onRingClick", {
+                    detail: {
+                        viewer: this.viewer.canvasId,
+                        image: this.currentlyHovered.image360
+                    }
+                });
+                document.dispatchEvent(event);
 			}
 		});
 	};
@@ -106,15 +120,9 @@ export class Images360 extends EventDispatcher{
 			target: this.viewer.scene.view.getPivot(),
 		};
 		this.viewer.setControls(this.viewer.orbitControls);
+		this.viewer.orbitControls.isInterior = true;
 		this.viewer.orbitControls.doubleClockZoomEnabled = false;
-		if (
-        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
-          navigator.userAgent
-        ) ||
-        (window.innerWidth <= 768))
-        {
-          
-        let index = this.images.findIndex( element => {
+		let index = this.images.findIndex( element => {
 		if (element.file === image360.file) {
 		return true;
 		}
@@ -132,31 +140,27 @@ export class Images360 extends EventDispatcher{
 			let current = new THREE.Vector3(this.images[index].position[0], this.images[index].position[1], this.images[index].position[2])
 			let next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
 			let dist = current.distanceTo(next)
-			while(dist < 0.5 && i > 0) {
+			while(dist < 3 && i > -1) {
 				i--
 				next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
 				dist = current.distanceTo(next)
 			}
-			this.images[i].mesh.visible = true
+			if(i>-1)this.images[i].mesh.visible = true
 			
 		}
 			let i = index + 1
 			let current = new THREE.Vector3(this.images[index].position[0], this.images[index].position[1], this.images[index].position[2])
 			let next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
 			let dist = current.distanceTo(next)
-			while(dist < 0.5) {
+			while(dist < 3 && i<this.images.length) {
 				i++
 				next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
 				dist = current.distanceTo(next)
 			}
-			this.images[i].mesh.visible = true
+			if(i<this.images.length)this.images[i].mesh.visible = true
 		
 		this.selectingEnabled = true;
-		}
-		else
-		{
-			this.selectingEnabled = false;
-		}
+		
 		this.sphere.visible = false;
 		this.load(image360).then( () => {
 			this.sphere.visible = true;
@@ -210,6 +214,7 @@ export class Images360 extends EventDispatcher{
 		let newCamPos = target.clone().sub(move);
 
 		this.viewer.orbitControls.doubleClockZoomEnabled = true;
+		this.viewer.orbitControls.isInterior = false;
 		this.viewer.setControls(this.previousView.controls);
 		this.focusedImage = null;
 		
@@ -360,15 +365,8 @@ export class Images360Loader{
 			return fileANumber.localeCompare(fileBNumber);
 		});
 
-		if (
-        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
-          navigator.userAgent
-        ) ||
-        (window.innerWidth <= 768))
-        {
-           Images360Loader.createSceneNodes(images360, params.transform);
-        }
-		return images360;
+		 Images360Loader.createSceneNodes(images360);
+			return images360;
 
 	}
 
diff --git a/src/navigation/OrbitControls.js b/src/navigation/OrbitControls.js
index fed504a3..2ed5150c 100644
--- a/src/navigation/OrbitControls.js
+++ b/src/navigation/OrbitControls.js
@@ -37,7 +37,7 @@ export class OrbitControls extends EventDispatcher {
     this.radiusDelta = 0;
 
     this.doubleClockZoomEnabled = true;
-
+	this.isInterior=false
     this.tweens = [];
 
     this.changeEvent = new CustomEvent("camerachange");
@@ -275,16 +275,13 @@ export class OrbitControls extends EventDispatcher {
 
       yaw -= progression * this.yawDelta;
       pitch -= progression * this.pitchDelta;
-
-		if(pitch < -1 * 0.3)
-		{
-			pitch= -1 * 0.3
-		}
-		else if(pitch > 1.3)
-		{
-			pitch = 1.3
-		}
-		
+	if (this.isInterior) {
+      if (pitch < -1 * 0.3) {
+        pitch = -1 * 0.3;
+      } else if (pitch > 1.3) {
+        pitch = 1.3;
+      }
+    }	
       view.yaw = yaw;
       view.pitch = pitch;
 
-- 
2.38.1.windows.1


From 0f859e01a5c5d2705aeca7a38887af66248dfe8f Mon Sep 17 00:00:00 2001
From: SathyaKrishna Vanama <sathyakrishna.vanama@constructn.ai>
Date: Wed, 12 Jul 2023 17:45:12 +0530
Subject: [PATCH 05/11] code changes

---
 examples/lion_las.html | 60 ++++++++++++------------------------------
 1 file changed, 17 insertions(+), 43 deletions(-)

diff --git a/examples/lion_las.html b/examples/lion_las.html
index fe233423..2df2bdb5 100644
--- a/examples/lion_las.html
+++ b/examples/lion_las.html
@@ -75,46 +75,7 @@
         $("#menu_appearance").next().show();
       });
 
-      function isMobileDevice() {
-        // Check for a specific mobile user agent string or screen size
-        // Modify this condition based on your requirements
-        console.log("fduihsdfju8iyshdfgyusifdhkjsdfhyuik", navigator.userAgent);
-        return (
-          /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
-            navigator.userAgent
-          ) || window.innerWidth <= 768
-        );
-      }
-
-      // Execute code only for the mobile version
-      if (isMobileDevice()) {
-        // Your mobile-specific code here
-        console.log("Running on a mobile device");
-        viewer.setDescription(`<button id="myButton">Next Image</button> `);
-        var button = document.getElementById("myButton");
-        button.addEventListener("click", function () {
-          i++;
-          console.log("sdujksdn", i);
-          //   viewer.scene.orientedImages[0].moveToImage(
-          //     viewer.scene.orientedImages[0].images[i]
-          //   );
-          viewer.scene.images360[0].focus(viewer.scene.images360[0].images[i]);
-          //removeAssets(viewer);
-        });
-      } else {
-        // Your web-specific code here
-        console.log("Running on the web", navigator.userAgent);
-      }
-      // Add a click event listener to the button
-      //   button.addEventListener("click", function () {
-      //     i++;
-      //     nextPanoImage(viewer);
-      //     // viewer.scene.orientedImages[0].moveToImage(
-      //     //   viewer.scene.orientedImages[0].images[i]
-      //     // );
-      //     //viewer.scene.images360[0].focus(viewer.scene.images360[0].images[i]);
-      //     //removeAssets(viewer);
-      //   });
+     
       let viewerMode = "image";
       // Sigeom
       Potree.loadPointCloud(
@@ -153,9 +114,22 @@
           let pcOffset = [0, 0, 0];
           pcMatrix = new THREE.Matrix4()
             .fromArray([
-              1.000465, 0.003179, 0.000021, -10232.804688, -0.003179, 1.000465,
-              0.000031, -231.655838, -0.000021, -0.000031, 1.00047, -1272.54834,
-              0.0, 0.0, 0.0, 1.0,
+            1,
+            0,
+            0,
+            0,
+            0,
+            1,
+            0,
+            0,
+            0,
+            0,
+            1,
+            0,
+            0,
+            0,
+            0,
+            1
             ])
             .transpose();
           pointcloud.applyMatrix(pcMatrix);
-- 
2.38.1.windows.1


From abbb15298fad7c727b310c029fa3a8eb74eea7da Mon Sep 17 00:00:00 2001
From: SathyaKrishna Vanama <sathyakrishna.vanama@constructn.ai>
Date: Thu, 13 Jul 2023 12:55:30 +0530
Subject: [PATCH 06/11] Ring geometry modification for clicking all over the
 circle completed

---
 src/modules/Images360/Images360.js | 55 +++++++++++++++++++-----------
 1 file changed, 36 insertions(+), 19 deletions(-)

diff --git a/src/modules/Images360/Images360.js b/src/modules/Images360/Images360.js
index 63e92c3d..fcba8200 100644
--- a/src/modules/Images360/Images360.js
+++ b/src/modules/Images360/Images360.js
@@ -43,8 +43,7 @@ export class Images360 extends EventDispatcher{
 			target: null,
 		};
 		this.raycaster = new THREE.Raycaster();
-		this.hoverMaterial = new THREE.MeshBasicMaterial({side: THREE.DoubleSide});
-		this.sm = new THREE.MeshBasicMaterial({side: THREE.DoubleSide,color:'#FF843F'});
+		this.hoverMaterial = new THREE.MeshBasicMaterial({side: THREE.BackSide});
 		
 		viewer.addEventListener("update", () => {
 			this.update(viewer);
@@ -84,7 +83,7 @@ export class Images360 extends EventDispatcher{
 
 
 		for(const image of this.images){
-			image.mesh.visible = visible && (this.focusedImage == null);
+			image.circleMesh.visible = visible && (this.focusedImage == null);
 		}
 
 		this.sphere.visible = visible && (this.focusedImage != null);
@@ -129,8 +128,9 @@ export class Images360 extends EventDispatcher{
 		});
 		
 		for(let image of this.images){
-			
-			image.mesh.visible = false;
+
+			image.circleMesh.visible = false;
+			image.ringMesh.visible=false
 		}
 		
 		if(index != 0)
@@ -145,7 +145,11 @@ export class Images360 extends EventDispatcher{
 				next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
 				dist = current.distanceTo(next)
 			}
-			if(i>-1)this.images[i].mesh.visible = true
+			if(i>-1)
+			{
+			this.images[i].circleMesh.visible = true
+			this.images[i].ringMesh.visible = true	
+			}
 			
 		}
 			let i = index + 1
@@ -157,7 +161,11 @@ export class Images360 extends EventDispatcher{
 				next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
 				dist = current.distanceTo(next)
 			}
-			if(i<this.images.length)this.images[i].mesh.visible = true
+			if(i<this.images.length)
+			{
+			this.images[i].circleMesh.visible = true
+			this.images[i].ringMesh.visible = true	
+			}
 		
 		this.selectingEnabled = true;
 		
@@ -276,12 +284,12 @@ export class Images360 extends EventDispatcher{
 		let ray = Potree.Utils.mouseToRay(mouse, camera, domElement.clientWidth, domElement.clientHeight);
 		this.raycaster.ray.copy(ray);
 		let intersections = this.raycaster.intersectObjects(this.images.map(image=>{
-			return image.mesh}));
+			return image.circleMesh}));
 		if(intersections.length === 0){
 			return;
 		}
 		let intersection = intersections[0];
-		if(intersection.object.image360.mesh.visible===true)
+		if(intersection.object.image360.circleMesh.visible===true)
 		{
 		this.currentlyHovered = intersection.object;
 		this.currentlyHovered.material = this.hoverMaterial;
@@ -292,9 +300,8 @@ export class Images360 extends EventDispatcher{
 	update(){
 
 		let {viewer} = this;
-
 		if(this.currentlyHovered){
-			this.currentlyHovered.material = this.sm;
+			this.currentlyHovered.material = this.handleHovering;
 			this.currentlyHovered = null;
 		}
 
@@ -374,14 +381,24 @@ export class Images360Loader{
 
 		for(let image360 of images360.images){
 			let {longitude, latitude, altitude} = image360;
-			let mesh = new THREE.Mesh(new THREE.RingGeometry( 0.5, 1, 32 ), new THREE.MeshBasicMaterial({side: THREE.DoubleSide, color:'#FF843F'}));
-			mesh.position.set(longitude, latitude, altitude - 2.0);
-			mesh.scale.set(1, 1, 1);
-			mesh.material.transparent = true;
-			mesh.material.opacity = 0.75;
-			mesh.image360 = image360;
-			images360.node.add(mesh);
-			image360.mesh = mesh;
+			let ringMesh = new THREE.Mesh(new THREE.RingGeometry( 0.5, 1, 32 ), new THREE.MeshBasicMaterial({side: THREE.DoubleSide, color:'#FF843F'}));
+			ringMesh.position.set(longitude, latitude, altitude - 2.0);
+			ringMesh.scale.set(1, 1, 1);
+			ringMesh.material.transparent = true;
+			ringMesh.material.opacity = 0.75;
+			ringMesh.image360 = image360;
+			let circleMesh = new THREE.Mesh(new THREE.CircleGeometry( 1, 32 ), new THREE.MeshBasicMaterial({side:THREE.DoubleSide}));
+			circleMesh.position.set(longitude, latitude, altitude - 2.0);
+			circleMesh.scale.set(1, 1, 1);
+			circleMesh.material.transparent = true;
+			circleMesh.material.opacity = 0;
+			circleMesh.image360 = image360;
+			const group = new THREE.Group();
+			group.add( ringMesh );
+			group.add( circleMesh );
+			images360.node.add(group);
+			image360.circleMesh = circleMesh;
+			image360.ringMesh = ringMesh;
 		}
 	}
 };
-- 
2.38.1.windows.1


From 530510e78b7f780f4473097d2f0bd5d400278bf7 Mon Sep 17 00:00:00 2001
From: SathyaKrishna Vanama <sathyakrishna.vanama@constructn.ai>
Date: Thu, 13 Jul 2023 15:52:58 +0530
Subject: [PATCH 07/11] ring color changing when hovering

---
 src/modules/Images360/Images360.js | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/src/modules/Images360/Images360.js b/src/modules/Images360/Images360.js
index fcba8200..a427a79c 100644
--- a/src/modules/Images360/Images360.js
+++ b/src/modules/Images360/Images360.js
@@ -43,8 +43,8 @@ export class Images360 extends EventDispatcher{
 			target: null,
 		};
 		this.raycaster = new THREE.Raycaster();
-		this.hoverMaterial = new THREE.MeshBasicMaterial({side: THREE.BackSide});
-		
+		this.hoverMaterial = new THREE.MeshBasicMaterial({side: THREE.DoubleSide,color:''});
+		this.sm = new THREE.MeshBasicMaterial({side: THREE.DoubleSide,color:'#FF843F'});
 		viewer.addEventListener("update", () => {
 			this.update(viewer);
 		});
@@ -291,7 +291,7 @@ export class Images360 extends EventDispatcher{
 		let intersection = intersections[0];
 		if(intersection.object.image360.circleMesh.visible===true)
 		{
-		this.currentlyHovered = intersection.object;
+		this.currentlyHovered = intersection.object.parent.children[0];
 		this.currentlyHovered.material = this.hoverMaterial;
 		}
 		
@@ -301,7 +301,7 @@ export class Images360 extends EventDispatcher{
 
 		let {viewer} = this;
 		if(this.currentlyHovered){
-			this.currentlyHovered.material = this.handleHovering;
+			this.currentlyHovered.material = this.sm;
 			this.currentlyHovered = null;
 		}
 
-- 
2.38.1.windows.1


From 93e974b0c17287945e48e0deac6a08334b8f066a Mon Sep 17 00:00:00 2001
From: SathyaKrishna Vanama <sathyakrishna.vanama@constructn.ai>
Date: Thu, 13 Jul 2023 17:13:25 +0530
Subject: [PATCH 08/11] ring geometry nameing convention changes

---
 src/modules/Images360/Images360.js | 42 ++++++++++++++----------------
 1 file changed, 20 insertions(+), 22 deletions(-)

diff --git a/src/modules/Images360/Images360.js b/src/modules/Images360/Images360.js
index a427a79c..9eca6a46 100644
--- a/src/modules/Images360/Images360.js
+++ b/src/modules/Images360/Images360.js
@@ -12,7 +12,8 @@ class Image360{
 		this.course = course;
 		this.pitch = pitch;
 		this.roll = roll;
-		this.mesh = null;
+		this.ringGroup=null
+		this.visibleRings=[]
 	}
 };
 
@@ -27,7 +28,7 @@ export class Images360 extends EventDispatcher{
 
 		this.images = [];
 		this.node = new THREE.Object3D();
-
+		this.visibleRings=[]		
 		this.sphere = new THREE.Mesh(new THREE.SphereGeometry(1, 128, 128), new THREE.MeshBasicMaterial({side: THREE.BackSide}));
 		this.sphere.visible = false;
 		this.sphere.scale.set(-1000, 1000, 1000);
@@ -83,7 +84,7 @@ export class Images360 extends EventDispatcher{
 
 
 		for(const image of this.images){
-			image.circleMesh.visible = visible && (this.focusedImage == null);
+			image.ringGroup.visible = visible && (this.focusedImage == null);
 		}
 
 		this.sphere.visible = visible && (this.focusedImage != null);
@@ -128,9 +129,7 @@ export class Images360 extends EventDispatcher{
 		});
 		
 		for(let image of this.images){
-
-			image.circleMesh.visible = false;
-			image.ringMesh.visible=false
+			image.ringGroup.visible=false
 		}
 		
 		if(index != 0)
@@ -140,15 +139,15 @@ export class Images360 extends EventDispatcher{
 			let current = new THREE.Vector3(this.images[index].position[0], this.images[index].position[1], this.images[index].position[2])
 			let next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
 			let dist = current.distanceTo(next)
-			while(dist < 3 && i > -1) {
+			while(dist < 3 && i > 0) {
 				i--
 				next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
 				dist = current.distanceTo(next)
 			}
 			if(i>-1)
 			{
-			this.images[i].circleMesh.visible = true
-			this.images[i].ringMesh.visible = true	
+			this.images[i].ringGroup.visible = true
+			this.visibleRings.push(this.images[i])
 			}
 			
 		}
@@ -163,8 +162,8 @@ export class Images360 extends EventDispatcher{
 			}
 			if(i<this.images.length)
 			{
-			this.images[i].circleMesh.visible = true
-			this.images[i].ringMesh.visible = true	
+			this.images[i].ringGroup.visible = true
+			this.visibleRings.push(this.images[i])	
 			}
 		
 		this.selectingEnabled = true;
@@ -283,13 +282,13 @@ export class Images360 extends EventDispatcher{
 		let domElement = this.viewer.renderer.domElement;
 		let ray = Potree.Utils.mouseToRay(mouse, camera, domElement.clientWidth, domElement.clientHeight);
 		this.raycaster.ray.copy(ray);
-		let intersections = this.raycaster.intersectObjects(this.images.map(image=>{
-			return image.circleMesh}));
+		let intersections = this.raycaster.intersectObjects(this.visibleRings.map(image=>{
+			return image.ringGroup.children[1]}));
 		if(intersections.length === 0){
 			return;
 		}
 		let intersection = intersections[0];
-		if(intersection.object.image360.circleMesh.visible===true)
+		if(intersection.object.parent.visible===true)
 		{
 		this.currentlyHovered = intersection.object.parent.children[0];
 		this.currentlyHovered.material = this.hoverMaterial;
@@ -381,24 +380,23 @@ export class Images360Loader{
 
 		for(let image360 of images360.images){
 			let {longitude, latitude, altitude} = image360;
-			let ringMesh = new THREE.Mesh(new THREE.RingGeometry( 0.5, 1, 32 ), new THREE.MeshBasicMaterial({side: THREE.DoubleSide, color:'#FF843F'}));
+			let ringMesh = new THREE.Mesh(new THREE.RingGeometry( 0.35, .5, 32 ), new THREE.MeshBasicMaterial({side: THREE.DoubleSide, color:'#FF843F'}));
 			ringMesh.position.set(longitude, latitude, altitude - 2.0);
 			ringMesh.scale.set(1, 1, 1);
 			ringMesh.material.transparent = true;
 			ringMesh.material.opacity = 0.75;
 			ringMesh.image360 = image360;
-			let circleMesh = new THREE.Mesh(new THREE.CircleGeometry( 1, 32 ), new THREE.MeshBasicMaterial({side:THREE.DoubleSide}));
+			let circleMesh = new THREE.Mesh(new THREE.CircleGeometry( .5, 32 ), new THREE.MeshBasicMaterial({side:THREE.DoubleSide}));
 			circleMesh.position.set(longitude, latitude, altitude - 2.0);
 			circleMesh.scale.set(1, 1, 1);
 			circleMesh.material.transparent = true;
 			circleMesh.material.opacity = 0;
 			circleMesh.image360 = image360;
-			const group = new THREE.Group();
-			group.add( ringMesh );
-			group.add( circleMesh );
-			images360.node.add(group);
-			image360.circleMesh = circleMesh;
-			image360.ringMesh = ringMesh;
+			const ringGroup = new THREE.Group();
+			ringGroup.add( ringMesh );
+			ringGroup.add( circleMesh );
+			images360.node.add(ringGroup);
+			image360.ringGroup=ringGroup
 		}
 	}
 };
-- 
2.38.1.windows.1


From 0b71001c620095327cfea5b86ed76513bdd95f16 Mon Sep 17 00:00:00 2001
From: SathyaKrishna Vanama <sathyakrishna.vanama@constructn.ai>
Date: Thu, 13 Jul 2023 18:56:11 +0530
Subject: [PATCH 09/11] ring displaying condition changed

---
 src/modules/Images360/Images360.js | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/modules/Images360/Images360.js b/src/modules/Images360/Images360.js
index 9eca6a46..189fe367 100644
--- a/src/modules/Images360/Images360.js
+++ b/src/modules/Images360/Images360.js
@@ -155,7 +155,7 @@ export class Images360 extends EventDispatcher{
 			let current = new THREE.Vector3(this.images[index].position[0], this.images[index].position[1], this.images[index].position[2])
 			let next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
 			let dist = current.distanceTo(next)
-			while(dist < 3 && i<this.images.length) {
+			while(dist < 3 && i<this.images.length-1) {
 				i++
 				next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
 				dist = current.distanceTo(next)
-- 
2.38.1.windows.1


From 3dca99a42858ada0dc9b1bc855abad0a7a157572 Mon Sep 17 00:00:00 2001
From: SathyaKrishna Vanama <sathyakrishna.vanama@constructn.ai>
Date: Wed, 26 Jul 2023 12:59:47 +0530
Subject: [PATCH 10/11] condition is added in Image 360 file and commands file
 is removed

---
 .gitignore                         |  2 +-
 commands.txt                       | 19 -------------------
 src/modules/Images360/Images360.js |  5 +++--
 3 files changed, 4 insertions(+), 22 deletions(-)
 delete mode 100644 commands.txt

diff --git a/.gitignore b/.gitignore
index 6931aa9e..aaa1ed5f 100644
--- a/.gitignore
+++ b/.gitignore
@@ -15,7 +15,7 @@ libs/CesiumUnminified
 /examples/page.html
 /resources/icons/index.html
 /examples/page.html
-
+/commands.txt
 /pointclouds/retz
 /pointclouds/NVIDIA_Ph01-20160403_tiles_converted
 /pointclouds/D
diff --git a/commands.txt b/commands.txt
deleted file mode 100644
index ddfbd1a3..00000000
--- a/commands.txt
+++ /dev/null
@@ -1,19 +0,0 @@
-curl -v 'https://developer.api.autodesk.com/authentication/v1/authenticate' -X 'POST' -H 'Content-Type: application/x-www-form-urlencoded' -d 'client_id=aJRMrmok5UAbsdsXjckJmSBmoNnYKLzM&client_secret=mSqemcEE53l4THBJ&grant_type=client_credentials&scope=data:read%20data:write%20viewables:read%20bucket:create%20bucket:read'
-
-eyJhbGciOiJSUzI1NiIsImtpZCI6IlU3c0dGRldUTzlBekNhSzBqZURRM2dQZXBURVdWN2VhIn0.eyJzY29wZSI6WyJkYXRhOnJlYWQiLCJkYXRhOndyaXRlIiwidmlld2FibGVzOnJlYWQiLCJidWNrZXQ6Y3JlYXRlIiwiYnVja2V0OnJlYWQiXSwiY2xpZW50X2lkIjoiYUpSTXJtb2s1VUFic2RzWGpja0ptU0Jtb05uWUtMek0iLCJhdWQiOiJodHRwczovL2F1dG9kZXNrLmNvbS9hdWQvYWp3dGV4cDYwIiwianRpIjoibk5iYVlqamRLME5OU1QzVndneHFtbEVVRFZaM1h0b2VydUtBM1FQSkxva2JQSVBMbWRaeWlQMUNIb2JnalZwUCIsImV4cCI6MTYyNTY1OTQ0NH0.CdolgqfI6YO4Bc7U7c3FGIR080fwlwDAXauXKPg4eqgjSdaYYdgK_ch-ahO-STi_Nl2p7a2TirotH3opgYp0CbyyXL6_fd8ETkk6eX0vKU0LOo7D6gk0CtigKWF7Xxta6icsWUM80lDNppYiSW1Cn1pWaAxHyQ4aSqfjlNVRdQ48V-d8MJ6VmbgCz57UyCcmUtkESrwgYzxOmvoVqwWDA72J6Uoj4gHU5pJnDjaOtzaOzIui11V1dgMZgsUkkoa1GpzarIsRKMeBGhyldTOD474pKn-L-vhM7qtfYjTbq24w9hHAHsnxWvuBdCMogwoWLh4mek4HPO72YpwTQAd8wA
-
-curl -v 'https://developer.api.autodesk.com/oss/v2/buckets' -X 'POST' -H 'Content-Type: application/json' -H 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsImtpZCI6Imp3dF9zeW1tZXRyaWNfa2V5In0.eyJjbGllbnRfaWQiOiJpWFdZbTNGVkdNaExZTHNzQVFBd2RNR01xNUhzQXdOYiIsImV4cCI6MTU4NTEyMTY0NSwic2NvcGUiOlsiZGF0YTpyZWFkIiwiZGF0YTp3cml0ZSIsInZpZXdhYmxlczpyZWFkIiwiYnVja2V0OmNyZWF0ZSIsImJ1Y2tldDpyZWFkIl0sImF1ZCI6Imh0dHBzOi8vYXV0b2Rlc2suY29tL2F1ZC9qd3RleHA2MCIsImp0aSI6Im10VklEWGtrOUJwUVBUYU84UlpEV3NWNWpCSHR3VkRObUIwVlN3dnJVeXFiNTVveFlibW5vaUNsMk02Vks4Ym4ifQ.71YkbtExiXDVkWeGODigBWGViNj9_5RSHwTjgvd_MME' -d '{"bucketKey":"threeforge","policyKey":"transient"}'
-digitaltwins
-Verify Bucket
-curl -v 'https://developer.api.autodesk.com/oss/v2/buckets/dtwin/details' -X 'GET' -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IlU3c0dGRldUTzlBekNhSzBqZURRM2dQZXBURVdWN2VhIn0.eyJzY29wZSI6WyJkYXRhOnJlYWQiLCJkYXRhOndyaXRlIiwidmlld2FibGVzOnJlYWQiLCJidWNrZXQ6Y3JlYXRlIiwiYnVja2V0OnJlYWQiXSwiY2xpZW50X2lkIjoiYUpSTXJtb2s1VUFic2RzWGpja0ptU0Jtb05uWUtMek0iLCJhdWQiOiJodHRwczovL2F1dG9kZXNrLmNvbS9hdWQvYWp3dGV4cDYwIiwianRpIjoibk5iYVlqamRLME5OU1QzVndneHFtbEVVRFZaM1h0b2VydUtBM1FQSkxva2JQSVBMbWRaeWlQMUNIb2JnalZwUCIsImV4cCI6MTYyNTY1OTQ0NH0.CdolgqfI6YO4Bc7U7c3FGIR080fwlwDAXauXKPg4eqgjSdaYYdgK_ch-ahO-STi_Nl2p7a2TirotH3opgYp0CbyyXL6_fd8ETkk6eX0vKU0LOo7D6gk0CtigKWF7Xxta6icsWUM80lDNppYiSW1Cn1pWaAxHyQ4aSqfjlNVRdQ48V-d8MJ6VmbgCz57UyCcmUtkESrwgYzxOmvoVqwWDA72J6Uoj4gHU5pJnDjaOtzaOzIui11V1dgMZgsUkkoa1GpzarIsRKMeBGhyldTOD474pKn-L-vhM7qtfYjTbq24w9hHAHsnxWvuBdCMogwoWLh4mek4HPO72YpwTQAd8wA'
-
-
-curl -v 'https://developer.api.autodesk.com/oss/v2/buckets/dtwin/objects/floor_4.ifc' -X 'PUT' -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IlU3c0dGRldUTzlBekNhSzBqZURRM2dQZXBURVdWN2VhIn0.eyJzY29wZSI6WyJkYXRhOnJlYWQiLCJkYXRhOndyaXRlIiwidmlld2FibGVzOnJlYWQiLCJidWNrZXQ6Y3JlYXRlIiwiYnVja2V0OnJlYWQiXSwiY2xpZW50X2lkIjoiYUpSTXJtb2s1VUFic2RzWGpja0ptU0Jtb05uWUtMek0iLCJhdWQiOiJodHRwczovL2F1dG9kZXNrLmNvbS9hdWQvYWp3dGV4cDYwIiwianRpIjoibk5iYVlqamRLME5OU1QzVndneHFtbEVVRFZaM1h0b2VydUtBM1FQSkxva2JQSVBMbWRaeWlQMUNIb2JnalZwUCIsImV4cCI6MTYyNTY1OTQ0NH0.CdolgqfI6YO4Bc7U7c3FGIR080fwlwDAXauXKPg4eqgjSdaYYdgK_ch-ahO-STi_Nl2p7a2TirotH3opgYp0CbyyXL6_fd8ETkk6eX0vKU0LOo7D6gk0CtigKWF7Xxta6icsWUM80lDNppYiSW1Cn1pWaAxHyQ4aSqfjlNVRdQ48V-d8MJ6VmbgCz57UyCcmUtkESrwgYzxOmvoVqwWDA72J6Uoj4gHU5pJnDjaOtzaOzIui11V1dgMZgsUkkoa1GpzarIsRKMeBGhyldTOD474pKn-L-vhM7qtfYjTbq24w9hHAHsnxWvuBdCMogwoWLh4mek4HPO72YpwTQAd8wA' -H 'Content-Type: application/octet-stream' -T 'floor_4.ifc'
-
-urn:adsk.objects:os.object:dtwin/floor_4.ifc
-
-dXJuOmFkc2sub2JqZWN0czpvcy5vYmplY3Q6ZHR3aW4vZmxvb3JfNC5pZmM=
-
-curl -X 'POST' -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IlU3c0dGRldUTzlBekNhSzBqZURRM2dQZXBURVdWN2VhIn0.eyJzY29wZSI6WyJkYXRhOnJlYWQiLCJkYXRhOndyaXRlIiwidmlld2FibGVzOnJlYWQiLCJidWNrZXQ6Y3JlYXRlIiwiYnVja2V0OnJlYWQiXSwiY2xpZW50X2lkIjoiYUpSTXJtb2s1VUFic2RzWGpja0ptU0Jtb05uWUtMek0iLCJhdWQiOiJodHRwczovL2F1dG9kZXNrLmNvbS9hdWQvYWp3dGV4cDYwIiwianRpIjoibk5iYVlqamRLME5OU1QzVndneHFtbEVVRFZaM1h0b2VydUtBM1FQSkxva2JQSVBMbWRaeWlQMUNIb2JnalZwUCIsImV4cCI6MTYyNTY1OTQ0NH0.CdolgqfI6YO4Bc7U7c3FGIR080fwlwDAXauXKPg4eqgjSdaYYdgK_ch-ahO-STi_Nl2p7a2TirotH3opgYp0CbyyXL6_fd8ETkk6eX0vKU0LOo7D6gk0CtigKWF7Xxta6icsWUM80lDNppYiSW1Cn1pWaAxHyQ4aSqfjlNVRdQ48V-d8MJ6VmbgCz57UyCcmUtkESrwgYzxOmvoVqwWDA72J6Uoj4gHU5pJnDjaOtzaOzIui11V1dgMZgsUkkoa1GpzarIsRKMeBGhyldTOD474pKn-L-vhM7qtfYjTbq24w9hHAHsnxWvuBdCMogwoWLh4mek4HPO72YpwTQAd8wA' -H 'Content-Type: application/json' -v 'https://developer.api.autodesk.com/modelderivative/v2/designdata/job' -d '{"input": {"urn": "dXJuOmFkc2sub2JqZWN0czpvcy5vYmplY3Q6ZHR3aW4vZmxvb3JfNC5pZmM="},"output":{"formats":[{"type":"svf","views":["2d","3d"]}]}}'
-
-curl -X 'GET' -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IlU3c0dGRldUTzlBekNhSzBqZURRM2dQZXBURVdWN2VhIn0.eyJzY29wZSI6WyJkYXRhOnJlYWQiLCJkYXRhOndyaXRlIiwidmlld2FibGVzOnJlYWQiLCJidWNrZXQ6Y3JlYXRlIiwiYnVja2V0OnJlYWQiXSwiY2xpZW50X2lkIjoiYUpSTXJtb2s1VUFic2RzWGpja0ptU0Jtb05uWUtMek0iLCJhdWQiOiJodHRwczovL2F1dG9kZXNrLmNvbS9hdWQvYWp3dGV4cDYwIiwianRpIjoibk5iYVlqamRLME5OU1QzVndneHFtbEVVRFZaM1h0b2VydUtBM1FQSkxva2JQSVBMbWRaeWlQMUNIb2JnalZwUCIsImV4cCI6MTYyNTY1OTQ0NH0.CdolgqfI6YO4Bc7U7c3FGIR080fwlwDAXauXKPg4eqgjSdaYYdgK_ch-ahO-STi_Nl2p7a2TirotH3opgYp0CbyyXL6_fd8ETkk6eX0vKU0LOo7D6gk0CtigKWF7Xxta6icsWUM80lDNppYiSW1Cn1pWaAxHyQ4aSqfjlNVRdQ48V-d8MJ6VmbgCz57UyCcmUtkESrwgYzxOmvoVqwWDA72J6Uoj4gHU5pJnDjaOtzaOzIui11V1dgMZgsUkkoa1GpzarIsRKMeBGhyldTOD474pKn-L-vhM7qtfYjTbq24w9hHAHsnxWvuBdCMogwoWLh4mek4HPO72YpwTQAd8wA' -v 'https://developer.api.autodesk.com/modelderivative/v2/designdata/dXJuOmFkc2sub2JqZWN0czpvcy5vYmplY3Q6ZHR3aW4vZmxvb3JfNC5pZmM=/manifest'
\ No newline at end of file
diff --git a/src/modules/Images360/Images360.js b/src/modules/Images360/Images360.js
index 189fe367..b547c404 100644
--- a/src/modules/Images360/Images360.js
+++ b/src/modules/Images360/Images360.js
@@ -151,6 +151,8 @@ export class Images360 extends EventDispatcher{
 			}
 			
 		}
+		if(index!=this.images.length-1)
+		{
 			let i = index + 1
 			let current = new THREE.Vector3(this.images[index].position[0], this.images[index].position[1], this.images[index].position[2])
 			let next = new THREE.Vector3(this.images[i].position[0], this.images[i].position[1], this.images[i].position[2])
@@ -165,7 +167,7 @@ export class Images360 extends EventDispatcher{
 			this.images[i].ringGroup.visible = true
 			this.visibleRings.push(this.images[i])	
 			}
-		
+		}
 		this.selectingEnabled = true;
 		
 		this.sphere.visible = false;
@@ -401,4 +403,3 @@ export class Images360Loader{
 	}
 };
 
-
-- 
2.38.1.windows.1


From 35e4d807c7b307b58d3814790b2b6dd4c13ad1a8 Mon Sep 17 00:00:00 2001
From: SathyaKrishna Vanama <sathyakrishna.vanama@constructn.ai>
Date: Wed, 26 Jul 2023 13:05:02 +0530
Subject: [PATCH 11/11] In oriented Images remove thumbnails code and added the
 loadeimage code

---
 src/modules/OrientedImages/OrientedImages.js | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/modules/OrientedImages/OrientedImages.js b/src/modules/OrientedImages/OrientedImages.js
index 4da9cd47..a65e1720 100644
--- a/src/modules/OrientedImages/OrientedImages.js
+++ b/src/modules/OrientedImages/OrientedImages.js
@@ -424,7 +424,8 @@ export class OrientedImageLoader {
       }
 
       viewer.scene.orientedImages[0].focused = image;
-      const tmpImagePath = `${imagesPath}/thumbnails/${target.id}`;
+    	const tmpImagePath = `${Potree.resourcePath}/images/loading.jpg`;
+      //const tmpImagePath = `${imagesPath}/thumbnails/${target.id}`;
       let texture = await loadImageTexture(tmpImagePath);
       updateTexture(texture);
       setTimeout(() => {
-- 
2.38.1.windows.1

